/**<
    Vector math, matrix math and geometry utilities. Roughly equivalent
    to geom.h in the core engine plus extensions.

    Author:
        q66 <quaker66@gmail.com>

    License:
        See COPYING.txt.
*/

import capi
import std.ffi

from std.table import rawget, rawset, pairs
from std.math import sin, cos, abs, min, max, sqrt, floor, atan2, asin, deg

var gen_vec2 = func(tp, sf, mt) {
    ffi::cdef(r"""
        typedef struct vec2%s_t {
            %s x, y;
        } vec2%s_t;
    """.format(sf, tp, sf))
    return ffi::metatype("vec2" ~ sf ~ "_t", mt), mt
}

var gen_vec3 = func(tp, sf, mt) {
    ffi::cdef(r"""
        typedef union vec3%s_t {
            struct { %s x, y, z; };
            struct { %s r, g, b; };
        } vec3%s_t;
    """.format(sf, tp, tp, sf))
    return ffi::metatype("vec3" ~ sf ~ "_t", mt), mt
}

var gen_vec4 = func(tp, sf, mt) {
    ffi::cdef(r"""
        typedef union vec4%s_t {
            struct { %s x, y, z, w; };
            struct { %s r, g, b, a; };
        } vec4%s_t;
    """.format(sf, tp, tp, sf))
    return ffi::metatype("vec4" ~ sf ~ "_t", mt), mt
}

var ffi_new = ffi.new
var clamp = func(v, l, h) {
    return max(l, min(v, h))
}

var iton = { 0: "x", 1: "y", 2: "z" }

var M = {}

/**
    Normalizes an angle to be within +-180 degrees of some value.
    Useful to know if we need to turn left or right in order to be
    closer to something (we just need to check the sign, after normalizing
    relative to that angle).

    For example, for angle 100 and rel_to 300, this function returns 460
    (as 460 is within 180 degrees of 300, but 100 isn't).
*/
var normalize_angle = func(angle, rel_to) {
    while angle < (rel_to - 180.0) { angle = angle + 360.0 }
    while angle > (rel_to + 180.0) { angle = angle - 360.0 }
    return angle
}
M.normalize_angle = normalize_angle

var Vec2, Vec2_mt; Vec2, Vec2_mt = gen_vec2("float", "f", {
    __new: func(self, x, y) {
        if typeof x == "number" {
            if !y {
                return ffi_new(self, x, x)
            } else {
                return ffi_new(self, x, y)
            }
        } else {
            return ffi_new(self, x.x, x.y)
        }
    },
    __tostring: func(self) {
        return "Vec2 <%f, %f>".format(self.x, self.y)
    },
    __eq: func(self, o) { return self.x == o.x && self.y == o.y },
    __mul: func(self, o) { return self.mul_new(o) },
    __div: func(self, o) { return self.div_new(o) },
    __add: func(self, o) { return self.add_new(o) },
    __sub: func(self, o) { return self.sub_new(o) },
    __index: {
        from_array: func(self, o) {
            return ffi_new(self, o[0], o[1])
        },
        copy: func(self) {
            return Vec2(self.x, self.y)
        },
        to_array: func(self) {
            return [ self.x, self.y ]
        },
        unpack: func(self) {
            return self.x, self.y
        },
        get_nth: func(self, n) { return self[iton[n - 1]] },
        set_nth: func(self, n, v) { self[iton[n - 1]] = v },
        is_zero: func(self) { return self.x == 0 && self.y == 0 },
        dot: func(self, o) { return self.x * o.x + self.y * o.y },
        dot_abs: func(self, o) {
            return abs(self.x * o.x) + abs(self.y * o.y)
        },
        squared_len: func(self) { return self.dot(self) },
        magnitude: func(self) { return sqrt(self.squared_len()) },
        normalize: func(self) {
            self.div(self.magnitude())
            return self
        },
        cross: func(self, o) { return self.x * o.y + self.y * o.x },
        mul: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x * o, self.y * o
            } else {
                self.x, self.y = self.x * o.x, self.y * o.y
            }
            return self
        },
        div: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x / o, self.y / o
            } else {
                self.x, self.y = self.x / o.x, self.y / o.y
            }
            return self
        },
        add: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x + o, self.y + o
            } else {
                self.x, self.y = self.x + o.x, self.y + o.y
            }
            return self
        },
        sub: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x - o, self.y - o
            } else {
                self.x, self.y = self.x - o.x, self.y - o.y
            }
            return self
        },
        mul_new: func(self, o) {
            if typeof o == "number" {
                return Vec2(self.x * o, self.y * o)
            } else {
                return Vec2(self.x * o.x, self.y * o.y)
            }
        },
        div_new: func(self, o) {
            if typeof o == "number" {
                return Vec2(self.x / o, self.y / o)
            } else {
                return Vec2(self.x / o.x, self.y / o.y)
            }
        },
        add_new: func(self, o) {
            if typeof o == "number" {
                return Vec2(self.x + o, self.y + o)
            } else {
                return Vec2(self.x + o.x, self.y + o.y)
            }
        },
        sub_new: func(self, o) {
            if typeof o == "number" {
                return Vec2(self.x - o, self.y - o)
            } else {
                return Vec2(self.x - o.x, self.y - o.y)
            }
        },
        neg: func(self) {
            self.x, self.y = -self.x, -self.y
            return self
        },
        min: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = min(self.x, o), min(self.y, o)
            } else {
                self.x, self.y = min(self.x, o.x), min(self.y, o.y)
            }
            return self
        },
        max: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = max(self.x, o), max(self.y, o)
            } else {
                self.x, self.y = max(self.x, o.x), max(self.y, o.y)
            }
            return self
        },
        abs: func(self) {
            self.x, self.y = abs(self.x), abs(self.y)
            return self
        },
        clamp: func(self, l, h) {
            self.x, self.y = clamp(self.x, l, h), clamp(self.y, l, h)
            return self
        },
        dist: func(self, o) {
            var dx, dy = self.x - o.x, self.y - o.y
            return sqrt(dx ** 2 + dy ** 2)
        },
        lerp: func(self, a, b, t) {
            if !t { a, b, t = self, a, b }
            self.x, self.y = a.x + (b.x - a.x) * t,
                             a.y * (b.y - a.y) * t
            return self
        },
        avg: func(self, b) { return self.add(b).mul(0.5) },
        rotate_around_z: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_z(cos(angle), sin(angle))
                } else {
                    var rx, ry = self.x, self.y
                    self.x, self.y = c * rx - s * ry, c * ry + s * rx
                    return self
                }
            } else {
                return self.rotate_around_z(c.x, c.y)
            }
        }
    }
})
M.Vec2 = Vec2

var Vec3, Vec3_mt; Vec3, Vec3_mt = gen_vec3("float", "f", {
    __new: func(self, x, y, z) {
        if typeof x == "number" {
            if !y && !z {
                return ffi_new(self, x, x, x)
            } else {
                return ffi_new(self, x, y, z)
            }
        } else {
            return ffi_new(self, x.x, x.y, x.z)
        }
    },
    __tostring: func(self) {
        return "Vec3 <%f, %f, %f>".format(self.x, self.y, self.z)
    },
    __eq: func(self, o) {
        return self.x == o.x && self.y == o.y && self.z == o.z
    },
    __mul: func(self, o) { return self.mul_new(o) },
    __div: func(self, o) { return self.div_new(o) },
    __add: func(self, o) { return self.add_new(o) },
    __sub: func(self, o) { return self.sub_new(o) },
    __index: {
        from_array: func(self, o) {
            return ffi_new(self, o[0], o[1], o[2])
        },
        from_vec2: func(self, o, z) {
            return ffi_new(self, o.x, o.y, z || 0)
        },
        from_yaw_pitch: func(self, yaw, pitch) {
            return ffi_new(self,
                -sin(yaw) * cos(pitch),
                 cos(yaw) * cos(pitch),
                 sin(pitch))
        },
        from_hex_color: func(self, color) {
            return ffi_new(self, ((color >> 16) & 0xFF) / 255,
                                 ((color >>  8) & 0xFF) / 255,
                                  (color        & 0xFF) / 255)
        },

        copy: func(self) {
            return Vec3(self.x, self.y, self.z)
        },
        to_array: func(self) {
            return [ self.x, self.y, self.z ]
        },
        unpack2: func(self) {
            return self.x, self.y
        },
        unpack: func(self) {
            return self.x, self.y, self.z
        },
        get_nth: func(self, n) { return self[iton[n - 1]] },
        set_nth: func(self, n, v) { self[iton[n - 1]] = v },
        is_zero: func(self) {
            return self.x == 0 && self.y == 0 && self.z == 0
        },
        dot2: func(self, o) { return self.x * o.x + self.y * o.y },
        dot: func(self, o) {
            return self.x * o.x + self.y * o.y + self.z * o.z
        },
        dot_abs: func(self, o) {
            return abs(self.x * o.x) + abs(self.y * o.y) + abs(self.z * o.z)
        },
        dot_z: func(self, o) {
            return self.z * o.z
        },
        squared_len: func(self) { return self.dot(self) },
        magnitude2: func(self) { return sqrt(self.dot2(self)) },
        magnitude: func(self) { return sqrt(self.squared_len()) },
        normalize: func(self) { return self.div(self.magnitude()) },
        is_normalized: func(self) {
            var m = self.squared_len()
            return m > 0.99 && m < 1.01
        },
        mul: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x * o, self.y * o, self.z * o
            } else {
                self.x, self.y, self.z = self.x * o.x, self.y * o.y,
                    self.z * o.z
            }
            return self
        },
        div: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x / o, self.y / o, self.z / o
            } else {
                self.x, self.y, self.z = self.x / o.x, self.y / o.y,
                    self.z / o.z
            }
            return self
        },
        add: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x + o, self.y + o, self.z + o
            } else {
                self.x, self.y, self.z = self.x + o.x, self.y + o.y,
                    self.z + o.z
            }
            return self
        },
        add_z: func(self, f) {
            self.z = self.z + f
            return self
        },
        sub: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x - o, self.y - o, self.z - o
            } else {
                self.x, self.y, self.z = self.x - o.x, self.y - o.y,
                    self.z - o.z
            }
            return self
        },
        sub_z: func(self, f) {
            self.z = self.z - f
            return self
        },
        mul_new: func(self, o) {
            if typeof o == "number" {
                return Vec3(self.x * o, self.y * o, self.z * o)
            } else {
                return Vec3(self.x * o.x, self.y * o.y, self.z * o.z)
            }
        },
        div_new: func(self, o) {
            if typeof o == "number" {
                return Vec3(self.x / o, self.y / o, self.z / o)
            } else {
                return Vec3(self.x / o.x, self.y / o.y, self.z / o.z)
            }
        },
        add_new: func(self, o) {
            if typeof o == "number" {
                return Vec3(self.x + o, self.y + o, self.z + o)
            } else {
                return Vec3(self.x + o.x, self.y + o.y, self.z + o.z)
            }
        },
        sub_new: func(self, o) {
            if typeof o == "number" {
                return Vec3(self.x - o, self.y - o, self.z - o)
            } else {
                return Vec3(self.x - o.x, self.y - o.y, self.z - o.z)
            }
        },
        neg2: func(self) {
            self.x, self.y = -self.x, -self.y
            return self
        },
        neg: func(self) {
            self.x, self.y, self.z = -self.x, -self.y, -self.z
            return self
        },
        min: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = min(self.x, o), min(self.y, o),
                    min(self.z, o)
            } else {
                self.x, self.y, self.z = min(self.x, o.x), min(self.y, o.y),
                    min(self.z, o.z)
            }
            return self
        },
        max: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = max(self.x, o), max(self.y, o),
                    max(self.z, o)
            } else {
                self.x, self.y, self.z = max(self.x, o.x), max(self.y, o.y),
                    max(self.z, o.z)
            }
            return self
        },
        abs: func(self) {
            self.x, self.y, self.z = abs(self.x), abs(self.y), abs(self.z)
            return self
        },
        clamp: func(self, l, h) {
            self.x, self.y, self.z = clamp(self.x, l, h), clamp(self.y, l, h),
                clamp(self.z, l, h)
            return self
        },
        squared_dist: func(self, e) {
            return self.sub_new(e).squared_len()
        },
        dist: func(self, e) {
            return self.sub_new(e).magnitude()
        },
        dist2: func(self, o) {
            var dx, dy = self.x - o.x, self.y - o.y
            return sqrt(dx ** 2 + dy ** 2)
        },
        reject: func(self, o, r) {
            return self.x > (o.x + r) || self.x < (o.x - r)
                || self.y > (o.y + r) || self.y < (o.y - r)
        },
        cross: func(self, a, b, o) {
            if o {
                return self.cross(a.sub_new(o), b.sub_new(o))
            }
            self.x, self.y, self.z = a.y * b.z - a.z * b.y,
                                     a.z * b.x - a.x * b.z,
                                     a.x * b.y - a.y * b.x
            return self
        },
        scalar_triple: func(self, a, b) {
            return self.x * (a.y * b.z - a.z * b.y)
                 + self.y * (a.z * b.x - a.x * b.z)
                 + self.z * (a.x * b.y - a.y * b.x)
        },
        scalar_triple_z: func(self, a, b) {
            return self.z * (a.x * b.y - a.y * b.x)
        },
        reflect_z: func(self, rz) {
            self.z = 2 * rz - self.z
            return self
        },
        reflect: func(self, n) {
            var k = 2 * self.dot(n)
            self.x, self.y, self.z = self.x - k * n.x,
                                     self.y - k * n.y,
                                     self.z - k * n.z
            return self
        },
        project: func(self, n) {
            var k = self.dot(n)
            self.x, self.y, self.z = self.x - k * n.x,
                                     self.y - k * n.y,
                                     self.z - k * n.z
            return self
        },
        project_xy_dir: func(self, n) {
            if n.z != 0 {
                self.z = -(self.x * n.x / n.z + self.y * n.y / n.z)
            }
            return self
        },
        project_xy: func(self, n, threshold) {
            var m = self.squared_len()
            var k = threshold && min(self.dot(n), threshold) || self.dot(n)
            self.project_xy_dir()
            self.rescale(sqrt(max(m - k ** 2, 0)))
            return self
        },
        lerp: func(self, a, b, t) {
            if !t { a, b, t = self, a, b }
            self.x, self.y, self.z = a.x + (b.x - a.x) * t,
                                     a.y * (b.y - a.y) * t,
                                     a.z * (b.z - a.z) * t
            return self
        },
        avg: func(self, b) { return self.add(b).mul(0.5) },
        rescale: func(self, k) {
            var mag = self.magnitude()
            if mag > 1e-6 { self.mul(k / mag) }
            return self
        },
        rotate_around_z: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_z(cos(angle), sin(angle))
                } else {
                    var rx, ry = self.x, self.y
                    self.x, self.y = c * rx - s * ry, c * ry + s * rx
                    return self
                }
            } else {
                return self.rotate_around_z(c.x, c.y)
            }
        },
        rotate_around_x: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_x(cos(angle), sin(angle))
                } else {
                    var ry, rz = self.y, self.z
                    self.y, self.z = c * ry - s * rz, c * rz + s * ry
                    return self
                }
            } else {
                return self.rotate_around_x(c.x, c.y)
            }
        },
        rotate_around_y: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_y(cos(angle), sin(angle))
                } else {
                    var rx, rz = self.x, self.z
                    self.x, self.z = c * rx + s * rz, c * rz - s * rx
                    return self
                }
            } else {
                return self.rotate_around_y(c.x, c.y)
            }
        },
        rotate: func(self, c, s, d) {
            if !d {
                if typeof c == "number" {
                    var angle, d = c, s
                    return self.rotate(cos(angle), sin(angle), d)
                } else {
                    var sc, d = c, s
                    return self.rotate(sc.x, sc.y, d)
                }
            } else {
                var x, y, z = self.x, self.y, self.z
                self.x = x*(d.x*d.x*(1-c)+c) + y*(d.x*d.y*(1-c)-d.z*s)
                    + z*(d.x*d.z*(1-c)+d.y*s)
                self.y = x*(d.y*d.x*(1-c)+d.z*s) + y*(d.y*d.y*(1-c)+c)
                    + z*(d.y*d.z*(1-c)-d.x*s)
                self.z = x*(d.x*d.z*(1-c)-d.y*s) + y*(d.y*d.z*(1-c)+d.x*s)
                    + z*(d.z*d.z*(1-c)+c)
                return self
            }
        },
        orthogonal: func(self, d) {
            var i = (abs(d.x) > abs(d.y))
                 && (abs(d.x) > abs(d.z) && 0 || 2)
                 || (abs(d.y) > abs(d.z) && 1 || 2)
            self[iton[i]] = d[iton[(i + 1) % 3]]
            self[iton[(i + 1) % 3]] = -d[iton[i]]
            self[iton[(i + 2) % 3]] = 0
            return self
        },
        orthonormalize: func(self, s, t) {
            s.project(self)
            t.project(self).project(s)
        },
        inside_bb: func(self, bbmin, bbmax) {
            if typeof bbmax == "number" {
                var o, size = bbmin, bbmax
                return self.x >= o.x && self.x <= (o.x + size)
                    && self.y >= o.y && self.y <= (o.y + size)
                    && self.z >= o.z && self.z <= (o.z + size)
            }
            return self.x >= bbmin.x && self.x <= bbmax.x
                && self.y >= bbmin.y && self.y <= bbmax.y
                && self.z >= bbmin.z && self.z <= bbmax.z
        },
        dist_to_bb: func(self, min, max) {
            if typeof max == "number" {
                var o, size = min, max
                return self.dist_to_bb(o, o.add_new(size))
            }
            var sqrdist = 0
            for i in 0 to 2 {
                var n = iton[i]
                if self[n] < min[n] {
                    var delta = self[n] - min[n]
                    sqrdist = sqrdist + delta ** 2
                } else if self[n] > max[n] {
                    var delta = max[n] - self[n]
                    sqrdist = sqrdist + delta ** 2
                }
            }
            return sqrt(sqrdist)
        },
        project_bb: func(self, min, max) {
            var x, y, z = self.x, self.y, self.z
            return x * (x < 0 && max.x || min.x)
                 + y * (y < 0 && max.y || min.y)
                 + z * (z < 0 && max.z || min.z)
        },
        to_hex_color: func(self) {
            return floor(clamp(self.r, 0, 1) * 255) << 16
                 | floor(clamp(self.g, 0, 1) * 255) <<  8
                 | floor(clamp(self.b, 0, 1) * 255)
        },

        /**
            Returns the distance to the floor below some given position.

            Arguments:
                - max_dist - the maximum distance.
                - radius - optionally the radius to search within.
                - lowest - if true, finds the lowest floor instead of highest
                  floor, optional.
        */
        floor_distance: func(self, max_dist, radius, lowest) {
            var rt = capi::ray_floor(self.x, self.y, self.z, max_dist)
            if !radius { return rt }

            var tbl = [ -radius / 2, 0, radius / 2 ]

            var f = min
            if lowest { f = max }

            for x in 0 to tbl.len() - 1 {
                for y in 0 to tbl.len() - 1 {
                    var o = self.add_new(Vec3(tbl[x], tbl[y], 0))
                    rt = f(rt, capi::ray_floor(o.x, o.y, o.z, max_dist))
                }
            }

            return rt
        },

        /**
            Returns true is the line between two given positions is clear
            (if there are no obstructions). Returns false otherwise.
        */
        is_los: func(self, d) {
            return capi::ray_los(self.x, self.y, self.z, d.x, d.y, d.z)
        },

        /**
            Calculates the yaw from an origin to a target. Done on 2D data
            only. If the last "reverse" argument is given as true, it
            calculates away from the target. Returns the yaw.
        */
        yaw_to: func(self, target, reverse) {
            return reverse && target.yaw_to(self)
                || deg(-(atan2(target.x - self.x, target.y - self.y)))
        },

        /**
            Calculates the pitch from an origin to a target. Done on 2D data
            only. If the last "reverse" argument is given as true, it
            calculates away from the target. Returns the pitch.
        */
        pitch_to: func(self, target, reverse) {
            return reverse && target.pitch_to(self)
                || deg(asin((target.z - self.z) / self.dist(target)))
        },

        /**
            Checks if the yaw between two points is within acceptable error
            range. Useful to see whether a character is facing closely enough
            to the target, for example. Returns true if it is within the range,
            false otherwise.
        */
        compare_yaw: func(self, target, yaw, acceptable) {
            return abs(normalize_angle(self.yaw_to(target), yaw) - yaw)
                <= acceptable
        },

        /**
            Checks if the pitch between two points is within acceptable error
            range. Useful to see whether a character is facing closely enough
            to the target, for example. Returns true if it is within the range,
            false otherwise.
        */
        compare_pitch: func(self, target, pitch, acceptable) {
            return abs(normalize_angle(self.pitch_to(target), pitch) - pitch)
                <= acceptable
        }
    }
})
M.Vec3 = Vec3

var Vec4, Vec4_mt; Vec4, Vec4_mt = gen_vec4("float", "f", {
    __new: func(self, x, y, z, w) {
        if typeof x == "number" {
            if !y && !z && !w {
                return ffi_new(self, x, x, x, x)
            } else {
                return ffi_new(self, x, y, z, w)
            }
        } else {
            return ffi_new(self, x.x, x.y, x.z, x.w)
        }
    },
    __tostring: func(self) {
        return "Vec3 <%f, %f, %f, %f>".format(self.x, self.y, self.z, self.w)
    },
    __eq: func(self, o) {
        return self.x == o.x && self.y == o.y
            && self.z == o.z && self.w == o.w
    },
    __mul: func(self, o) { return self.mul_new(o) },
    __div: func(self, o) { return self.div_new(o) },
    __add: func(self, o) { return self.add_new(o) },
    __sub: func(self, o) { return self.sub_new(o) },
    __index: {
        from_array: func(self, o) {
            return ffi_new(self, o[0], o[1], o[2], o[3])
        },
        from_vec3: func(self, o, w) {
            return ffi_new(self, o.x, o.y, o.z, w || 0)
        },

        copy: func(self) {
            return Vec4(self.x, self.y, self.z, self.w)
        },
        to_array: func(self) {
            return [ self.x, self.y, self.z, self.w ]
        },
        unpack3: func(self) {
            return self.x, self.y, self.z
        },
        unpack: func(self) {
            return self.x, self.y, self.z, self.w
        },
        get_nth: func(self, n) { return self[iton[n - 1]] },
        set_nth: func(self, n, v) { self[iton[n - 1]] = v },
        is_zero: func(self) {
            return self.x == 0 && self.y == 0 && self.z == 0 && self.w == 0
        },
        dot3: func(self, o) {
            return self.x * o.x + self.y * o.y + self.z * o.z
        },
        dot: func(self, o) {
            return self.x * o.x + self.y * o.y + self.z * o.z + self.w * o.w
        },
        squared_len: func(self) { return self.dot(self) },
        magnitude3: func(self) { return sqrt(self.dot3(self)) },
        magnitude: func(self) { return sqrt(self.squared_len()) },
        normalize: func(self) { return self.div(self.magnitude()) },
        lerp: func(self, a, b, t) {
            if !t { a, b, t = self, a, b }
            self.x, self.y, self.z, self.w = a.x + (b.x - a.x) * t,
                                             a.y * (b.y - a.y) * t,
                                             a.z * (b.z - a.z) * t,
                                             a.w * (b.w - a.w) * t
            return self
        },
        avg: func(self, b) { return self.add(b).mul(0.5) },
        mul3: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x * o, self.y * o, self.z * o
            } else {
                self.x, self.y, self.z = self.x * o.x, self.y * o.y,
                    self.z * o.z
            }
            return self
        },
        div3: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x / o, self.y / o, self.z / o
            } else {
                self.x, self.y, self.z = self.x / o.x, self.y / o.y,
                    self.z / o.z
            }
            return self
        },
        add3: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x + o, self.y + o, self.z + o
            } else {
                self.x, self.y, self.z = self.x + o.x, self.y + o.y,
                    self.z + o.z
            }
            return self
        },
        sub3: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x - o, self.y - o, self.z - o
            } else {
                self.x, self.y, self.z = self.x - o.x, self.y - o.y,
                    self.z - o.z
            }
            return self
        },
        mul: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = self.x * o, self.y * o,
                    self.z * o, self.w * o
            } else {
                self.x, self.y, self.z, self.w = self.x * o.x, self.y * o.y,
                    self.z * o.z, self.w * o.w
            }
            return self
        },
        div: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = self.x / o, self.y / o,
                    self.z / o, self.w / o
            } else {
                self.x, self.y, self.z, self.w = self.x / o.x, self.y / o.y,
                    self.z / o.z, self.w / o.w
            }
            return self
        },
        add: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = self.x + o, self.y + o,
                    self.z + o, self.w + o
            } else {
                self.x, self.y, self.z, self.w = self.x + o.x, self.y + o.y,
                    self.z + o.z, self.w + o.w
            }
            return self
        },
        add_w: func(self, f) {
            self.w = self.w + f
            return self
        },
        sub: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = self.x - o, self.y - o,
                    self.z - o, self.w - o
            } else {
                self.x, self.y, self.z, self.w = self.x - o.x, self.y - o.y,
                    self.z - o.z, self.w - o.w
            }
            return self
        },
        sub_w: func(self, f) {
            self.w = self.w - f
            return self
        },
        mul_new: func(self, o) {
            if typeof o == "number" {
                return Vec4(self.x * o, self.y * o, self.z * o, self.w * o)
            } else {
                return Vec4(self.x * o.x, self.y * o.y, self.z * o.z,
                    self.w * o.w)
            }
        },
        div_new: func(self, o) {
            if typeof o == "number" {
                return Vec4(self.x / o, self.y / o, self.z / o, self.w / o)
            } else {
                return Vec4(self.x / o.x, self.y / o.y, self.z / o.z,
                    self.w / o.w)
            }
        },
        add_new: func(self, o) {
            if typeof o == "number" {
                return Vec4(self.x + o, self.y + o, self.z + o, self.w + o)
            } else {
                return Vec4(self.x + o.x, self.y + o.y, self.z + o.z,
                    self.w + o.w)
            }
        },
        sub_new: func(self, o) {
            if typeof o == "number" {
                return Vec4(self.x - o, self.y - o, self.z - o, self.w - o)
            } else {
                return Vec4(self.x - o.x, self.y - o.y, self.z - o.z,
                    self.w - o.w)
            }
        },
        neg3: func(self) {
            self.x, self.y, self.z = -self.x, -self.y, -self.w
            return self
        },
        neg: func(self) {
            self.x, self.y, self.z, self.w = -self.x, -self.y, -self.z, -self.w
            return self
        },
        min: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = min(self.x, o),
                    min(self.y, o), min(self.z, o), min(self.w, o)
            } else {
                self.x, self.y, self.z, self.w = min(self.x, o.x),
                    min(self.y, o.y), min(self.z, o.z), min(self.w, o.w)
            }
            return self
        },
        max: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = max(self.x, o),
                    max(self.y, o), max(self.z, o), max(self.w, o)
            } else {
                self.x, self.y, self.z, self.w = max(self.x, o.x),
                    max(self.y, o.y), max(self.z, o.z), max(self.w, o.w)
            }
            return self
        },
        abs: func(self) {
            self.x, self.y, self.z, self.w = abs(self.x), abs(self.y),
                abs(self.z), abs(self.w)
            return self
        },
        clamp: func(self, l, h) {
            self.x, self.y, self.z, self.w = clamp(self.x, l, h),
                clamp(self.y, l, h), clamp(self.z, l, h), clamp(self.w, l. h)
            return self
        },
        dist: func(self, o) {
            var dx, dy, dz = self.x - o.x, self.y - o.y, self.z - o.z
            return sqrt(dx ** 2 + dy ** 2 + dz ** 2)
        },
        dist2: func(self, o) {
            var dx, dy = self.x - o.x, self.y - o.y
            return sqrt(dx ** 2 + dy ** 2)
        },
        rotate_around_z: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_z(cos(angle), sin(angle))
                } else {
                    var rx, ry = self.x, self.y
                    self.x, self.y = c * rx - s * ry, c * ry + s * rx
                    return self
                }
            } else {
                return self.rotate_around_z(c.x, c.y)
            }
        },
        rotate_around_x: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_x(cos(angle), sin(angle))
                } else {
                    var ry, rz = self.y, self.z
                    self.y, self.z = c * ry - s * rz, c * rz + s * ry
                    return self
                }
            } else {
                return self.rotate_around_x(c.x, c.y)
            }
        },
        rotate_around_y: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_y(cos(angle), sin(angle))
                } else {
                    var rx, rz = self.x, self.z
                    self.x, self.z = c * rx + s * rz, c * rz - s * rx
                    return self
                }
            } else {
                return self.rotate_around_y(c.x, c.y)
            }
        }
    }
})
M.Vec4 = Vec4

from std.table import getmt, setmt
from std.util import proxy as newproxy

var ntoi2 = { x: 0, y: 1 }
var ntoi3 = { x: 0, y: 1, z: 2, r: 0, g: 1, b: 2 }
var ntoi4 = { x: 0, y: 1, z: 2, w: 3, r: 0, g: 1, b: 2, a: 3 }

var gen_vec_surrogate = func(name, base, ltable) {
    var surrtbl
    surrtbl = {
        name: name,
        new: func(self, ent, svar) {
            var rawt = { entity: ent, variable: svar }
            rawt.rawt = rawt
            var ret = newproxy(true)
            var mt = getmt(ret)
            mt.__tostring = self.__tostring
            mt.__index    = setmt(rawt, self)
            mt.__newindex = self.__newindex
            mt.__eq, mt.__mul, mt.__div, mt.__add, mt.__sub
                = base.__eq, base.__mul, base.__div, base.__add, base.__sub
            return ret
        },
        __tostring: (ltable.w && func(self) {
            return "%s <%f, %f, %f, %f>".format(name, self.x, self.y,
                self.z, self.w)
        } || (ltable.z && func(self) {
            return "%s <%f, %f, %f>".format(name, self.x, self.y, self.z)
        } || func(self) {
            return "%s <%f, %f>".format(name, self.x, self.y)
        })),
        __index: func(self, n) {
            var i = ltable[n]
            if i { return self.variable.get_item(self.entity, i) }
            return surrtbl[n] || rawget(self.rawt, n)
        },
        __newindex: func(self, n, val) {
            var i = ltable[n]
            if i { return self.variable.set_item(self.entity, i, val) }
            rawset(self.rawt, n, val)
        }
    }
    for k, v in pairs(base.__index) {
        if !k.find_match("^from_.+$") { surrtbl[k] = v }
    }
    return surrtbl
}

M.Vec2_Surrogate = gen_vec_surrogate("Vec2_Surrogate", Vec2_mt, ntoi2)
M.Vec3_Surrogate = gen_vec_surrogate("Vec3_Surrogate", Vec3_mt, ntoi3)
M.Vec4_Surrogate = gen_vec_surrogate("Vec4_Surrogate", Vec4_mt, ntoi4)

var sincos360 = [
    Vec2( 1.00000000,  0.00000000), Vec2( 0.99984770,  0.01745241), Vec2( 0.99939083,  0.03489950), Vec2( 0.99862953,  0.05233596), Vec2( 0.99756405,  0.06975647), Vec2( 0.99619470,  0.08715574), // 0
    Vec2( 0.99452190,  0.10452846), Vec2( 0.99254615,  0.12186934), Vec2( 0.99026807,  0.13917310), Vec2( 0.98768834,  0.15643447), Vec2( 0.98480775,  0.17364818), Vec2( 0.98162718,  0.19080900), // 6
    Vec2( 0.97814760,  0.20791169), Vec2( 0.97437006,  0.22495105), Vec2( 0.97029573,  0.24192190), Vec2( 0.96592583,  0.25881905), Vec2( 0.96126170,  0.27563736), Vec2( 0.95630476,  0.29237170), // 12
    Vec2( 0.95105652,  0.30901699), Vec2( 0.94551858,  0.32556815), Vec2( 0.93969262,  0.34202014), Vec2( 0.93358043,  0.35836795), Vec2( 0.92718385,  0.37460659), Vec2( 0.92050485,  0.39073113), // 18
    Vec2( 0.91354546,  0.40673664), Vec2( 0.90630779,  0.42261826), Vec2( 0.89879405,  0.43837115), Vec2( 0.89100652,  0.45399050), Vec2( 0.88294759,  0.46947156), Vec2( 0.87461971,  0.48480962), // 24
    Vec2( 0.86602540,  0.50000000), Vec2( 0.85716730,  0.51503807), Vec2( 0.84804810,  0.52991926), Vec2( 0.83867057,  0.54463904), Vec2( 0.82903757,  0.55919290), Vec2( 0.81915204,  0.57357644), // 30
    Vec2( 0.80901699,  0.58778525), Vec2( 0.79863551,  0.60181502), Vec2( 0.78801075,  0.61566148), Vec2( 0.77714596,  0.62932039), Vec2( 0.76604444,  0.64278761), Vec2( 0.75470958,  0.65605903), // 36
    Vec2( 0.74314483,  0.66913061), Vec2( 0.73135370,  0.68199836), Vec2( 0.71933980,  0.69465837), Vec2( 0.70710678,  0.70710678), Vec2( 0.69465837,  0.71933980), Vec2( 0.68199836,  0.73135370), // 42
    Vec2( 0.66913061,  0.74314483), Vec2( 0.65605903,  0.75470958), Vec2( 0.64278761,  0.76604444), Vec2( 0.62932039,  0.77714596), Vec2( 0.61566148,  0.78801075), Vec2( 0.60181502,  0.79863551), // 48
    Vec2( 0.58778525,  0.80901699), Vec2( 0.57357644,  0.81915204), Vec2( 0.55919290,  0.82903757), Vec2( 0.54463904,  0.83867057), Vec2( 0.52991926,  0.84804810), Vec2( 0.51503807,  0.85716730), // 54
    Vec2( 0.50000000,  0.86602540), Vec2( 0.48480962,  0.87461971), Vec2( 0.46947156,  0.88294759), Vec2( 0.45399050,  0.89100652), Vec2( 0.43837115,  0.89879405), Vec2( 0.42261826,  0.90630779), // 60
    Vec2( 0.40673664,  0.91354546), Vec2( 0.39073113,  0.92050485), Vec2( 0.37460659,  0.92718385), Vec2( 0.35836795,  0.93358043), Vec2( 0.34202014,  0.93969262), Vec2( 0.32556815,  0.94551858), // 66
    Vec2( 0.30901699,  0.95105652), Vec2( 0.29237170,  0.95630476), Vec2( 0.27563736,  0.96126170), Vec2( 0.25881905,  0.96592583), Vec2( 0.24192190,  0.97029573), Vec2( 0.22495105,  0.97437006), // 72
    Vec2( 0.20791169,  0.97814760), Vec2( 0.19080900,  0.98162718), Vec2( 0.17364818,  0.98480775), Vec2( 0.15643447,  0.98768834), Vec2( 0.13917310,  0.99026807), Vec2( 0.12186934,  0.99254615), // 78
    Vec2( 0.10452846,  0.99452190), Vec2( 0.08715574,  0.99619470), Vec2( 0.06975647,  0.99756405), Vec2( 0.05233596,  0.99862953), Vec2( 0.03489950,  0.99939083), Vec2( 0.01745241,  0.99984770), // 84
    Vec2( 0.00000000,  1.00000000), Vec2(-0.01745241,  0.99984770), Vec2(-0.03489950,  0.99939083), Vec2(-0.05233596,  0.99862953), Vec2(-0.06975647,  0.99756405), Vec2(-0.08715574,  0.99619470), // 90
    Vec2(-0.10452846,  0.99452190), Vec2(-0.12186934,  0.99254615), Vec2(-0.13917310,  0.99026807), Vec2(-0.15643447,  0.98768834), Vec2(-0.17364818,  0.98480775), Vec2(-0.19080900,  0.98162718), // 96
    Vec2(-0.20791169,  0.97814760), Vec2(-0.22495105,  0.97437006), Vec2(-0.24192190,  0.97029573), Vec2(-0.25881905,  0.96592583), Vec2(-0.27563736,  0.96126170), Vec2(-0.29237170,  0.95630476), // 102
    Vec2(-0.30901699,  0.95105652), Vec2(-0.32556815,  0.94551858), Vec2(-0.34202014,  0.93969262), Vec2(-0.35836795,  0.93358043), Vec2(-0.37460659,  0.92718385), Vec2(-0.39073113,  0.92050485), // 108
    Vec2(-0.40673664,  0.91354546), Vec2(-0.42261826,  0.90630779), Vec2(-0.43837115,  0.89879405), Vec2(-0.45399050,  0.89100652), Vec2(-0.46947156,  0.88294759), Vec2(-0.48480962,  0.87461971), // 114
    Vec2(-0.50000000,  0.86602540), Vec2(-0.51503807,  0.85716730), Vec2(-0.52991926,  0.84804810), Vec2(-0.54463904,  0.83867057), Vec2(-0.55919290,  0.82903757), Vec2(-0.57357644,  0.81915204), // 120
    Vec2(-0.58778525,  0.80901699), Vec2(-0.60181502,  0.79863551), Vec2(-0.61566148,  0.78801075), Vec2(-0.62932039,  0.77714596), Vec2(-0.64278761,  0.76604444), Vec2(-0.65605903,  0.75470958), // 126
    Vec2(-0.66913061,  0.74314483), Vec2(-0.68199836,  0.73135370), Vec2(-0.69465837,  0.71933980), Vec2(-0.70710678,  0.70710678), Vec2(-0.71933980,  0.69465837), Vec2(-0.73135370,  0.68199836), // 132
    Vec2(-0.74314483,  0.66913061), Vec2(-0.75470958,  0.65605903), Vec2(-0.76604444,  0.64278761), Vec2(-0.77714596,  0.62932039), Vec2(-0.78801075,  0.61566148), Vec2(-0.79863551,  0.60181502), // 138
    Vec2(-0.80901699,  0.58778525), Vec2(-0.81915204,  0.57357644), Vec2(-0.82903757,  0.55919290), Vec2(-0.83867057,  0.54463904), Vec2(-0.84804810,  0.52991926), Vec2(-0.85716730,  0.51503807), // 144
    Vec2(-0.86602540,  0.50000000), Vec2(-0.87461971,  0.48480962), Vec2(-0.88294759,  0.46947156), Vec2(-0.89100652,  0.45399050), Vec2(-0.89879405,  0.43837115), Vec2(-0.90630779,  0.42261826), // 150
    Vec2(-0.91354546,  0.40673664), Vec2(-0.92050485,  0.39073113), Vec2(-0.92718385,  0.37460659), Vec2(-0.93358043,  0.35836795), Vec2(-0.93969262,  0.34202014), Vec2(-0.94551858,  0.32556815), // 156
    Vec2(-0.95105652,  0.30901699), Vec2(-0.95630476,  0.29237170), Vec2(-0.96126170,  0.27563736), Vec2(-0.96592583,  0.25881905), Vec2(-0.97029573,  0.24192190), Vec2(-0.97437006,  0.22495105), // 162
    Vec2(-0.97814760,  0.20791169), Vec2(-0.98162718,  0.19080900), Vec2(-0.98480775,  0.17364818), Vec2(-0.98768834,  0.15643447), Vec2(-0.99026807,  0.13917310), Vec2(-0.99254615,  0.12186934), // 168
    Vec2(-0.99452190,  0.10452846), Vec2(-0.99619470,  0.08715574), Vec2(-0.99756405,  0.06975647), Vec2(-0.99862953,  0.05233596), Vec2(-0.99939083,  0.03489950), Vec2(-0.99984770,  0.01745241), // 174
    Vec2(-1.00000000,  0.00000000), Vec2(-0.99984770, -0.01745241), Vec2(-0.99939083, -0.03489950), Vec2(-0.99862953, -0.05233596), Vec2(-0.99756405, -0.06975647), Vec2(-0.99619470, -0.08715574), // 180
    Vec2(-0.99452190, -0.10452846), Vec2(-0.99254615, -0.12186934), Vec2(-0.99026807, -0.13917310), Vec2(-0.98768834, -0.15643447), Vec2(-0.98480775, -0.17364818), Vec2(-0.98162718, -0.19080900), // 186
    Vec2(-0.97814760, -0.20791169), Vec2(-0.97437006, -0.22495105), Vec2(-0.97029573, -0.24192190), Vec2(-0.96592583, -0.25881905), Vec2(-0.96126170, -0.27563736), Vec2(-0.95630476, -0.29237170), // 192
    Vec2(-0.95105652, -0.30901699), Vec2(-0.94551858, -0.32556815), Vec2(-0.93969262, -0.34202014), Vec2(-0.93358043, -0.35836795), Vec2(-0.92718385, -0.37460659), Vec2(-0.92050485, -0.39073113), // 198
    Vec2(-0.91354546, -0.40673664), Vec2(-0.90630779, -0.42261826), Vec2(-0.89879405, -0.43837115), Vec2(-0.89100652, -0.45399050), Vec2(-0.88294759, -0.46947156), Vec2(-0.87461971, -0.48480962), // 204
    Vec2(-0.86602540, -0.50000000), Vec2(-0.85716730, -0.51503807), Vec2(-0.84804810, -0.52991926), Vec2(-0.83867057, -0.54463904), Vec2(-0.82903757, -0.55919290), Vec2(-0.81915204, -0.57357644), // 210
    Vec2(-0.80901699, -0.58778525), Vec2(-0.79863551, -0.60181502), Vec2(-0.78801075, -0.61566148), Vec2(-0.77714596, -0.62932039), Vec2(-0.76604444, -0.64278761), Vec2(-0.75470958, -0.65605903), // 216
    Vec2(-0.74314483, -0.66913061), Vec2(-0.73135370, -0.68199836), Vec2(-0.71933980, -0.69465837), Vec2(-0.70710678, -0.70710678), Vec2(-0.69465837, -0.71933980), Vec2(-0.68199836, -0.73135370), // 222
    Vec2(-0.66913061, -0.74314483), Vec2(-0.65605903, -0.75470958), Vec2(-0.64278761, -0.76604444), Vec2(-0.62932039, -0.77714596), Vec2(-0.61566148, -0.78801075), Vec2(-0.60181502, -0.79863551), // 228
    Vec2(-0.58778525, -0.80901699), Vec2(-0.57357644, -0.81915204), Vec2(-0.55919290, -0.82903757), Vec2(-0.54463904, -0.83867057), Vec2(-0.52991926, -0.84804810), Vec2(-0.51503807, -0.85716730), // 234
    Vec2(-0.50000000, -0.86602540), Vec2(-0.48480962, -0.87461971), Vec2(-0.46947156, -0.88294759), Vec2(-0.45399050, -0.89100652), Vec2(-0.43837115, -0.89879405), Vec2(-0.42261826, -0.90630779), // 240
    Vec2(-0.40673664, -0.91354546), Vec2(-0.39073113, -0.92050485), Vec2(-0.37460659, -0.92718385), Vec2(-0.35836795, -0.93358043), Vec2(-0.34202014, -0.93969262), Vec2(-0.32556815, -0.94551858), // 246
    Vec2(-0.30901699, -0.95105652), Vec2(-0.29237170, -0.95630476), Vec2(-0.27563736, -0.96126170), Vec2(-0.25881905, -0.96592583), Vec2(-0.24192190, -0.97029573), Vec2(-0.22495105, -0.97437006), // 252
    Vec2(-0.20791169, -0.97814760), Vec2(-0.19080900, -0.98162718), Vec2(-0.17364818, -0.98480775), Vec2(-0.15643447, -0.98768834), Vec2(-0.13917310, -0.99026807), Vec2(-0.12186934, -0.99254615), // 258
    Vec2(-0.10452846, -0.99452190), Vec2(-0.08715574, -0.99619470), Vec2(-0.06975647, -0.99756405), Vec2(-0.05233596, -0.99862953), Vec2(-0.03489950, -0.99939083), Vec2(-0.01745241, -0.99984770), // 264
    Vec2(-0.00000000, -1.00000000), Vec2( 0.01745241, -0.99984770), Vec2( 0.03489950, -0.99939083), Vec2( 0.05233596, -0.99862953), Vec2( 0.06975647, -0.99756405), Vec2( 0.08715574, -0.99619470), // 270
    Vec2( 0.10452846, -0.99452190), Vec2( 0.12186934, -0.99254615), Vec2( 0.13917310, -0.99026807), Vec2( 0.15643447, -0.98768834), Vec2( 0.17364818, -0.98480775), Vec2( 0.19080900, -0.98162718), // 276
    Vec2( 0.20791169, -0.97814760), Vec2( 0.22495105, -0.97437006), Vec2( 0.24192190, -0.97029573), Vec2( 0.25881905, -0.96592583), Vec2( 0.27563736, -0.96126170), Vec2( 0.29237170, -0.95630476), // 282
    Vec2( 0.30901699, -0.95105652), Vec2( 0.32556815, -0.94551858), Vec2( 0.34202014, -0.93969262), Vec2( 0.35836795, -0.93358043), Vec2( 0.37460659, -0.92718385), Vec2( 0.39073113, -0.92050485), // 288
    Vec2( 0.40673664, -0.91354546), Vec2( 0.42261826, -0.90630779), Vec2( 0.43837115, -0.89879405), Vec2( 0.45399050, -0.89100652), Vec2( 0.46947156, -0.88294759), Vec2( 0.48480962, -0.87461971), // 294
    Vec2( 0.50000000, -0.86602540), Vec2( 0.51503807, -0.85716730), Vec2( 0.52991926, -0.84804810), Vec2( 0.54463904, -0.83867057), Vec2( 0.55919290, -0.82903757), Vec2( 0.57357644, -0.81915204), // 300
    Vec2( 0.58778525, -0.80901699), Vec2( 0.60181502, -0.79863551), Vec2( 0.61566148, -0.78801075), Vec2( 0.62932039, -0.77714596), Vec2( 0.64278761, -0.76604444), Vec2( 0.65605903, -0.75470958), // 306
    Vec2( 0.66913061, -0.74314483), Vec2( 0.68199836, -0.73135370), Vec2( 0.69465837, -0.71933980), Vec2( 0.70710678, -0.70710678), Vec2( 0.71933980, -0.69465837), Vec2( 0.73135370, -0.68199836), // 312
    Vec2( 0.74314483, -0.66913061), Vec2( 0.75470958, -0.65605903), Vec2( 0.76604444, -0.64278761), Vec2( 0.77714596, -0.62932039), Vec2( 0.78801075, -0.61566148), Vec2( 0.79863551, -0.60181502), // 318
    Vec2( 0.80901699, -0.58778525), Vec2( 0.81915204, -0.57357644), Vec2( 0.82903757, -0.55919290), Vec2( 0.83867057, -0.54463904), Vec2( 0.84804810, -0.52991926), Vec2( 0.85716730, -0.51503807), // 324
    Vec2( 0.86602540, -0.50000000), Vec2( 0.87461971, -0.48480962), Vec2( 0.88294759, -0.46947156), Vec2( 0.89100652, -0.45399050), Vec2( 0.89879405, -0.43837115), Vec2( 0.90630779, -0.42261826), // 330
    Vec2( 0.91354546, -0.40673664), Vec2( 0.92050485, -0.39073113), Vec2( 0.92718385, -0.37460659), Vec2( 0.93358043, -0.35836795), Vec2( 0.93969262, -0.34202014), Vec2( 0.94551858, -0.32556815), // 336
    Vec2( 0.95105652, -0.30901699), Vec2( 0.95630476, -0.29237170), Vec2( 0.96126170, -0.27563736), Vec2( 0.96592583, -0.25881905), Vec2( 0.97029573, -0.24192190), Vec2( 0.97437006, -0.22495105), // 342
    Vec2( 0.97814760, -0.20791169), Vec2( 0.98162718, -0.19080900), Vec2( 0.98480775, -0.17364818), Vec2( 0.98768834, -0.15643447), Vec2( 0.99026807, -0.13917310), Vec2( 0.99254615, -0.12186934), // 348
    Vec2( 0.99452190, -0.10452846), Vec2( 0.99619470, -0.08715574), Vec2( 0.99756405, -0.06975647), Vec2( 0.99862953, -0.05233596), Vec2( 0.99939083, -0.03489950), Vec2( 0.99984770, -0.01745241), // 354
    Vec2( 1.00000000,  0.00000000), Vec2( 0.99984770,  0.01745241), Vec2( 0.99939083,  0.03489950), Vec2( 0.99862953,  0.05233596), Vec2( 0.99756405,  0.06975647), Vec2( 0.99619470,  0.08715574), // 360
    Vec2( 0.99452190,  0.10452846), Vec2( 0.99254615,  0.12186934), Vec2( 0.99026807,  0.13917310), Vec2( 0.98768834,  0.15643447), Vec2( 0.98480775,  0.17364818), Vec2( 0.98162718,  0.19080900), // 366
    Vec2( 0.97814760,  0.20791169), Vec2( 0.97437006,  0.22495105), Vec2( 0.97029573,  0.24192190), Vec2( 0.96592583,  0.25881905), Vec2( 0.96126170,  0.27563736), Vec2( 0.95630476,  0.29237170), // 372
    Vec2( 0.95105652,  0.30901699), Vec2( 0.94551858,  0.32556815), Vec2( 0.93969262,  0.34202014), Vec2( 0.93358043,  0.35836795), Vec2( 0.92718385,  0.37460659), Vec2( 0.92050485,  0.39073113), // 378
    Vec2( 0.91354546,  0.40673664), Vec2( 0.90630779,  0.42261826), Vec2( 0.89879405,  0.43837115), Vec2( 0.89100652,  0.45399050), Vec2( 0.88294759,  0.46947156), Vec2( 0.87461971,  0.48480962), // 384
    Vec2( 0.86602540,  0.50000000), Vec2( 0.85716730,  0.51503807), Vec2( 0.84804810,  0.52991926), Vec2( 0.83867057,  0.54463904), Vec2( 0.82903757,  0.55919290), Vec2( 0.81915204,  0.57357644), // 390
    Vec2( 0.80901699,  0.58778525), Vec2( 0.79863551,  0.60181502), Vec2( 0.78801075,  0.61566148), Vec2( 0.77714596,  0.62932039), Vec2( 0.76604444,  0.64278761), Vec2( 0.75470958,  0.65605903), // 396
    Vec2( 0.74314483,  0.66913061), Vec2( 0.73135370,  0.68199836), Vec2( 0.71933980,  0.69465837), Vec2( 0.70710678,  0.70710678), Vec2( 0.69465837,  0.71933980), Vec2( 0.68199836,  0.73135370), // 402
    Vec2( 0.66913061,  0.74314483), Vec2( 0.65605903,  0.75470958), Vec2( 0.64278761,  0.76604444), Vec2( 0.62932039,  0.77714596), Vec2( 0.61566148,  0.78801075), Vec2( 0.60181502,  0.79863551), // 408
    Vec2( 0.58778525,  0.80901699), Vec2( 0.57357644,  0.81915204), Vec2( 0.55919290,  0.82903757), Vec2( 0.54463904,  0.83867057), Vec2( 0.52991926,  0.84804810), Vec2( 0.51503807,  0.85716730), // 414
    Vec2( 0.50000000,  0.86602540), Vec2( 0.48480962,  0.87461971), Vec2( 0.46947156,  0.88294759), Vec2( 0.45399050,  0.89100652), Vec2( 0.43837115,  0.89879405), Vec2( 0.42261826,  0.90630779), // 420
    Vec2( 0.40673664,  0.91354546), Vec2( 0.39073113,  0.92050485), Vec2( 0.37460659,  0.92718385), Vec2( 0.35836795,  0.93358043), Vec2( 0.34202014,  0.93969262), Vec2( 0.32556815,  0.94551858), // 426
    Vec2( 0.30901699,  0.95105652), Vec2( 0.29237170,  0.95630476), Vec2( 0.27563736,  0.96126170), Vec2( 0.25881905,  0.96592583), Vec2( 0.24192190,  0.97029573), Vec2( 0.22495105,  0.97437006), // 432
    Vec2( 0.20791169,  0.97814760), Vec2( 0.19080900,  0.98162718), Vec2( 0.17364818,  0.98480775), Vec2( 0.15643447,  0.98768834), Vec2( 0.13917310,  0.99026807), Vec2( 0.12186934,  0.99254615), // 438
    Vec2( 0.10452846,  0.99452190), Vec2( 0.08715574,  0.99619470), Vec2( 0.06975647,  0.99756405), Vec2( 0.05233596,  0.99862953), Vec2( 0.03489950,  0.99939083), Vec2( 0.01745241,  0.99984770), // 444
    Vec2( 0.00000000,  1.00000000), Vec2(-0.01745241,  0.99984770), Vec2(-0.03489950,  0.99939083), Vec2(-0.05233596,  0.99862953), Vec2(-0.06975647,  0.99756405), Vec2(-0.08715574,  0.99619470), // 450
    Vec2(-0.10452846,  0.99452190), Vec2(-0.12186934,  0.99254615), Vec2(-0.13917310,  0.99026807), Vec2(-0.15643447,  0.98768834), Vec2(-0.17364818,  0.98480775), Vec2(-0.19080900,  0.98162718), // 456
    Vec2(-0.20791169,  0.97814760), Vec2(-0.22495105,  0.97437006), Vec2(-0.24192190,  0.97029573), Vec2(-0.25881905,  0.96592583), Vec2(-0.27563736,  0.96126170), Vec2(-0.29237170,  0.95630476), // 462
    Vec2(-0.30901699,  0.95105652), Vec2(-0.32556815,  0.94551858), Vec2(-0.34202014,  0.93969262), Vec2(-0.35836795,  0.93358043), Vec2(-0.37460659,  0.92718385), Vec2(-0.39073113,  0.92050485), // 468
    Vec2(-0.40673664,  0.91354546), Vec2(-0.42261826,  0.90630779), Vec2(-0.43837115,  0.89879405), Vec2(-0.45399050,  0.89100652), Vec2(-0.46947156,  0.88294759), Vec2(-0.48480962,  0.87461971), // 474
    Vec2(-0.50000000,  0.86602540), Vec2(-0.51503807,  0.85716730), Vec2(-0.52991926,  0.84804810), Vec2(-0.54463904,  0.83867057), Vec2(-0.55919290,  0.82903757), Vec2(-0.57357644,  0.81915204), // 480
    Vec2(-0.58778525,  0.80901699), Vec2(-0.60181502,  0.79863551), Vec2(-0.61566148,  0.78801075), Vec2(-0.62932039,  0.77714596), Vec2(-0.64278761,  0.76604444), Vec2(-0.65605903,  0.75470958), // 486
    Vec2(-0.66913061,  0.74314483), Vec2(-0.68199836,  0.73135370), Vec2(-0.69465837,  0.71933980), Vec2(-0.70710678,  0.70710678), Vec2(-0.71933980,  0.69465837), Vec2(-0.73135370,  0.68199836), // 492
    Vec2(-0.74314483,  0.66913061), Vec2(-0.75470958,  0.65605903), Vec2(-0.76604444,  0.64278761), Vec2(-0.77714596,  0.62932039), Vec2(-0.78801075,  0.61566148), Vec2(-0.79863551,  0.60181502), // 498
    Vec2(-0.80901699,  0.58778525), Vec2(-0.81915204,  0.57357644), Vec2(-0.82903757,  0.55919290), Vec2(-0.83867057,  0.54463904), Vec2(-0.84804810,  0.52991926), Vec2(-0.85716730,  0.51503807), // 504
    Vec2(-0.86602540,  0.50000000), Vec2(-0.87461971,  0.48480962), Vec2(-0.88294759,  0.46947156), Vec2(-0.89100652,  0.45399050), Vec2(-0.89879405,  0.43837115), Vec2(-0.90630779,  0.42261826), // 510
    Vec2(-0.91354546,  0.40673664), Vec2(-0.92050485,  0.39073113), Vec2(-0.92718385,  0.37460659), Vec2(-0.93358043,  0.35836795), Vec2(-0.93969262,  0.34202014), Vec2(-0.94551858,  0.32556815), // 516
    Vec2(-0.95105652,  0.30901699), Vec2(-0.95630476,  0.29237170), Vec2(-0.96126170,  0.27563736), Vec2(-0.96592583,  0.25881905), Vec2(-0.97029573,  0.24192190), Vec2(-0.97437006,  0.22495105), // 522
    Vec2(-0.97814760,  0.20791169), Vec2(-0.98162718,  0.19080900), Vec2(-0.98480775,  0.17364818), Vec2(-0.98768834,  0.15643447), Vec2(-0.99026807,  0.13917310), Vec2(-0.99254615,  0.12186934), // 528
    Vec2(-0.99452190,  0.10452846), Vec2(-0.99619470,  0.08715574), Vec2(-0.99756405,  0.06975647), Vec2(-0.99862953,  0.05233596), Vec2(-0.99939083,  0.03489950), Vec2(-0.99984770,  0.01745241), // 534
    Vec2(-1.00000000,  0.00000000), Vec2(-0.99984770, -0.01745241), Vec2(-0.99939083, -0.03489950), Vec2(-0.99862953, -0.05233596), Vec2(-0.99756405, -0.06975647), Vec2(-0.99619470, -0.08715574), // 540
    Vec2(-0.99452190, -0.10452846), Vec2(-0.99254615, -0.12186934), Vec2(-0.99026807, -0.13917310), Vec2(-0.98768834, -0.15643447), Vec2(-0.98480775, -0.17364818), Vec2(-0.98162718, -0.19080900), // 546
    Vec2(-0.97814760, -0.20791169), Vec2(-0.97437006, -0.22495105), Vec2(-0.97029573, -0.24192190), Vec2(-0.96592583, -0.25881905), Vec2(-0.96126170, -0.27563736), Vec2(-0.95630476, -0.29237170), // 552
    Vec2(-0.95105652, -0.30901699), Vec2(-0.94551858, -0.32556815), Vec2(-0.93969262, -0.34202014), Vec2(-0.93358043, -0.35836795), Vec2(-0.92718385, -0.37460659), Vec2(-0.92050485, -0.39073113), // 558
    Vec2(-0.91354546, -0.40673664), Vec2(-0.90630779, -0.42261826), Vec2(-0.89879405, -0.43837115), Vec2(-0.89100652, -0.45399050), Vec2(-0.88294759, -0.46947156), Vec2(-0.87461971, -0.48480962), // 564
    Vec2(-0.86602540, -0.50000000), Vec2(-0.85716730, -0.51503807), Vec2(-0.84804810, -0.52991926), Vec2(-0.83867057, -0.54463904), Vec2(-0.82903757, -0.55919290), Vec2(-0.81915204, -0.57357644), // 570
    Vec2(-0.80901699, -0.58778525), Vec2(-0.79863551, -0.60181502), Vec2(-0.78801075, -0.61566148), Vec2(-0.77714596, -0.62932039), Vec2(-0.76604444, -0.64278761), Vec2(-0.75470958, -0.65605903), // 576
    Vec2(-0.74314483, -0.66913061), Vec2(-0.73135370, -0.68199836), Vec2(-0.71933980, -0.69465837), Vec2(-0.70710678, -0.70710678), Vec2(-0.69465837, -0.71933980), Vec2(-0.68199836, -0.73135370), // 582
    Vec2(-0.66913061, -0.74314483), Vec2(-0.65605903, -0.75470958), Vec2(-0.64278761, -0.76604444), Vec2(-0.62932039, -0.77714596), Vec2(-0.61566148, -0.78801075), Vec2(-0.60181502, -0.79863551), // 588
    Vec2(-0.58778525, -0.80901699), Vec2(-0.57357644, -0.81915204), Vec2(-0.55919290, -0.82903757), Vec2(-0.54463904, -0.83867057), Vec2(-0.52991926, -0.84804810), Vec2(-0.51503807, -0.85716730), // 594
    Vec2(-0.50000000, -0.86602540), Vec2(-0.48480962, -0.87461971), Vec2(-0.46947156, -0.88294759), Vec2(-0.45399050, -0.89100652), Vec2(-0.43837115, -0.89879405), Vec2(-0.42261826, -0.90630779), // 600
    Vec2(-0.40673664, -0.91354546), Vec2(-0.39073113, -0.92050485), Vec2(-0.37460659, -0.92718385), Vec2(-0.35836795, -0.93358043), Vec2(-0.34202014, -0.93969262), Vec2(-0.32556815, -0.94551858), // 606
    Vec2(-0.30901699, -0.95105652), Vec2(-0.29237170, -0.95630476), Vec2(-0.27563736, -0.96126170), Vec2(-0.25881905, -0.96592583), Vec2(-0.24192190, -0.97029573), Vec2(-0.22495105, -0.97437006), // 612
    Vec2(-0.20791169, -0.97814760), Vec2(-0.19080900, -0.98162718), Vec2(-0.17364818, -0.98480775), Vec2(-0.15643447, -0.98768834), Vec2(-0.13917310, -0.99026807), Vec2(-0.12186934, -0.99254615), // 618
    Vec2(-0.10452846, -0.99452190), Vec2(-0.08715574, -0.99619470), Vec2(-0.06975647, -0.99756405), Vec2(-0.05233596, -0.99862953), Vec2(-0.03489950, -0.99939083), Vec2(-0.01745241, -0.99984770), // 624
    Vec2(-0.00000000, -1.00000000), Vec2( 0.01745241, -0.99984770), Vec2( 0.03489950, -0.99939083), Vec2( 0.05233596, -0.99862953), Vec2( 0.06975647, -0.99756405), Vec2( 0.08715574, -0.99619470), // 630
    Vec2( 0.10452846, -0.99452190), Vec2( 0.12186934, -0.99254615), Vec2( 0.13917310, -0.99026807), Vec2( 0.15643447, -0.98768834), Vec2( 0.17364818, -0.98480775), Vec2( 0.19080900, -0.98162718), // 636
    Vec2( 0.20791169, -0.97814760), Vec2( 0.22495105, -0.97437006), Vec2( 0.24192190, -0.97029573), Vec2( 0.25881905, -0.96592583), Vec2( 0.27563736, -0.96126170), Vec2( 0.29237170, -0.95630476), // 642
    Vec2( 0.30901699, -0.95105652), Vec2( 0.32556815, -0.94551858), Vec2( 0.34202014, -0.93969262), Vec2( 0.35836795, -0.93358043), Vec2( 0.37460659, -0.92718385), Vec2( 0.39073113, -0.92050485), // 648
    Vec2( 0.40673664, -0.91354546), Vec2( 0.42261826, -0.90630779), Vec2( 0.43837115, -0.89879405), Vec2( 0.45399050, -0.89100652), Vec2( 0.46947156, -0.88294759), Vec2( 0.48480962, -0.87461971), // 654
    Vec2( 0.50000000, -0.86602540), Vec2( 0.51503807, -0.85716730), Vec2( 0.52991926, -0.84804810), Vec2( 0.54463904, -0.83867057), Vec2( 0.55919290, -0.82903757), Vec2( 0.57357644, -0.81915204), // 660
    Vec2( 0.58778525, -0.80901699), Vec2( 0.60181502, -0.79863551), Vec2( 0.61566148, -0.78801075), Vec2( 0.62932039, -0.77714596), Vec2( 0.64278761, -0.76604444), Vec2( 0.65605903, -0.75470958), // 666
    Vec2( 0.66913061, -0.74314483), Vec2( 0.68199836, -0.73135370), Vec2( 0.69465837, -0.71933980), Vec2( 0.70710678, -0.70710678), Vec2( 0.71933980, -0.69465837), Vec2( 0.73135370, -0.68199836), // 672
    Vec2( 0.74314483, -0.66913061), Vec2( 0.75470958, -0.65605903), Vec2( 0.76604444, -0.64278761), Vec2( 0.77714596, -0.62932039), Vec2( 0.78801075, -0.61566148), Vec2( 0.79863551, -0.60181502), // 678
    Vec2( 0.80901699, -0.58778525), Vec2( 0.81915204, -0.57357644), Vec2( 0.82903757, -0.55919290), Vec2( 0.83867057, -0.54463904), Vec2( 0.84804810, -0.52991926), Vec2( 0.85716730, -0.51503807), // 684
    Vec2( 0.86602540, -0.50000000), Vec2( 0.87461971, -0.48480962), Vec2( 0.88294759, -0.46947156), Vec2( 0.89100652, -0.45399050), Vec2( 0.89879405, -0.43837115), Vec2( 0.90630779, -0.42261826), // 690
    Vec2( 0.91354546, -0.40673664), Vec2( 0.92050485, -0.39073113), Vec2( 0.92718385, -0.37460659), Vec2( 0.93358043, -0.35836795), Vec2( 0.93969262, -0.34202014), Vec2( 0.94551858, -0.32556815), // 696
    Vec2( 0.95105652, -0.30901699), Vec2( 0.95630476, -0.29237170), Vec2( 0.96126170, -0.27563736), Vec2( 0.96592583, -0.25881905), Vec2( 0.97029573, -0.24192190), Vec2( 0.97437006, -0.22495105), // 702
    Vec2( 0.97814760, -0.20791169), Vec2( 0.98162718, -0.19080900), Vec2( 0.98480775, -0.17364818), Vec2( 0.98768834, -0.15643447), Vec2( 0.99026807, -0.13917310), Vec2( 0.99254615, -0.12186934), // 708
    Vec2( 0.99452190, -0.10452846), Vec2( 0.99619470, -0.08715574), Vec2( 0.99756405, -0.06975647), Vec2( 0.99862953, -0.05233596), Vec2( 0.99939083, -0.03489950), Vec2( 0.99984770, -0.01745241), // 714
    Vec2( 1.00000000,  0.00000000) // 720
]
M.sin_cos_360 = func(angle) {
    return sincos360[angle]
}

var mod_360 = func(angle) {
    if angle < 0 {
        angle = 360 + ((angle <= -360) && -((-angle) % 360) || angle)
    } else if angle >= 360 {
        angle %= 360
    }
    return angle
}
M.mod_360 = mod_360

M.sin_cos_mod_360 = func(angle) {
    return sincos360[mod_360(angle)]
}

return M
