/**<
    Vector math, matrix math and geometry utilities. Roughly equivalent
    to geom.h in the core engine plus extensions.

    Author:
        q66 <daniel@octaforge.org>

    License:
        See COPYING.txt.
*/

import capi
from std.geom import Vec2, Vec3, Vec4
from std.math import min, max

/**
    Returns the distance to the floor below some given position.

    Arguments:
        - max_dist - the maximum distance.
        - radius - optionally the radius to search within.
        - lowest - if true, finds the lowest floor instead of highest
          floor, optional.
*/
export func floor_distance(self, max_dist, radius, lowest) {
    var rt = capi::ray_floor(self.x, self.y, self.z, max_dist)
    if !radius { return rt }

    var tbl = [ -radius / 2, 0, radius / 2 ]

    var f = min
    if lowest { f = max }

    for x in 0 to tbl.len() - 1 {
        for y in 0 to tbl.len() - 1 {
            var o = self.add_new(Vec3(tbl[x], tbl[y], 0))
            rt = f(rt, capi::ray_floor(o.x, o.y, o.z, max_dist))
        }
    }

    return rt
}

/**
    Returns true is the line between two given positions is clear
    (if there are no obstructions). Returns false otherwise.
*/
export func is_los(self, d) {
    return capi::ray_los(self.x, self.y, self.z, d.x, d.y, d.z)
}


from std.table import getmt, setmt, rawget, rawset
from std.util import proxy as newproxy

var ntoi2 = { x: 0, y: 1 }
var ntoi3 = { x: 0, y: 1, z: 2, r: 0, g: 1, b: 2 }
var ntoi4 = { x: 0, y: 1, z: 2, w: 3, r: 0, g: 1, b: 2, a: 3 }

var disallow = {
    from_array: true,
    from_vec2: true,
    from_vec3: true,
    from_yaw_pitch: true,
    from_hex_color: true
}

func surr_eq (self, o) { return self.equals (o) }
func surr_mul(self, o) { return self.mul_new(o) }
func surr_div(self, o) { return self.div_new(o) }
func surr_add(self, o) { return self.add_new(o) }
func surr_sub(self, o) { return self.sub_new(o) }

func gen_vec_surrogate(name, base, ltable) {
    var surrtbl
    surrtbl = {
        name: name,
        new: func(self, ent, svar) {
            var rawt = { entity: ent, variable: svar }
            rawt.rawt = rawt
            var ret = newproxy(true)
            var mt = getmt(ret)
            mt.__tostring = self.__tostring
            mt.__index    = setmt(rawt, self)
            mt.__newindex = self.__newindex
            mt.__eq, mt.__mul, mt.__div, mt.__add, mt.__sub
                = surr_eq, surr_mul, surr_div, surr_add, surr_sub
            return ret
        },
        __tostring: (ltable.w && func(self) {
            return "%s <%f, %f, %f, %f>".format(name, self.x, self.y,
                self.z, self.w)
        } || (ltable.z && func(self) {
            return "%s <%f, %f, %f>".format(name, self.x, self.y, self.z)
        } || func(self) {
            return "%s <%f, %f>".format(name, self.x, self.y)
        })),
        __index: func(self, n) {
            var i = ltable[n]
            if i { return self.variable.get_item(self.entity, i) }
            return (!disallow[n] ? base[n] : undef) || surrtbl[n] || rawget(self.rawt, n)
        },
        __newindex: func(self, n, val) {
            var i = ltable[n]
            if i { return self.variable.set_item(self.entity, i, val) }
            rawset(self.rawt, n, val)
        }
    }
    return surrtbl
}

export var Vec2_Surrogate = gen_vec_surrogate("Vec2_Surrogate", Vec2, ntoi2)
export var Vec3_Surrogate = gen_vec_surrogate("Vec3_Surrogate", Vec3, ntoi3)
export var Vec4_Surrogate = gen_vec_surrogate("Vec4_Surrogate", Vec4, ntoi4)