/**<
    A basic widget set. This module in particular implements the core of the
    whole system. All modules are documented, but not all methods in each
    widget are documented - only those of a significant meaning to the user
    are (as the other ones have no use for the user). It also manages the HUD.

    Author:
        q66 <quaker66@gmail.com>

    License:
        See COPYING.txt.
*/

import capi
import core.engine.cubescript as cs
import core.events.signal
import core.logger

from std.geom import Vec2

var gl_scissor_enable, gl_scissor_disable, gl_scissor, gl_blend_enable,
gl_blend_disable, gl_blend_func, gle_attrib2f, gle_color3f, gle_color4ub,
gle_attrib4ub, gle_defcolorub, gle_disable, hudmatrix_ortho, hudmatrix_reset,
shader_hud_set, hud_get_w, hud_get_h, hud_get_ss_x, hud_get_ss_y, hud_get_so_x,
hud_get_so_y, isconnected, text_get_res, text_font_get_h, aspect_get,
editing_get, console_scale_get, input_get_free_cursor, input_cursor_get_x,
input_cursor_get_y, input_cursor_exists_update in capi

from core.externals import set as set_external

var var_get, var_set = cs.var_get, cs.var_set

var emit = signal.emit

from std.object import Object
from std.table import rawget, rawset, pairs
from std.util import select
from std.math import min, max, clamp, floor, ceil
from std.util import assert

/// Module: core
var M = {}

import core.gui.constants as consts

/** Enum: gl
    Forwarded from the "constants" module.
*/
M.gl = consts.gl
var gl = M.gl

/** Enum: key
    Forwarded from the "constants" module.
*/
M.key = consts.key
var key = M.key

/** Enum: mod
    Forwarded from the "constants" module.
*/
M.mod = consts.mod
var mod = M.mod

// initialized after Root is created
var root
var clicked_code

var adjust = enum {
    ALIGN_HMASK: 0x3,
    ALIGN_VMASK: 0xC,
    ALIGN_MASK : ALIGN_HMASK | ALIGN_VMASK,
    CLAMP_MASK : 0xF0,

    ALIGN_HSHIFT: 0,
    ALIGN_VSHIFT: 2,

    ALIGN_HNONE  : 0 << ALIGN_HSHIFT,
    ALIGN_LEFT   : 1 << ALIGN_HSHIFT,
    ALIGN_HCENTER: 2 << ALIGN_HSHIFT,
    ALIGN_RIGHT  : 3 << ALIGN_HSHIFT,

    ALIGN_VNONE  : 0 << ALIGN_VSHIFT,
    ALIGN_TOP    : 1 << ALIGN_VSHIFT,
    ALIGN_VCENTER: 2 << ALIGN_VSHIFT,
    ALIGN_BOTTOM : 3 << ALIGN_VSHIFT,

    ALIGN_CENTER: ALIGN_HCENTER | ALIGN_VCENTER,
    ALIGN_NONE  : ALIGN_HNONE   | ALIGN_VNONE,

    CLAMP_LEFT   : 1 << 4,
    CLAMP_RIGHT  : 1 << 5,
    CLAMP_TOP    : 1 << 6,
    CLAMP_BOTTOM : 1 << 7,
}
M.adjust = adjust

var wtypes_by_name = {}
var wtypes_by_type = {}

var lastwtype = 0

/**
    Registers a widget type.

    Arguments:
        - name - the widget type name.
        - base - the widget type base widget type (defaults to $Widget).
        - obj - the body with custom contents.
        - ftype - the "type" field, by default it just assigns is a new type.
*/
M.register_type = func(name, base, obj, ftype) {
    if !ftype {
        lastwtype = lastwtype + 1
        ftype = lastwtype
    }
    base = base || wtypes_by_type[1]
    obj = obj || {}
    obj.type = ftype
    obj.name = name
    obj = base.clone(obj)
    wtypes_by_name[name] = obj
    wtypes_by_type[ftype] = obj
    return obj
}
var register_type = M.register_type

/**
    Given either a name or type, this function returns the widget type
    with that name or type.
*/
M.get_type = func(n) {
    if typeof n == "string" {
        return wtypes_by_name[n]
    } else {
        return wtypes_by_type[n]
    }
}
var get_type = M.get_type

/**
    Loops widget children, executing the function given in the second
    argument with the child passed to it. If the widget has states,
    it first acts on the current state and do on the actual children
    from 1 to N. If the selected state is not available, it tries "default".

    See also $loop_children_r.
*/
M.loop_children = func(self, fun) {
    var ch = self.children
    var vc = self.vchildren
    var vr = self.vstates
    var st = self.states

    var s = self.choose_state()
    if s != undef {
        var  w = st[s] || st["default"]
        if !w { w = vr[s] || vr["default"] }
        if w {
            var a, b, fret = fun(w)
            if fret || a != undef { return a, b }
        }
    }

    for i, o in vc.each() {
        var a, b, fret = fun(o)
        if fret || a != undef { return a, b }
    }

    for i, o in ch.each() {
        var a, b, fret = fun(o)
        if fret || a != undef { return a, b }
    }
}
var loop_children = M.loop_children

/**
    Loops widget children in reverse order, executing the function
    given in the second argument with the child passed to it. First
    goes over all children in reverse order and do if the widget
    has states, it acts on the current state. If the selected state
    is not available, it tries "default".

    See also $loop_children.
*/
M.loop_children_r = func(self, fun) {
    var ch = self.children
    var vc = self.vchildren
    var vr = self.vstates
    var st = self.states

    for i, o in ch.each_r() {
        var a, b, fret = fun(o)
        if fret || a != undef { return a, b }
    }

    for i, o in vc.each_r() {
        var a, b, fret = fun(o)
        if fret || a != undef { return a, b }
    }

    var s = self.choose_state()
    if s != undef {
        var  w = st[s] || st["default"]
        if !w { w = vr[s] || vr["default"] }
        if w {
            var a, b, fret = fun(w)
            if fret || a != undef { return a, b }
        }
    }
}
var loop_children_r = M.loop_children_r

/**
    Similar to $loop_children, takes some extra assumptions - executes only
    for those children that cover the given coordinates. The function is
    executed, passing the computed coordinates alongside the object to
    the function. The computed coordinates represent position of a cursor
    within the object - "cx - o.x" and "cy - o.y" respectively (the ox, oy
    coords of 0, 0 represent the top-left corner).

    Arguments:
        - o - the widget.
        - cx, cy - the cursor x and y position.
        - fun - the function to execute.
        - ins - when not given, assumed true; when false, it executes the
          function for every child, even if the cursor is not inside the
          child.
        - useproj - false by default, when true, it tries to get the
          projection of every child and do multiplies cx, cy with
          projection values - useful when treating windows (we need
          proper scaling on these and thus also proper input).

    See also:
        - $loop_in_children_r
*/
M.loop_in_children = func(self, cx, cy, fun, ins, useproj) {
    return loop_children(self, func(o) {
        var ox, oy
        if useproj {
            var proj = o.get_projection()
            ox, oy = (cx * proj.pw - o.x), (cy * proj.ph - o.y)
        } else {
            ox, oy = cx - o.x, cy - o.y
        }
        if ins == false || (ox >= 0 && ox < o.w && oy >= 0 && oy < o.h) {
            var a, b, fret = fun(o, ox, oy)
            if fret || a != undef { return a, b, true }
        }
    })
}
var loop_in_children = M.loop_in_children

/**
    See $loop_in_children and $loop_children_r. This is equal to above,
    just using $loop_children_r instead.
*/
M.loop_in_children_r = func(self, cx, cy, fun, ins, useproj) {
    return loop_children_r(self, func(o) {
        var ox, oy
        if useproj {
            var proj = o.get_projection()
            ox, oy = (cx * proj.pw - o.x), (cy * proj.ph - o.y)
        } else {
            ox, oy = cx - o.x, cy - o.y
        }
        if ins == false || (ox >= 0 && ox < o.w && oy >= 0 && oy < o.h) {
            var a, b, fret = fun(o, ox, oy)
            if fret || a != undef { return a, b, true }
        }
    })
}
var loop_in_children_r = M.loop_in_children_r

/**
    Represents a clip area defined by four points, x1, y1, x2, y2. The latter
    refer to x1+w and y1+h respectively.
*/
M.ClipArea = Object.clone({
    __ctor: func(self, x, y, w, h) {
        self.x1, self.y1, self.x2, self.y2 = x, y, x + w, y + h
    },

    /**
        Intersects the clip area with another one. Writes into self.
    */
    intersect: func(self, c) {
        self.x1 = max(self.x1, c.x1)
        self.y1 = max(self.y1, c.y1)
        self.x2 = max(self.x1, min(self.x2, c.x2))
        self.y2 = max(self.y1, min(self.y2, c.y2))
    },

    /**
        Given x, y, w, h, checks if the area specified by the coordinates
        is fully clipped by the clip area.
    */
    is_fully_clipped: func(self, x, y, w, h) {
        return self.x1 == self.x2 || self.y1 == self.y2 || x >= self.x2 ||
               y >= self.y2 || (x + w) <= self.x1 || (y + h) <= self.y1
    },

    scissor: func(self, root) {
        var sx1, sy1, sx2, sy2 = root.get_projection()
            .calc_scissor(self.x1, self.y1, self.x2, self.y2)
        gl_scissor(sx1, sy1, sx2 - sx1, sy2 - sy1)
    }
})
var ClipArea = M.ClipArea

/**
    An utility function for drawing quads, takes x, y, w, h and optionally
    tx, ty, tw, th (defaulting to 0, 0, 1, 1).
*/
M.draw_quad = func(x, y, w, h, tx, ty, tw, th) {
    tx, ty, tw, th = tx || 0, ty || 0, tw || 1, th || 1
    gle_attrib2f(x,     y)     gle_attrib2f(tx,      ty)
    gle_attrib2f(x + w, y)     gle_attrib2f(tx + tw, ty)
    gle_attrib2f(x + w, y + h) gle_attrib2f(tx + tw, ty + th)
    gle_attrib2f(x,     y + h) gle_attrib2f(tx,      ty + th)
}
var quad = M.draw_quad

/**
    An utility function for drawing quads, takes x, y, w, h and optionally
    tx, ty, tw, th (defaulting to 0, 0, 1, 1). Used with triangle strip.
*/
M.draw_quadtri = func(x, y, w, h, tx, ty, tw, th) {
    tx, ty, tw, th = tx || 0, ty || 0, tw || 1, th || 1
    gle_attrib2f(x,     y)     gle_attrib2f(tx,      ty)
    gle_attrib2f(x + w, y)     gle_attrib2f(tx + tw, ty)
    gle_attrib2f(x,     y + h) gle_attrib2f(tx,      ty + th)
    gle_attrib2f(x + w, y + h) gle_attrib2f(tx + tw, ty + th)
}
var quadtri = M.draw_quadtri

var gen_setter = func(name) {
    var sname = name ~ ",changed"
    return func(self, val) {
        self[name] = val
        emit(self, sname, val)
    }
}
M.gen_setter = gen_setter

/// Defines the possible orientations on widgets - HORIZONTAL and VERTICAL.
M.orient = enum {
    HORIZONTAL: 0, VERTICAL: 1
}
var orient = M.orient

var changes = enum {
    SHADER: 1 << 0,
    COLOR : 1 << 1,
    BLEND : 1 << 2
}
M.changes = changes

var changed = 0

var blend = enum {
    ALPHA, MOD
}
M.blend = blend

var blendtype = blend.ALPHA

var blend_change = func(type, src, dst) {
    if blendtype != type {
        blendtype = type
        gl_blend_func(src, dst)
    }
}

var blend_reset = func() {
    blend_change(blend.ALPHA, gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
}

var blend_mod = func() {
    blend_change(blend.MOD, gl.ZERO, gl.SRC_COLOR)
}

M.blend_change = blend_change
M.blend_reset  = blend_reset
M.blend_mod    = blend_mod

var Projection = Object.clone({
    __ctor: func(self, obj) {
        self.obj = obj
        self.px, self.py, self.pw, self.ph = 0, 0, 0, 0
    },

    calc: func(self) {
        var obj = self.obj
        var r = obj.get_root()
        var aspect = r.get_aspect(true)
        var ph = max(max(obj.h, obj.w / aspect), 1)
        var pw = aspect * ph
        self.px, self.py = 0, 0
        self.pw, self.ph = pw, ph
        return pw, ph
    },

    adjust_layout: func(self) {
        self.obj.adjust_layout(0, 0, self.calc())
    },

    projection: func(self) {
        var px, py, pw, ph in self
        hudmatrix_ortho(px, px + pw, py + ph, py, -1, 1)
        hudmatrix_reset()
        self.ss_x, self.ss_y = hud_get_ss_x(), hud_get_ss_y()
        self.so_x, self.so_y = hud_get_so_x(), hud_get_so_y()
    },

    calc_scissor: func(self, x1, y1, x2, y2, clip) {
        var obj = self.obj
        var r = obj.get_root()
        var sscale  = Vec2(self.ss_x, self.ss_y)
        var soffset = Vec2(self.so_x, self.so_y)
        var s1 = Vec2(x1, y2).mul(sscale).add(soffset)
        var s2 = Vec2(x2, y1).mul(sscale).add(soffset)
        var hudw, hudh = r.get_pixel_w(), r.get_pixel_h()
        var sx1, sy1, sx2, sy2 =
            floor(s1.x * hudw + 0.5), floor(s1.y * hudh + 0.5),
            floor(s2.x * hudw + 0.5), floor(s2.y * hudh + 0.5)
        if clip {
            sx1 = clamp(sx1, 0, hudw)
            sy1 = clamp(sy1, 0, hudh)
            sx2 = clamp(sx2, 0, hudw)
            sy2 = clamp(sy2, 0, hudh)
        }
        return sx1, sy1, sx2, sy2
    },

    draw: func(self, sx, sy) {
        var root = self.obj.get_root()
        root.set_projection(self)
        self.projection()
        shader_hud_set()

        blendtype = blend.ALPHA
        gl_blend_enable()
        gl_blend_func(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
        gle_color3f(1, 1, 1)

        changed = 0
        root._drawing = undef

        var obj = self.obj
        obj.draw(sx || obj.x, sy || obj.y)

        obj.stop_draw()

        gl_blend_disable()
        root.set_projection(undef)
    },

    calc_above_hud: func(self) {
        return 1 - (self.obj.y * self.ss_y + self.so_y)
    }
})

var color_ctors = {
    0: func(self) { self.r, self.g, self.b, self.a = 0xFF, 0xFF, 0xFF, 0xFF },
    1: func(self, c) {
        c = c || 0xFFFFFFFF
        var a = c >> 24
        self.r, self.g, self.b, self.a = (c >> 16) & 0xFF, (c >> 8) & 0xFF,
            c & 0xFF, (a == 0) && 0xFF || a
    },
    2: func(self, c, a) {
        c = c || 0xFFFFFF
        self.r, self.g, self.b, self.a = (c >> 16) & 0xFF, (c >> 8) & 0xFF,
            c & 0xFF, a || 0xFF
    },
    3: func(self, r, g, b) {
        self.r, self.g, self.b, self.a = r || 0xFF, g || 0xFF, b || 0xFF, 0xFF
    }
}

var color_defctor = func(self, r, g, b, a) {
    self.r, self.g, self.b, self.a = r || 0xFF, g || 0xFF, b || 0xFF, a || 0xFF
}

/**
    A color structure used for color attributes in all widgets that support
    them. Has fields r, g, b, a ranging from 0 to 255.
*/
M.Color = Object.clone({
    /**
        Depending on the number of arguments, this initializes the color.

        With zero argments, everything is initialized to 0xFF (255). With
        one argument, the argument is treated as a hex color. That means
        you can specify it either as 0xRRGGBB or 0xAARRGGBB. If you use
        the former, the alpha defaults to 0xFF.

        With two arguments, the first argument is a hex color in 0xRRGGBB
        and the second argument is the alpha. With three or four arguments
        you're providing the r, g, b and possibly a values. If only three
        arguments are provided, the alpha defaults to 0xFF.

        Note that if you provide undef or false in place of any argument,
        it'll default all color channels it affects to 0xFF.

        The set_(r|g|b|a) methods emit the "(r|g|b|a),changed" signals
        on this structure, passing the new value to the emit call.
    */
    __ctor: func(self, ...) {
        var nargs = select("#", ...);
        (color_ctors[nargs] || color_defctor)(self, ...)
    },

    /// Sets the color (like glColor4f).
    init: func(self) {
        gle_color4ub(self.r, self.g, self.b, self.a)
    },

    /// Like above, but used as an attribute.
    attrib: func(self) {
        gle_attrib4ub(self.r, self.g, self.b, self.a)
    },

    /// Defines the color attribute as 4 unsigned bytes.
    def: func() { gle_defcolorub(4) },

    /// Function: set_r
    set_r: gen_setter("r"),
    /// Function: set_g
    set_g: gen_setter("g"),
    /// Function: set_b
    set_b: gen_setter("b"),
    /// Function: set_a
    set_a: gen_setter("a")
})

/** Variable: uitextrows
    Specifies how many rows of text of scale 1 can fit on the screen. Defaults
    to 40. You can change this to tweak the font scale and thus the whole UI
    scale.
*/
cs::var_new_checked("uitextrows", cs.var_type.int, 1, 40, 200,
    cs.var_flags.PERSIST)

var uitextrows = var_get("uitextrows")
signal::connect(cs, "uitextrows,changed", func(self, n) {
    uitextrows = n
})

var Widget, Window, Tag

/**
    The basic widget type every other derives from. Provides everything
    needed for a working widget type, but doesn't do anything by itself.

    The widget has several basic properties described below.

    Properties are not made for direct setting from the outside environment.
    Those properties that are meant to be set have a setter method called
    set_PROPNAME. Unless documented otherwise, those functions emit the
    PROPNAME,changed signal with the given value passed to emit. Some
    properties that you don't set and are set from the internals also
    emit signals so you can handle extra events. That is typically documented.

    Several properties can be initialized via kwargs (align_h, align_v,
    clamp, clamp_h, clamp_v, clamp_l, clamp_r, clamp_b, clamp_t, floating,
    variant, states, signals, container and __init, which is a function called
    at the end of the constructor if it exists). Array members of kwargs are
    children.

    Left/right/top/bottom clamping is false by default. If the "clamp" value
    is defined and not false in kwargs, they all turn true.

    After that, the values "clamp_h" and "clamp_v" are checked - the former
    enables/disables left/right clamping, the latter enables/disables
    top/bottom clamping.

    After these are checked, the individual values "clamp_l", "clamp_r",
    "clamp_t", "clamp_b" are checked, turning on/off the individual directions.

    Widgets instances can have states - they're named references to widgets
    and are widget type specific. For example a button could have states
    "default" and "clicked", each being a reference to different
    appareance of a button depending on its state.

    For widget-global behavior, there are "variants". Variants are named.
    They store different kinds of states. For example variant "foo" could
    store specifically themed states and variant "bar" differently themed
    states.

    When selecting the current state of a widget instance, it first tries
    the "states" member (which is var to the widget instance). If such
    state is found, it's used. Otherwise the widget-global "__variants"
    table is tried, getting the variant self.variant (or "default" if undef).

    Note that self.variant can also have the "false" value, in this case
    no variant is used at all (not even "default").

    Every variant can have a member "__properties" which is an array of
    extra properties specific to the variant. You can initialize them
    via kwargs just like all other properties and the appropriate
    setters are defined.

    There can also be "__init" on every variant which is a function that
    is called with self as an argument after initialization of the variant.

    Note that you can't override existing properties (as in, either self[name]
    or self["set_" ~ name] exists) and if you set a different variant, all
    custom properties are discarded and replaced. Properties starting with an
    underscore are not allowed (reserved for private fields).

    The property "container" is a reference to another widget that is used
    as a target for appending/prepending/insertion and is fully optional.

    The property "tab_next" is a reference to another widget that is focused
    when the tab key is pressed while this widget is focused. Only works when
    the property is actually set to a valid widget reference.

    Each widget type also contains an "__instances" table storing a set
    of all instances of the widget type.

    Properties:
        - x, y, w, h - the widget dimensions.
        - adjust - the widget clamping and alignment as a set of bit flags.
        - children - an array of widget children.
        - floating - false by default, when true the widget is freely movable.
        - parent - the parent widget.
        - variant - the current widget variant.
        - variants, states - See above.
        - container - see above.
*/
M.Widget = register_type("Widget", Object, {
    /**
        Builds a widget instance from scratch. The optional kwargs
        table contains properties that should be set on the resulting
        widget.
    */
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}

        var instances = rawget(self.__proto, "__instances")
        if !instances {
            instances = {}
            rawset(self.__proto, "__instances", instances)
        }
        instances[self] = self

        var variants = rawget(self.__proto, "__variants")
        if !variants {
            variants = {}
            rawset(self.__proto, "__variants", variants)
        }

        self.managed_objects = {}
        self.managed_properties = []

        self.x, self.y, self.w, self.h = 0, 0, 0, 0

        self.adjust = adjust.ALIGN_CENTER

        // alignment and clamping
        var align_h = kwargs.align_h || 0
        var align_v = kwargs.align_v || 0

        // double negation turns the value into an equivalent boolean
        var cl = !!kwargs.clamp
        var clamp_l, clamp_r, clamp_b, clamp_t = cl, cl, cl, cl

        var clh, clv = kwargs.clamp_h, kwargs.clamp_v
        if clh != undef { clamp_l, clamp_r = !!clh, !!clh }
        if clv != undef { clamp_t, clamp_b = !!clv, !!clv }

        var cll, clr, clt, clb = kwargs.clamp_l, kwargs.clamp_r,
            kwargs.clamp_t, kwargs.clamp_b
        if cll != undef { clamp_l = !!cll }
        if clr != undef { clamp_r = !!clr }
        if clt != undef { clamp_t = !!clt }
        if clb != undef { clamp_b = !!clb }

        self.floating = kwargs.floating || false
        self.visible  = (kwargs.visible != false) && true || false
        self.disabled = kwargs.disabled || false

        self.align(align_h, align_v)
        self.clamp(clamp_l, clamp_r, clamp_b, clamp_t)

        if kwargs.signals {
            for k, v in pairs(kwargs.signals) {
                signal::connect(self, k, v)
            }
        }

        self.init_clone = kwargs.init_clone

        // extra kwargs
        var variant = kwargs.variant
        if variant != false {
            var dstates = variants[variant || "default"]
            var props = dstates && dstates.__properties || undef
            if props { for i, v in props.each() {
                assert(v.sub(0, 1) != "_", "invalid property " ~ v)
                assert(!self["set_" ~ v] && self[v] == undef,
                    "cannot override existing property " ~ v)
                self[v] = kwargs[v]
            } }
        }

        // disable asserts, already checked above
        self.set_variant(variant, true)

        // prepare for children
        var ch, states
        var cont = self.container
        if cont {
            ch, states = cont.children, cont.states
        } else {
            cont = self
            ch, states = [], {}
            self.children, self.states = ch, states
        }

        // children
        if kwargs.children {
            for i, v in kwargs.children.each() {
                ch.push(v)
                v.parent = cont
                v._root  = cont._root
            }
        }
        var ach = [ ... ]
        for i, v in ach.each() if v {
            ch.push(v)
            v.parent = cont
            v._root  = cont._root
        }
        self.children = ch

        // states
        var ks = kwargs.states
        if ks { for k, v in pairs(ks) {
            states[k] = v
            v.parent = cont
            v._root  = cont._root
        } }
        self.states = states

        // and init
        if  kwargs.__init {
            kwargs::__init(self)
        }
    },

    /**
        Clears a widget including its children recursively. Calls the
        "destroy" signal. Removes itself from its widget type' instances
        set. Does nothing if already cleared.
    */
    clear: func(self) {
        if self._cleared { return }
        self.clear_focus()

        var children = self.children
        for k, v in children.each() { v.clear() }
        var vchildren = self.vchildren
        for k, v in vchildren.each() { v.clear() }
        var states = self.states
        for k, v in pairs(states) { v.clear() }
        var vstates = self.vstates
        for k, v in pairs(vstates) { v.clear() }
        var mobjs = self.managed_objects
        for k, v in pairs(mobjs) { v.clear() }
        self.container = undef

        emit(self, "destroy")
        var insts = rawget(self.__proto, "__instances")
        if insts {
            insts[self] = undef
        }

        self._cleared = true
    },

    /**
        Creates a deep clone of the widget, that is, where each child
        is again a clone of the original child, down the tree. Useful
        for default widget type states, where we need to clone
        these per-instance.
    */
    deep_clone: func(self, obj, initc) {
        var ch, rch = [], self.children
        var vc, rvc = [], self.vchildren
        var st, rst = {}, self.states
        var vs, rvs = {}, self.vstates
        var ic = initc && self.init_clone || undef
        var cl = self.clone({ children: ch, vchildren: vc,
            states: st, vstates: vs })
        for i, c in rch.each() {
            var chcl = c.deep_clone(obj, true)
            chcl.parent = cl
            chcl._root  = cl._root
            ch.push(chcl)
        }
        for i, c in rvc.each() {
            var chcl = c.deep_clone(obj, true)
            chcl.parent = cl
            chcl._root  = cl._root
            vc.push(chcl)
        }
        for k, v in pairs(rst) {
            var vcl = v.deep_clone(obj, true)
            vcl.parent = cl
            vcl._root  = cl._root
            st[k] = vcl
        }
        for k, v in pairs(rvs) {
            var vcl = v.deep_clone(obj, true)
            vcl.parent = cl
            vcl._root  = cl._root
            vs[k] = vcl
        }
        if ic { ic(cl, obj) }
        return cl
    },

    /**
        Sets the variant this widget instance uses. If not provided, "default"
        is set implicitly.
    */
    set_variant: func(self, variant, disable_asserts) {
        self.variant = variant
        var old_vstates = self.vstates
        if old_vstates { for k, v in pairs(old_vstates) {
            v.clear()
        } }
        var old_vchildren = self.vchildren
        if old_vchildren { for i, v in old_vchildren.each() {
            v.clear()
        } }
        var manprops = self.managed_properties
        for i, v in manprops.each_r() {
            self[v] = undef
            manprops.pop()
        }
        var vstates = {}
        self.vstates = vstates
        var vchildren = []
        self.vchildren = vchildren
        if variant == false { return undef }
        var variants = rawget(self.__proto, "__variants")
        var dstates = variants[variant || "default"]
        if dstates {
            var notvariants = {
                "__properties": true, "__init": true,
                "__children": true
            }
            for k, v in pairs(dstates) {
                if notvariants[k] { continue }
                var ic = v.init_clone
                var cl = v.deep_clone(self)
                vstates[k] = cl
                cl.parent = self
                cl._root  = self._root
                if ic { ic(cl, self) }
            }
            var children = dstates.__children
            if children { for i, v in children.each() {
                var ic = v.init_clone
                var cl = v.deep_clone(self)
                vchildren.push(cl)
                cl.parent = self
                cl._root  = self._root
                if ic { ic(cl, self) }
            } }
            var props = dstates.__properties
            if props { for i, v in props.each() {
                var nm = "set_" ~ v
                if !disable_asserts {
                    assert(v.sub(0, 1) != "_", "invalid property " ~ v)
                    assert(!self[nm] && self[v] == undef,
                        "cannot override existing property " ~ v)
                }
                self[nm] = gen_setter(v)
                manprops.push(nm)
            } }
            var init = dstates.__init
            if init { init(self) }
        }
        var cont = self.container
        if cont && cont._cleared { self.container = undef }
    },

    /**
        Call on the widget type. Updates the state widget on the widget type
        and every instance of it. Destroys the old state of that name (if any)
        on the type and on every instance. If the instance already uses a
        different state (custom), it's left alone.

        Using this you can update the look of all widgets of certain type
        with ease.

        See also $state_changed.

        Arguments:
            - sname - the state name.
            - sval - the state widget.
            - variant - optional (defaults to "default").
    */
    update_prototype_state: func(self, sname, sval, variant) {
        variant = variant || "default"
        var dstates = rawget(self, "__variants")
        if !dstates {
            dstates = {}
            rawset(self, "__variants", dstates)
        }
        var variant = dstates[variant]
        if !variant {
            variant = {}
            dstates[variant] = variant
        }
        var oldstate = variant[sname]
        variant[sname] = sval
        oldstate.clear()

        var insts = rawget(self, "__instances")
        if insts { for v in pairs(insts) {
            var sts = v.vstates
            if v.variant == variant {
                var st = sts[sname]
                // update only on widgets actually using the default state
                if st && st.__proto == oldstate {
                    var ic = sval.init_clone
                    var nst = sval.deep_clone(v)
                    nst.parent = v
                    nst._root  = v._root
                    sts[sname] = nst
                    st.clear()
                    if ic { ic(nst, v) }
                    v.state_changed(sname, nst)
                }
            }
            var cont = v.container
            if cont && cont._cleared { v.container = undef }
        } }
    },

    /**
        Given an associative array of states (and optionally variant), it
        calls $update_prototype_state for each.
    */
    update_prototype_states: func(self, states, variant) {
        for k, v in pairs(states) {
            self.update_prototype_state(k, v, variant)
        }
    },

    /**
        Given the state name an a widget, this sets the state of that name
        for the individual widget (unlike $update_prototype_state). That is
        useful when you need widgets with custom appearance but you don't
        want all widgets to have it. This function destroys the old state
        if any.

        See also $state_changed.
    */
    update_state: func(self, state, obj) {
        var states = self.states
        var ostate = states[state]
        if ostate { ostate.clear() }
        states[state] = obj
        obj.parent = self
        obj._root  = self._root
        var cont = self.container
        if cont && cont._cleared { self.container = undef }
        self.state_changed(state, obj)
        return obj
    },

    /// Given an associative array of states, it calls $update_state for each.
    update_states: func(self, states) {
        for k, v in pairs(states) {
            self.update_state(k, v)
        }
    },

    /**
        Called with the state name and the state widget everytime
        $update_state or $update_prototype_state updates a widget's state.
        Useful for widget type and instance specific things such as updating
        labels on buttons. By default does nothing.
    */
    state_changed: func(self, sname, obj) {
    },

    /**
        Returns the state that should be currently used. By default
        returns undef.
    */
    choose_state: func(self) { return undef },

    /**
        Takes care of widget positioning and sizing. By default calls
        recursively.
    */
    layout: func(self) {
        self.w = 0
        self.h = 0

        loop_children(self, func(o) {
            if !o.floating { o.x, o.y = 0, 0 }
            o.layout()
            self.w = max(self.w, o.x + o.w)
            self.h = max(self.h, o.y + o.h)
        })
    },

    /**
        Adjusts layout of children widgets. Takes additional optional
        parameters px (0), py (0), pw (self.w), ph (self.h). Basically
        calls $adjust_layout on each child with those parameters.
    */
    adjust_children: func(self, px, py, pw, ph) {
        px, py, pw, ph = px || 0, py || 0, pw || self.w, ph || self.h
        loop_children(self, func(o) { o.adjust_layout(px, py, pw, ph) })
    },

    /**
        Layout adjustment hook for self. Adjusts x, y, w, h of the widget
        according to its alignment and clamping. When everything is done,
        calls $adjust_children with no parameters.
    */
    adjust_layout: func(self, px, py, pw, ph) {
        var x, y, w, h, a = self.x, self.y,
            self.w, self.h, self.adjust

        var adj = a & adjust.ALIGN_HMASK

        if adj == adjust.ALIGN_LEFT {
            x = px
        } else if adj == adjust.ALIGN_HCENTER {
            x = px + (pw - w) / 2
        } else if adj == adjust.ALIGN_RIGHT {
            x = px + pw - w
        }

        adj = a & adjust.ALIGN_VMASK

        if adj == adjust.ALIGN_TOP {
            y = py
        } else if adj == adjust.ALIGN_VCENTER {
            y = py + (ph - h) / 2
        } else if adj == adjust.ALIGN_BOTTOM {
            y = py + ph - h
        }

        if (a & adjust.CLAMP_MASK) != 0 {
            if (a & adjust.CLAMP_LEFT ) != 0 { x = px }
            if (a & adjust.CLAMP_RIGHT) != 0 {
                w = px + pw - x
            }

            if (a & adjust.CLAMP_TOP   ) != 0 { y = py }
            if (a & adjust.CLAMP_BOTTOM) != 0 {
                h = py + ph - y
            }
        }

        self.x, self.y, self.w, self.h = x, y, w, h
        self.adjust_children()
    },

    /**
        Given the cursor coordinates, this function should return the
        targeted widget. Returns undef if there is nothing or nothing
        targetable. By default this just loops the children in reverse
        order, calls target on each and returns the result of the first
        target call that actually returns something.
    */
    target: func(self, cx, cy) {
        return loop_in_children_r(self, cx, cy, func(o, ox, oy) {
            var c = o.visible && !o.disabled && o.target(ox, oy) || undef
            if c { return c }
        })
    },

    /**
        Called on keypress.  By default it doesn't define any behavior so it
        just loops children in reverse order and returns true if any key calls
        on the children return true or false if they don't. It also handles
        tab-cycling behavior when the tab_next field is defined.

        Arguments:
            - code - the keycode pressed.
            - isdown - true if it was pressed, false if it was released.

        See also:
            - $key_raw
            - $key_hover
            - $text_input
    */
    key: func(self, code, isdown) {
        var tn = self.tab_next
        if tn && code == key.TAB && self.is_focused() {
            if isdown { tn.set_focused(true) }
            return true
        }
        return loop_children_r(self, func(o) {
            if o.visible && !o.disabled &&  o.key(code, isdown) { return true }
        }) || false
    },

    /**
        A "raw" key handler that is used in the very beginning of the keypress
        handler. By default, it iterates the children (backwards), tries
        key_raw on each and if that returns true, it returns true too,
        otherwise it goes on (if nothing returned true, it returns false).
        If this returns false, the keypress handler continues normally.

        See also:
            - $key
            - $key_hover
            - $text_input
    */
    key_raw: func(self, code, isdown) {
        return loop_children_r(self, func(o) {
            if o.visible && !o.disabled && o.key_raw(code, isdown) { return true }
        }) || false
    },

    /**
        Called on text input on the widget. Returns true of the input was
        accepted and false otherwise. The default version loops children
        (backwards) and tries on each until it hits true.

        See also:
            - $key
            - $key_raw
            - $key_hover
    */
    text_input: func(self, str) {
        return loop_children_r(self, func(o) {
            if o.visible && !o.disabled && o.text_input(str) { return true }
        }) || false
    },

    /**
        Occurs on keypress (any key) when hovering over a widget. The default
        just tries to key_hover on its parent (returns false as a fallback).
        Called after $key_raw (if possible) and before mouse clicks and
        root $key.

        See also:
            - $key
            - $key_raw
            - $key_hover
    */
    key_hover: func(self, code, isdown) {
        var parent = self.parent
        if parent {
            return parent.key_hover(code, isdown)
        }
        return false
    },

    start_draw: func(self) {},
    end_draw: func(self) {},

    end_draw_change: func(self, change) {
        self.end_draw()
        changed &= ~change
        if changed != 0 {
            if (changed & changes.SHADER) != 0 { shader_hud_set() }
            if (changed & changes.COLOR ) != 0 { gle_color3f(1, 1, 1) }
            if (changed & changes.BLEND ) != 0 { blend_reset() }
        }
    },

    change_draw: func(self, change) {
        var root = self.get_root()
        change = change || 0
        if !root._drawing {
            self.start_draw()
            changed = change
        } else if root._drawing.type != self.type {
            root._drawing.end_draw_change(change)
            self.start_draw()
            changed = change
        }
        root._drawing = self
    },

    stop_draw: func(self) {
        var root = self.get_root()
        if  root._drawing {
            root._drawing.end_draw_change(0)
            root._drawing = undef
        }
    },

    /**
        Called in the drawing phase. By default just loops all the children
        and draws on these (assuming they're not fully clipped).

        Arguments:
            - sx, sy - the left and upper side coordinates of the widget,
              optional (if not present, they default to "x" and "y" properties
              of the current widget).
    */
    draw: func(self, sx, sy) {
        sx = sx || self.x
        sy = sy || self.y
        var root = self.get_root()

        loop_children(self, func(o) {
            var ox = o.x
            var oy = o.y
            var ow = o.w
            var oh = o.h
            if !root.clip_is_fully_clipped(sx + ox, sy + oy, ow, oh)
            && o.visible {
                o.draw(sx + ox, sy + oy)
            }
        })
    },

    /**
        Given the cursor coordinates, this function returns the widget
        currently hovered on. By default it just loops children in
        reverse order using $loop_in_children_r and calls hover recursively
        on each (and returns the one that first returns a defined value).
        If the hover call returns itself, it means we're hovering on the
        widget the method was called on and the current hover coords
        are set up appropriately.

        See also:
            - $click
    */
    hover: func(self, cx, cy) {
        var w = self.get_root()
        var isw = (self == w)
        return loop_in_children_r(self, cx, cy, func(o, ox, oy) {
            var c  = (o.visible && !o.disabled) && o.hover(ox, oy) || undef
            if    c == o {
                w._hover_x = ox
                w._hover_y = oy
            }
            if isw || c { return c, undef, true }
        }, true, isw)
    },

    /**
        Called every frame on the widget that's being hovered on (assuming
        it exists). It takes the coordinates we're hovering on. By default
        it emits the "hovering" signal on itself, passing the coordinates
        to it.

        See also:
             - $leaving
             - $holding
    */
    hovering: func(self, cx, cy) {
        emit(self, "hovering", cx, cy)
    },

    /**
        Called when a mouse cursor is leaving widget hover. Takes the cx
        and cy arguments like $hovering (they're the last position in the
        widget the cursor was hovering on) and emits the "leaving" signal,
        passing those arguments to it.
    */
    leaving: func(self, cx, cy) {
        emit(self, "leaving", cx, cy)
    },

    hold: func(self, cx, cy, obj) {
        return loop_in_children_r(self, cx, cy, func(o, ox, oy) {
            if o == obj { return ox, oy }
            if o.visible && !o.disabled { return o.hold(ox, oy, obj) }
        }, false, self == root)
    },

    /**
        See $hovering. It's the same, but called only when the widget
        is being held.
    */
    holding: func(self, cx, cy, code) {
        emit(self, "holding", cx, cy, code)
    },

    /**
        See $hover. It's identical, only for the click event. This also
        takes the currently clicked mouse button as the last argument.
    */
    click: func(self, cx, cy, code) {
        var w = self.get_root()
        var isw = (self == w)
        return loop_in_children_r(self, cx, cy, func(o, ox, oy) {
            var c  = (o.visible && !o.disabled) && o.click(ox, oy, code) || undef
            if    c == o {
                w._click_x = ox
                w._click_y = oy
            }
            if isw || c { return c, undef, true }
        }, true, isw)
    },

    /**
        Called once on the widget that was clicked. By emits the "clicked"
        signal on itself. Takes the click coords as arguments and passes
        them to the signal. Also takes the clicked mouse button code
        and passes it as well.

        See also:
            - $released
    */
    clicked: func(self, cx, cy, code) {
        emit(self, "clicked", cx, cy, code)
    },

    /**
        See $clicked. Emits the "released" signal with the same arguments
        as the "clicked" signal above. The coordinates are calculated by
        the time of button release, so they're up to date.
    */
    released: func(self, cx, cy, code) {
        emit(self, "released", cx, cy, code)
    },

    /**
        Returns true if the widget takes input in regular cursor mode. That
        is the default behavior. However, that is not always convenient as
        sometimes you want on-screen widgets that take input in free cursor
        mode only.
    */
    grabs_input: func(self) { return true },

    /**
        Finds a child widget.

        Arguments:
            - otype - the child type to find.
            - name - if the widget is named, this is taken into consideration.
            - recurse - if true (true by default), this will search recursively
              in children of the children.
            - exclude - a reference to a widget that should be excluded, this
              is optional. Note that this is never passed in recursively.

        See also:
            - $find_children
            - $find_sibling
    */
    find_child: func(self, otype, name, recurse, exclude) {
        recurse = (recurse == undef) && true || recurse
        var o = loop_children(self, func(o) {
            if o != exclude && o.type == otype &&
            (!name || name == o.obj_name) {
                return o
            }
        })
        if o { return o }
        if recurse {
            o = loop_children(self, func(o) {
                if o != exclude {
                    var found = o.find_child(otype, name)
                    if    found != undef { return found }
                }
            })
        }
        return o
    },

    /**
        See $find_child. Takes an extra argument (optional) which is an
        array. Unlike the above, this finds all possible matches and appends
        them to the given array (if not given, a new array is created). This
        returns the array. If the array is given and not empty, it's not
        erased (all matches append).
    */
    find_children: func(self, otype, name, recurse, exclude, ret) {
        var ch = ret || []
        recurse = (recurse == undef) && true || recurse
        loop_children(self, func(o) {
            if o != exclude && o.type == otype &&
            (!name || name == o.obj_name) {
                ch.push(o)
            }
        })
        if recurse {
            loop_children(self, func(o) {
                if o != exclude {
                    o.find_child(otype, name, true, undef, ch)
                }
            })
        }
        return ch
    },

    /**
        Finds a sibling of a widget. A sibling is basically defined as any
        child of the parent widget that isn't self (searched recursively),
        do any child of the parent widget of that parent widget and so on.

        Arguments:
            - otype - the sibling type.
            - name - the sibling name (if named).

        See also:
            - $find_siblings
            - $find_child
    */
    find_sibling: func(self, otype, name) {
        var prev = self
        var cur  = self.parent

        while cur {
            var o = cur.find_child(otype, name, true, prev)
            if    o { return o }

            prev = cur
            cur  = cur.parent
        }
    },

    /// See $find_sibling. Equivalent to $find_children.
    find_siblings: func(self, otype, name, ret) {
        var ch   = ret || []
        var prev = self
        var cur  = self.parent

        while cur {
            cur.find_children(otype, name, true, prev, ch)
            prev = cur
            cur  = cur.parent
        }
        return ch
    },

    /**
        Replaces a widget that has been tagged (inside a tag, the tag itself
        persists).

        Arguments:
            - tname - the tag name (name of a $Tag instance).
            - obj - the widget to replace the original with.
            - fun - optionally a function called at the end with "obj"
              as an argument.

        Returns:
            True if the replacement was successful, false otherwise.
    */
    replace: func(self, tname, obj, fun) {
        var tag = self.find_child(Tag.type, tname)
        if !tag { return false }
        tag.destroy_children()
        tag.append(obj)
        if fun { fun(obj) }
        return true
    },

    /**
        Removes the given widget from the widget's children. Alternatively,
        the argument can be the index of the child in the list. Returns true
        on success and false on failure.

        If the last argument "detach" is true, this doesn't clear the widget
        and instead of returning true or false, it returns the widget or undef.
    */
    remove: func(self, o, detach) {
        if typeof o == "number" {
            if self.children.len() < (o + 1) {
                if detach { return undef }
                return false
            }
            var r = self.children.remove(o)
            if detach { return r }
            r.clear()
            return true
        }
        for i, c in self.children.each() {
            if o == c {
                var r = self.children.remove(i)
                if detach { return r }
                r.clear()
                return true
            }
        }
        if detach { return undef }
        return false
    },

    /// Removes itself from its parent using $remove.
    destroy: func(self) {
        self.parent.remove(self)
    },

    /// Detaches itself from its parent using $remove.
    detach: func(self) {
        self.parent.remove(self, true)
    },

    /**
        Destroys all the children using regular $clear. Emits a signal
        "children,destroy" afterwards on self.
    */
    destroy_children: func(self) {
        var ch = self.children
        for i, o in ch.each() {
            o.clear()
        }
        self.children = []
        emit(self, "children,destroy")
    },

    /**
        Aligns the widget given the horizontal alignment and the vertical
        alignment. Those can be -1 (top, left), 0 (center) and 1 (bottom,
        right).
    */
    align: func(self, h, v) {
        self.adjust = (self.adjust & ~adjust.ALIGN_MASK)
            | ((clamp(h, -1, 1) + 2) << adjust.ALIGN_HSHIFT)
            | ((clamp(v, -1, 1) + 2) << adjust.ALIGN_VSHIFT)
    },

    /**
        Sets the widget clamping, given the left, right, top and bottom
        clamping. The values can be either true or false.
    */
    clamp: func(self, l, r, t, b) {
        self.adjust = (self.adjust & ~adjust.CLAMP_MASK)
            | (l && adjust.CLAMP_LEFT   || 0)
            | (r && adjust.CLAMP_RIGHT  || 0)
            | (t && adjust.CLAMP_TOP    || 0)
            | (b && adjust.CLAMP_BOTTOM || 0)
    },

    /** Function: get_alignment
        Returns the horizontal and vertical alignment of the widget in
        the same format as $align arguments.

        See also:
            - $align
            - $get_clamping
    */
    get_alignment: func(self) {
        var a   = self.adjust
        var adj = a & adjust.ALIGN_HMASK
        var hal = (adj == adjust.ALIGN_LEFT) && -1 ||
            (adj == adjust.ALIGN_HCENTER && 0 || 1)

        adj = a & adjust.ALIGN_VMASK
        var val = (adj == adjust.ALIGN_BOTTOM) && 1 ||
            (adj == adjust.ALIGN_VCENTER && 0 || -1)

        return hal, val
    },

    /**
        Returns the left, right, bottom, top clamping as either true or false.

        See also:
            - $clamp
            - $get_alignment
    */
    get_clamping: func(self) {
        var a   = self.adjust
        var adj = a & adjust.CLAMP_MASK
        if    adj == 0 {
            return 0, 0, 0, 0
        }

        return (a & adjust.CLAMP_LEFT  ) != 0, (a & adjust.CLAMP_RIGHT) != 0,
               (a & adjust.CLAMP_BOTTOM) != 0, (a & adjust.CLAMP_TOP  ) != 0
    },

    /// Function: set_floating
    set_floating: gen_setter("floating"),

    /// Function: set_visible
    set_visible: gen_setter("visible"),

    /// Function: set disabled
    set_disabled: gen_setter("disabled"),

    /// Returns the previous container, erases its parent and root, but doesn't
    /// destroy it.
    set_container: func(self, val) {
        var orig = self.container
        if orig {
            orig.parent = undef
            orig._root  = undef
        }
        self.container = val
        if val {
            val.parent = self
            val._root  = self.get_root()
        }
        emit(self, "container,changed", val)
        return orig
    },

    /// Function: set_init_clone
    set_init_clone: gen_setter("init_clone"),

    /// Function: set_tab_next
    set_tab_next: gen_setter("tab_next"),

    /** Function: insert
        Inserts a widget at the given position in the widget's children.

        Arguments:
            - pos - the position.
            - obj - the widget object.
            - fun - optional function called with "obj" as an argument after
              it has been inserted.
            - force_ch - forces insertion into "real" children even with the
              widget "container" property set.

        Returns:
            The given widget.

        See also:
            - $append
            - $prepend
    */
    insert: func(self, pos, obj, fun, force_ch) {
        var children = force_ch && self.children
            || (self.container || self).children
        children.insert(pos, obj)
        obj.parent = self
        obj._root  = self._root
        if fun { fun(obj) }
        return obj
    },

    /** Function: append
        Like $insert, but appends to the end of the children list.
    */
    append: func(self, obj, fun, force_ch) {
        var children = force_ch && self.children
            || (self.container || self).children
        children.push(obj)
        obj.parent = self
        obj._root  = self._root
        if fun { fun(obj) }
        return obj
    },

    /** Function: prepend
        Like $insert, but prepends (inserts to the beginning of the list).
    */
    prepend: func(self, obj, fun, force_ch) {
        var children = force_ch && self.children
            || (self.container || self).children
        children.insert(0, obj)
        obj.parent = self
        obj._root  = self._root
        if fun { fun(obj) }
        return obj
    },

    /**
        Given a menu object (any widget), this shows the menu with this widget
        as the parent.

        As for on-hover menus - you need to show your on-hover menu every time
        the "hovering" signal is activated, because it gets dropped next frame.

        Note that the this widget becomes the menu's parent, thus this widget
        becomes responsible for it (if it gets destroyed, it destroys the
        menu as well), that is, unless the menu changes parent in the meantime.

        Arguments:
            - obj - the menu object.
            - at_cursor - instead of using special positioning for menus
              and submenus, this shows the menu at cursor position.
            - clear_on_drop - clears the menu when dropped if true, the
              default behavior is that the menu remains alive until its parent
              is destroyed. If you can avoid using this, please do so, as
              it's more expensive. For example when creating on-hover menus,
              instead of setting the argument to true and creating a new widget
              every call of "hovering", create a permanent reference to the
              menu elsewhere instead.
    */
    show_menu: func(self, obj, at_cursor, clear_on_drop) {
        var root = self.get_root()
        root._menu_init(obj, self, at_cursor, clear_on_drop)
        return obj
    },

    /**
        Returns this widget's menu assuming it has one.
    */
    get_menu: func(self) { return self._menu },

    /**
        Given a tooltip object (any widget), this shows the tooltip with this
        widget as the parent. The same precautions as for $show_menu apply.
        There is no at_cursor argument (because that's how it behaves by
        default).

        You typically want to call this in the "hovering" signal of a widget.
        Make sure to actually create the tooltip object beforehand, somewhere
        where it's done just once (for example in the user constructor).
        Alternatively, you can pass clear_on_drop as true and create it
        everytime, but that's not recommended.

        Arguments:
            - obj - the tooltip object.
            - clear_on_drop - see $show_menu.

        See also:
            - $show_menu
    */
    show_tooltip: func(self, obj, clear_on_drop) {
        self.get_root()._tooltip_init(obj, self, clear_on_drop)
        return obj
    },

    /** Function: is_field
        Returns true if this widget is a textual field, by default false.
    */
    is_field: func() { return false },

    /**
        Returns the parent of this widget (or undef if no parent).
        This is just a plain hash table read, no complex retrieval.
    */
    get_parent: func(self) {
        return self.parent
    },

    /**
        Returns the root window of this widget. Note that this might do a more
        complex retrieval if root is unassigned and might modify parents (if
        it has to ask parents for root and they don't have it, it uses a
        recursive approach).
    */
    get_root: func(self) {
        var  rt = self._root
        if !rt {
            // a recursive approach makes sure parents will
            // have their roots assigned (for later use - faster)
            var par = self.get_parent()
            if par {
                rt = par.get_root()
                self._root = rt
                return rt
            }
        }
        return rt
    },

    /**
        Clears any kind of focus for this widget.
    */
    clear_focus: func(self) {
        var w = self.get_root()
        if self == w._clicked  { w._clicked  = undef }
        if self == w._hovering { w._hovering = undef }
        if self == w._focused  { w._focused  = undef }
    },

    /**
        If the button code is given, this returns true or false depending on
        whether the current widget is clicked in its root and was clicked
        using the given button; otherwise, returns the code of the button
        that it was clicked with if it's clicked, or false if it's not
        clicked at all.
    */
    is_clicked: func(self, btn) {
        var clked = self.get_root()._clicked
        if btn {
            return (self == clked) && (btn == clicked_code)
        } else if self == clked {
            return clicked_code
        } else {
            return false
        }
    },

    /**
        Returns true or false depending on whether the widget is being
        hovered on in its root.
    */
    is_hovering: func(self) { return self == self.get_root()._hovering },

    /**
        If the given parameter is true, this widget gets the focus within
        the root. If it's a non-true value, the widget gets unfocused
        assuming it's currently focused.
    */
    set_focused: func(self, foc) {
        var root = self.get_root()
        if foc {
            root._focused = self
        } else if root._focused == self {
            root._focused = undef
        }
    },

    /**
        Returns true or false depending on whether the widget is focused
        in its root.
    */
    is_focused: func(self) {
        return self == self.get_root()._focused
    },

    /**
        Returns false, as normal widgets are not roots.
    */
    is_root: func(self) {
        return false
    },

    /**
        Gets the widget's projection. If it doesn't exist it tries to create
        a new one unless the parameter is true. Returns the projection or
        undef.
    */
    get_projection: func(self, nonew) {
        var proj = self._projection
        if proj || nonew { return proj }
        proj = self.get_root().get_projection_object()(self)
        self._projection = proj
        return proj
    },

    /**
        Sets the widget's projection to some forced value. Returns the
        projection.
    */
    set_projection: func(self, proj) {
        self._projection = proj
        return proj
    }
})
Widget = M.Widget

/**
    Named widgets are regular widgets thave have a name that is specific
    to instance.

    Properties:
        - obj_name - can be passed in kwargs as "name".
*/
M.NamedWidget = register_type("NamedWidget", Widget, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.obj_name = kwargs.name
        return Widget::__ctor(self, kwargs, ...)
    },

    /// Function: set_obj_name
    set_obj_name: gen_setter("obj_name")
})
var NamedWidget = M.NamedWidget

/**
    Tags are special named widgets. They can contain more widgets. They're
    particularly useful when looking up certain part of a GUI structure or
    replacing something inside without having to iterate through and finding
    it manually.
*/
M.Tag = register_type("Tag", NamedWidget)
Tag = M.Tag

/**
    This is a regular window. It's nothing more than a special case of named
    widget. You can derive custom window types from this (see $Overlay) but
    you have to make sure the widget type stays the same (pass Window.type
    as the last argument to $register_type).

    Properties:
        - input_grab - true by default, specifies whether this window grabs
          input. If it's false, the window takes input only in free cursor
          mode.
*/
M.Window = register_type("Window", NamedWidget, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        var ig = kwargs.input_grab
        self.input_grab = ig == undef && true || ig
        self.above_hud = kwargs.above_hud || false
        return NamedWidget::__ctor(self, kwargs, ...)
    },

    /// Equivalent to win.parent.hide_window(win.obj_name).
    hide: func(self) {
        return self.parent.hide_window(self.obj_name)
    },

    grabs_input: func(self) { return self.input_grab },

    /// Function: set_input_grab
    set_input_grab: gen_setter("input_grab"),

    /// Function: set_above_hud
    set_above_hud: gen_setter("above_hud")
})
Window = M.Window

/**
    Overlays are windows that take no input under no circumstances. There is no
    difference otherwise. This overloads {{$Widget.grabs_input}} (returns
    false), {{$Widget.target}} (returns undef), {{$Widget.hover}} (returns undef)
    and {{$Widget.click}} (returns undef).

    There is one default overlay - the HUD. You can retrieve it using $get_hud.
    Its layout is managed separately, it takes root's dimensions. You can
    freely append into it. It gets cleared everytime you leave the map and it
    doesn't display when mainmenu is active.
*/
M.Overlay = register_type("Overlay", Window, {
    grabs_input: func(self) { return false },

    target: func() { },
    hover : func() { },
    click : func() { }
}, Window.type)
var Overlay = M.Overlay

/**
    A root is a structure that derives from $Widget and holds windows.
    It defines the base for calculating dimensions of child widgets as
    well as input hooks. It also provides some window management functions.
    By default the system creates one default root that holds all the
    primary windows. In the future it will be possible to create new
    roots for different purposes (e.g. in-game GUI on a surface) but
    that is not supported at this point.
*/
M.Root = register_type("Root", Widget, {
    __ctor: func(self) {
        self.windows     = {}
        self.cursor_x    = 0.499
        self.cursor_y    = 0.499
        self.has_cursor  = false
        self._root       = self
        self._clip_stack = []
        self._menu_stack = []
        self._menu_nhov  = undef
        self._tooltip    = undef
        self._hover_x    = 0
        self._hover_y    = 0
        self._click_x    = 0
        self._click_y    = 0
        self._clicked    = undef
        self._hovering   = undef
        self._focused    = undef
        self._drawing    = undef
        self._rtxt_scale = 0
        self._ctxt_scale = 0
        return Widget::__ctor(self)
    },

    /**
        This custom overload of {{$Widget.grabs_input}} loops children
        (in reverse order) and calls grabs_input on each. If any of them
        returns true, this also returns true, otherwise it returns false.
    */
    grabs_input: func(self) {
        return loop_children_r(self, func(o) {
            if o.grabs_input() { return true }
        }) || false
    },

    adjust_children: func(self) {
        loop_children(self, func(o) {
            var proj = self.set_projection(o.get_projection())
            proj.adjust_layout()
            self.set_projection(undef)
        })
    },

    layout_dim: func(self) {
        self.x, self.y = 0, 0
        self.w, self.h = self.get_aspect(true), 1
    },

    /**
        Overloads {{$Widget.layout}}. Calculates proper root dimensions
        (takes forced aspect set using an engine variable forceaspect into
        account), then layouts every child (using correct projection separate
        for every window) and do adjusts children.
    */
    layout: func(self) {
        self.layout_dim()

        loop_children(self, func(o) {
            if !o.floating { o.x, o.y = 0, 0 }
            self.set_projection(o.get_projection())
            o.layout()
            self.set_projection(undef)
        })

        self.adjust_children()
    },

    draw: func(self, sx, sy) {
        sx = sx || self.x
        sy = sy || self.y

        loop_children(self, func(o) {
            var ox = o.x
            var oy = o.y
            var ow = o.w
            var oh = o.h
            if !self.clip_is_fully_clipped(sx + ox, sy + oy, ow, oh)
            && o.visible {
                o.get_projection().draw(sx + ox, sy + oy)
            }
        })

        var tooltip = self._tooltip
        var ms = self._menu_stack
        for i, o in ms.each() {       o.get_projection().draw() }
        if tooltip            { tooltip.get_projection().draw() }
    },

    build_window: func(self, name, win, fun) {
        var old = self.find_child(Window.type, name, false)
        if old { self.remove(old) }
        win = win({ name: name })
        win.parent = self
        win._root  = self._root
        self.children.push(win)
        if fun { fun(win) }
        return win
    },

    /**
        Creates a window, but doesn't show it. At the time of creation the
        structure is not built, it merely creates a callback that it stores.
        The window is actually built when shown, and destroyed when hidden.

        If there already is a window of that name, it returns the old build
        hook. You can call it with no arguments to show the window. If you
        pass true as the sole argument, it returns whether the window is
        currently visible. If you pass false to it, it marks the window
        as invisible/destroyed (without actually hiding anything, unlike
        <hide_window> which destroys it AND marks it). Don't actually rely
        on this, it's only intended for the internals.

        Arguments:
            - name - the window name.
            - win - the window object type (for example $Window or $Overlay).
            - fun - the function to call after the window has been built
              (with the window as an argument).
    */
    new_window: func(self, name, win, fun) {
        var old = self.windows[name]
        var visible = false
        self.windows[name] = func(vis) {
            if vis == true {
                return visible
            } else if vis == false {
                visible = false
                return undef
            }
            self.build_window(name, win, fun)
            visible = true
        }
        return old
    },

    /**
        Triggers a window build. The window has to exist, if it doesn't,
        this just returns true. Otherwise builds the window and returns
        true.
    */
    show_window: func(self, name) {
        var  g = self.windows[name]
        if !g { return false }
        g()
        return true
    },

    /// Returns the window build hook (the same one $show_window calls).
    get_window: func(self, name) {
        return self.windows[name]
    },

    /**
        Hides a window - that is, destroys it. It can be re-built anytime
        later. Returns true if it actually destroyed anything, false otherwise.
        If the given argument is the boolean value "true" rather than a window
        name, this hides the topmost window that grabs input.
    */
    hide_window: func(self, name) {
        if name == true {
            var twin = self.children.last()
            if !twin || !twin.grabs_input() { return false }
            name = twin.obj_name
        }
        var old = self.find_child(Window.type, name, false)
        if old { self.remove(old) }
        var win = self.windows[name]
        if !win {
            logger::log(logger.ERROR, "no such window: " ~ name)
            return false
        }
        win(false) // set visible to false
        return old != undef
    },

    /**
        This finds a window of the given name in the children and returns
        `win.replace(tname, obj, fun)`. It's merely a convenient wrapper.

        Arguments:
            - wname - the window name.
            - tname - the tag name.
            - obj - the object.
            - fun - the optional function (see {{$Widget.replace}}).

        Returns:
            The result of replacing, and false if the window doesn't exist.
    */
    replace_in_window: func(self, wname, tname, obj, fun) {
        var win = self.find_child(Window.type, wname, false)
        if !win { return false }
        return win.replace(tname, obj, fun)
    },

    /**
        Given a window name, this returns true if that window is currently
        shown and false otherwise.
    */
    window_visible: func(self, name) {
        return self.windows[name](true)
    },

    above_hud: func(self) {
        var y = 1
        for i, w in self.children.each() {
            if w.above_hud {
                y = min(y, w.get_projection().calc_above_hud())
            }
        }
        return y
    },

    /**
        Sets the root's cursor position, given the global pointer
        coordinates. By default this simply copies the given values.
    */
    set_cursor: func(self, x, y) {
        self.cursor_x = x
        self.cursor_y = y
    },

    /**
        Returns whether the current root has a cursor. If the argument
        is true, this does an update (re-checks, updates the value and
        emits an internal signal).
    */
    cursor_exists: func(self, update) {
        var cec = self.has_cursor
        if !update { return cec }
        var bce = cec
        cec = self.grabs_input() || self.target(self.cursor_x * self.w,
            self.cursor_y * self.h) != undef
        if bce != cec {
            self.has_cursor = cec
            emit(self, "__has_cursor,changed", cec)
        }
        return cec
    },

    /**
        Returns true as roots are alway roots.
    */
    is_root: func(self) {
        return true
    },

    /**
        Gets the widget's projection. Unlike regular projection getter,
        this doesn't attempt to create a new projection if one doesn't
        exist as roots typically don't have projections.
    */
    get_projection: func(self) {
        return self._projection
    },

    /// Pushes a clip area into the root's clip stack and scissors.
    clip_push: func(self, x, y, w, h) {
        var cs = self._clip_stack
        if cs.empty() { gl_scissor_enable() }

        var c = ClipArea(x, y, w, h)
        cs.push(c)

        if cs.len() >= 2 { c.intersect(cs[cs.len() - 2]) }
        c.scissor(self)
    },

    /**
        Pops a clip area out of the clip stack and scissors (assuming there
        is anything left on the clip stack).
    */
    clip_pop: func(self) {
        var cs = self._clip_stack
        cs.pop()
        if cs.empty() { gl_scissor_disable()
        } else { cs.last().scissor(self)
        }
    },

    /**
        See $ClipArea.is_fully_clipped. Works on the last clip area on the
        clip stack.
    */
    clip_is_fully_clipped: func(self, x, y, w, h) {
        var cs = self._clip_stack
        if cs.empty() { return false }
        return cs.last().is_fully_clipped(x, y, w, h)
    },

    /**
        Scissors the last area in the clip stack.
    */
    clip_scissor: func(self) {
        self._clip_stack.last().scissor(self)
    },

    _tooltip_init: func(self, o, op, clear_on_drop) {
        op.managed_objects[o] = o
        var oldop = o.parent
        if oldop { oldop.managed_objects[o] = undef }

        self._tooltip  = o
        o.parent       = op
        o._root        = self
        op._root       = self
        self.set_projection(o.get_projection())
        o.layout()
        self.set_projection(undef)

        o._clear_on_drop = clear_on_drop

        var x, y = self.cursor_x * self.w + 0.01, self.cursor_y + 0.01
        var tw, th = o.w, o.h
        if (x + tw * 0.95) > self.w {
            x = x - tw + 0.02
            if x <= 0 { x = 0.02 }
        }
        if (y + th * 0.95) > 1 {
            y = y - th + 0.02
        }
        o.x, o.y = max(0, x), max(0, y)
    },

    _menus_drop: func(self, n) {
        var ms = self._menu_stack
        n = n || ms.len()
        while n > 0 {
            var o = ms.pop()
            var op = o.parent
            if o._clear_on_drop {
                o.clear()
                op.managed_objects[o] = undef
            }
            op._menu = undef
            n -= 1
        }
    },

    /// Clears currently shown menus.
    clear_menus: func(self) {
        self._menus_drop()
    },

    _menu_init: func(self, o, op, at_cursor, clear_on_drop) {
        if self._menu_nhov && self._menu_nhov < 0 {
            self._menus_drop()
        }

        op.managed_objects[o] = o
        var oldop = o.parent
        if oldop { oldop.managed_objects[o] = undef }

        var ms = self._menu_stack
        ms.push(o)
        o.is_menu = true
        o.parent  = op
        o._root   = self
        op._root  = self
        op._menu  = o

        o._clear_on_drop = clear_on_drop

        var prevo = (ms.len() > 1) && ms[ms.len() - 2] || undef

        // initial layout to guess the bounds
        var proj = self.set_projection(o.get_projection())
        o.layout()
        proj.calc()
        var pw, ph = proj.pw, proj.ph
        self.set_projection(undef)

        // parent projection (for correct offsets)
        var fw, fh
        if !prevo {
            var win = o.parent
            while true {
                var p = win.parent
                if !p.parent { break }
                win = p
            }
            var proj = win.get_projection()
            fw, fh = pw / proj.pw, ph / proj.ph
        } else {
            var proj = prevo.get_projection()
            fw, fh = pw / proj.pw, ph / proj.ph
        }

        // ow/h: menu w/h, opw/h: menu parent w/h (e.g. menubutton)
        var ow, oh, opw, oph = o.w, o.h, op.w * fw, op.h * fh

        var cx, cy = self.cursor_x, self.cursor_y

        // when spawning menus right on the cursor
        if at_cursor {
            // compute cursor coords in terms of widget position
            var x, y = cx * pw, cy * ph
            // adjust y so that it's always visible as whole
            if (y + oh) > ph { y = max(0, y - oh) }
            // adjust x if clipped on the right
            if (x + ow) > pw {
                x = max(0, x - ow)
            }
            // set position and return
            o.x, o.y = max(0, x), max(0, y)
            return
        }

        var hov = self._hovering
        var dx, dy = hov && self._hover_x * fw || self._click_x * fw,
                     hov && self._hover_y * fh || self._click_y * fh
        // omx, omy: the base position of the new menu
        var omx, omy = cx * pw - dx, cy * ph - dy

        // a submenu - uses different alignment - submenus are put next to
        // their spawners, regular menus are put under their spawners
        if ms.len() > 1 {
            // when the current y + height of menu exceeds the screen height,
            // move the menu up by its height minus the spawner height, make
            // sure it's at least 0 (so that it's not accidentally moved above
            // the screen)
            if omy + oh > ph {
                omy = max(0, omy - oh + oph)
            }
            // when the current x + width of the spawner + width of the menu
            // exceeds the screen width, move it to the left by its width,
            // making sure the x is at least 0
            if (omx + opw + ow) > pw {
                omx = max(0, omx - ow)
            // else offset by spawner width
            } else {
                omx += opw
            }
        // regular menu
        } else {
            // when current y + height of spawner + height of menu exceeds the
            // screen height, move the menu up by its height, make sure
            // it's > 0
            if omy + oph + oh > ph {
                omy = max(0, omy - oh)
            // otherwise move down a bit (by the button height)
            } else {
                omy += oph
            }
            // adjust x here - when the current x + width of the menu exceeds
            // the screen width, perform adjustments
            if (omx + ow) > pw {
                // if the menu spawner width exceeds the screen width too,
                // put the menu to the right
                if (omx + opw) > pw {
                    omx = max(0, pw - ow)
                // else align it with the spawner
                } else { omx = max(0, omx - ow + opw) }
            }
        }
        o.x, o.y = max(0, omx), max(0, omy)
    },

    menu_click: func(self, o, cx, cy, code) {
        var proj = o.get_projection()
        var ox, oy = cx * proj.pw - o.x, cy * proj.ph - o.y
        if ox >= 0 && ox < o.w && oy >= 0 && oy < o.h {
            var cl = o.click(ox, oy, code)
            if cl == o { self._click_x, self._click_y = ox, oy }
            return true, cl
        } else {
            return false
        }
    },

    menu_hover: func(self, o, cx, cy) {
        var proj = o.get_projection()
        var ox, oy = cx * proj.pw - o.x, cy * proj.ph - o.y
        if ox >= 0 && ox < o.w && oy >= 0 && oy < o.h {
            var cl = o.hover(ox, oy)
            if cl == o { self._hover_x, self._hover_y = ox, oy }
            return true, cl
        } else {
            return false
        }
    },

    menu_hold: func(self, o, cx, cy, obj) {
        var proj = o.get_projection()
        var ox, oy = cx * proj.pw - o.x, cy * proj.ph - o.y
        if obj == o { return ox, oy }
        return o.hold(ox, oy, obj)
    },

    /**
        Returns the width of this root window in pixels. By default just
        retrieves HUD width from the engine. Override as needed. The second
        parameter (if provided - if not, then no aspect forcing will be taken
        into consideration) can be either a number specifying forced aspect
        ratio (width divided by height) or true, in which case $get_aspect
        is used.
    */
    get_pixel_w: func(self, faspect) {
        if faspect == true { faspect = self.get_aspect() }
        if faspect {
            return ceil(hud_get_w() * faspect)
        }
        return hud_get_w()
    },

    /**
        Returns the height of this root window in pixels. By default just
        retrieves HUD height from the engine. Override as needed.
    */
    get_pixel_h: func(self) {
        return hud_get_h()
    },

    /**
        If this returns undef, aspect ratio will be auto-computed. Otherwise
        you can return any aspect ratio as a floating point number which is
        a result of division of width by height. By default checks forced
        aspect variable in the engine and returns undef if it's 0 or the
        value. Override as needed.

        Keep in mind that if the second provided paremter is true, this will
        return in all cases - as return value of $get_pixel_w divided by
        return value of $get_pixel_h.
    */
    get_aspect: func(self, forceret) {
        var faspect = aspect_get()
        if faspect != 0 { return faspect }
        if forceret { return self.get_pixel_w() / self.get_pixel_h() }
    },

    /**
        Returns the number of rows of text that can fit on the screen. Used
        to calculate text scale. By default just returns $uitextrows.
    */
    get_text_rows: func(self) {
        return uitextrows
    },

    calc_text_scale: func(self) {
        self._rtxt_scale = 1 / self.get_text_rows()
        var tw, th = self.get_pixel_w(true), self.get_pixel_h()
        tw, th = text_get_res(tw, th)
        self._ctxt_scale = text_font_get_h() * console_scale_get() / th
    },

    get_text_scale: func(self, con) {
        return con && self._ctxt_scale || self._rtxt_scale
    },

    /// Returns the projection object used by windows of this root.
    get_projection_object: func(self) {
        return Projection
    },

    /// Given a value in pixels, this returns the value in UI units.
    get_ui_size: func(self, px) {
        return px / self.get_pixel_h()
    },

    update: func(self, cx, cy) {
        self.set_cursor(cx, cy)

        var tooltip = self._tooltip
        if tooltip && tooltip._clear_on_drop {
            tooltip.clear()
            tooltip.parent.managed_objects[tooltip] = undef
        }
        tooltip, self._tooltip = undef, undef

        self.calc_text_scale()

        if self.cursor_exists() && self.visible {
            var hovering_try
            var hk, hl
            var nhov = -1
            var ms = self._menu_stack
            for i, v in ms.each_r() {
                hk, hl = self.menu_hover(v, self.cursor_x,
                    self.cursor_y)
                if hk {
                    hovering_try = hl
                    if hl { nhov = i }
                    break
                }
            }
            var oldhov, oldhx, oldhy
                = self._hovering, self._hover_x, self._hover_y
            if hk {
                self._hovering = hovering_try
            } else {
                self._hovering = self.hover(self.cursor_x, self.cursor_y)
            }
            if oldhov && oldhov != self._hovering {
                oldhov.leaving(oldhx, oldhy)
            }
            if self._hovering {
                var msl = ms.len()
                if msl > 0 && nhov >= 0 && (msl - 1) > nhov {
                    self._menus_drop(msl - nhov - 1)
                }
                self._menu_nhov = nhov
                self._hovering.hovering(self._hover_x, self._hover_y)
                self._menu_nhov = undef
            }

            if self._clicked {
                var hx, hy
                for i, v in ms.each_r() {
                    hx, hy = self.menu_hold(v, self.cursor_x, self.cursor_y,
                        self._clicked)
                    if hx { break }
                }
                if !hx {
                    hx, hy = self.hold(self.cursor_x, self.cursor_y,
                        self._clicked)
                }
                self._clicked.holding(hx, hy, clicked_code)
            }
        } else {
            self._hovering, self._clicked = undef, undef
        }

        if self.visible { self.layout() }

        tooltip = self._tooltip
        if tooltip {
            var proj = self.set_projection(tooltip.get_projection())
            tooltip.layout()
            proj.calc()
            tooltip.adjust_children()
            self.set_projection(undef)
        }

        for i, o in self._menu_stack.each() {
            var proj = self.set_projection(o.get_projection())
            o.layout()
            proj.calc()
            o.adjust_children()
            self.set_projection(undef)
        }

        self.cursor_exists(true)
    },

    /**
        Resets the root (drops all children, menus and tooltip). Emits
        the "reset" signal at the end.
    */
    reset: func(self) {
        self.destroy_children()
        if self._tooltip && self._tooltip._clear_on_drop {
            self._tooltip.clear()
            self._tooltip.parent.managed_objects[self._tooltip] = undef
        }
        self._tooltip = undef
        self._menus_drop()
        emit(self, "reset")
    }
})
var Root = M.Root

root = Root()

signal::connect(root, "__has_cursor,changed", func(self, val) {
    input_cursor_exists_update(val)
})

var hud = Overlay({ name: "hud" })
hud._root = root

/// Returns the HUD overlay.
M.get_hud = func() {
    return hud
}

var mousebuttons = {
    (key.MOUSELEFT): true, (key.MOUSEMIDDLE) : true, (key.MOUSERIGHT): true,
    (key.MOUSEBACK): true, (key.MOUSEFORWARD): true
}

set_external("input_keypress", func(code, isdown) {
    if !root.cursor_exists() || !root.visible || root.disabled {
        return false
    }
    if root.key_raw(code, isdown) {
        return true
    }
    if root._hovering && root._hovering.key_hover(code, isdown) {
        return true
    }
    if mousebuttons[code] {
        if isdown {
            clicked_code = code
            var clicked_try
            var ck, cl
            var ms = root._menu_stack
            if !ms.empty() {
                for i, v in ms.each_r() {
                    ck, cl = root.menu_click(v, root.cursor_x, root.cursor_y,
                        code)
                    if ck {
                        clicked_try = cl
                        break
                    }
                }
                if !ck { root._menus_drop() }
            }
            if ck {
                root._clicked = clicked_try
            } else {
                root._clicked = root.click(root.cursor_x, root.cursor_y, code)
            }
            if root._clicked {
                root._clicked.clicked(root._click_x, root._click_y, code)
            } else {
                clicked_code = undef
            }
        } else {
            if root._clicked {
                var hx, hy
                var ms = root._menu_stack
                for i, v in ms.each_r() {
                    hx, hy = root.menu_hold(v, root.cursor_x,
                        root.cursor_y, root._clicked)
                    if hx { break }
                }
                if !hx {
                    hx, hy = root.hold(root.cursor_x, root.cursor_y,
                        root._clicked)
                }
                root._clicked.released(hx, hy, code)
            }
            clicked_code, root._clicked = undef, undef
        }
        return true
    }
    return root.key(code, isdown)
})

set_external("input_text", func(str) {
    return root.text_input(str)
})

var draw_hud = false

var mmenu = var_get("mainmenu")
signal::connect(cs, "mainmenu,changed", func(self, v) {
    mmenu = v
})

set_external("gui_clear", func() {
    root.reset()
    if mmenu != 0 && isconnected() {
        var_set("mainmenu", 0, true, false)
    }
    if draw_hud {
        hud.destroy_children()
        draw_hud = false
    }
})

set_external("gui_update", func() {
    if mmenu != 0 && !root.window_visible("main") &&
    !isconnected(true) {
        root.show_window("main")
    }

    draw_hud = (mmenu == 0 && editing_get() == 0) && hud.visible || false

    var cx, cy = input_cursor_get_x(), input_cursor_get_y()

    root.update(cx, cy)

    if draw_hud {
        var proj = root.set_projection(hud.get_projection())
        hud.layout()
        hud.x, hud.y, hud.w, hud.h = 0, 0, root.w, root.h
        proj.calc()
        hud.adjust_children()
        root.set_projection(undef)
    }
})

M.__draw_window = func(win) {
    // draw on main root
    win.x, win.y, win.parent, win._root = 0, 0, root, root
    var proj = root.set_projection(win.get_projection())
    proj.calc()
    win.layout()
    proj.adjust_layout()
    proj.draw()
    root.set_projection(undef)
}

set_external("gui_render", func() {
    var w = root
    if draw_hud || (w.visible && !w.children.empty()) {
        w.draw()
        if draw_hud { hud.get_projection().draw() }
        gle_disable()
    }
})

set_external("gui_above_hud", func() {
    return root.above_hud()
})

/// Gets the default GUI root widget.
M.get_root = func() {
    return root
}

return M
