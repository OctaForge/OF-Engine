/**<
    Various primitive widgets (rectangles, text and others).

    Author:
        q66 <daniel@octaforge.org>

    License:
        See COPYING.txt.
*/

import capi
import apiutil
import std.geom
import core.engine.model
import core.engine.cubescript as cs
import core.events.signal

var gl_blend_func, shader_hudnotexture_set, shader_hud_set, gl_bind_texture,
gl_texture_param, shader_hud_set_variant, gle_begin, gle_end, gle_defvertexf,
gle_deftexcoord0f, gle_color4f, gle_attrib2f, texture_load,
texture_load_alpha_mask, texture_get_notexture, thumbnail_load,
texture_draw_slot, texture_draw_vslot, gl_blend_disable, gl_blend_enable,
gl_scissor_disable, gl_scissor_enable, gle_disable, model_preview_start,
model_preview, model_preview_end, hudmatrix_push, hudmatrix_scale,
hudmatrix_flush, hudmatrix_pop, hudmatrix_translate, text_draw,
text_get_bounds, text_font_push, text_font_pop, text_font_set,
console_render_full, text_font_get_w, text_font_get_h, prefab_preview in capi

var emit = signal.emit

from std.conv import tostring
from std.math import min, max, abs, clamp, floor, ceil, huge
from std.table import len

var Vec2 = geom.Vec2
var sincosmod360 = geom.sin_cos_mod_360
var sincos360 = geom.sin_cos_360

/// Module: core
import core.gui.core as M

// consts
var gl = M.gl

// widget types
var register_type = M.register_type

// primitive drawing
var quad, quadtri = M.draw_quad, M.draw_quadtri

// color
var Color = M.Color

// base widgets
var Widget = M::get_type("Widget")

// setters
var gen_setter = M.gen_setter

var Filler = M.Filler

var init_color = func(col) {
    return col && (typeof col == "number" && Color(col) || col) || Color()
}

var gen_color_setter = func(name) {
    var sname = name ~ ",changed"
    return func(self, val) {
        self[name] = init_color(val)
        emit(self, sname, val)
    }
}

/**
    Derived from $Filler. Represents a regular rectangle.

    Properties:
        - color - color of the rectangle, defaults to $Color() - via kwargs
          you can initialize it either via $Color constructor or a hex number
          in format 0xRRGGBB or 0xAARRGGBB.
        - solid - if true, it's a solid color rectangle (default), otherwise
          it modulates the color its background.
*/
M.ColorFiller = register_type("ColorFiller", Filler, {
    __ctor: func(self, kwargs, ...) {
        kwargs       = kwargs || {}
        self.solid = kwargs.solid != false && true || false
        self.color = init_color(kwargs.color)

        return Filler::__ctor(self, kwargs, ...)
    },

    start_draw: func(self) {
        shader_hudnotexture_set()
        gle_defvertexf(2)
    },

    draw: func(self, sx, sy) {
        var w, h, color, solid in self

        self.change_draw(M.changes.SHADER | M.changes.COLOR | M.changes.BLEND)
        if !solid { M::blend_mod() } else { M::blend_reset() }
        color.init()

        gle_begin(gl.TRIANGLE_STRIP)
        gle_attrib2f(sx,     sy)
        gle_attrib2f(sx + w, sy)
        gle_attrib2f(sx,     sy + h)
        gle_attrib2f(sx + w, sy + h)
        gle_end()

        return Filler::draw(self, sx, sy)
    },

    /// Function: set_solid
    set_solid: gen_setter("solid"),

    /// Function: set_color
    set_color: gen_color_setter("color")
})
var ColorFiller = M.ColorFiller

/**
    Derived from $ColorFiller.

    Properties:
        - horizontal - by default the gradient is vertical, if this is true
          it's horizontal.
        - color2 - the other color of the gradient.
*/
M.Gradient = register_type("Gradient", ColorFiller, {
    __ctor: func(self, kwargs, ...) {
        ColorFiller::__ctor(self, kwargs, ...)
        self.horizontal = kwargs.horizontal
        self.color2 = init_color(kwargs.color2)
    },

    start_draw: func(self) {
        var color in self
        shader_hudnotexture_set()
        gle_defvertexf(2)
        color::def()
    },

    draw: func(self, sx, sy) {
        var w, h, color, color2, solid, horizontal in self

        self.change_draw(M.changes.SHADER | M.changes.COLOR | M.changes.BLEND)
        if !solid { M::blend_mod() } else { M::blend_reset() }

        gle_begin(gl.TRIANGLE_STRIP)

        gle_attrib2f(sx, sy)
        if horizontal {
            color2.attrib()
        } else {
            color.attrib()
        }
        gle_attrib2f(sx + w, sy)     color.attrib()
        gle_attrib2f(sx,     sy + h) color2.attrib()
        gle_attrib2f(sx + w, sy + h)
        if horizontal {
            color.attrib()
        } else {
            color2.attrib()
        }

        gle_end()

        return Filler::draw(self, sx, sy)
    },

    /// Function: set_horizontal
    set_horizontal: gen_setter("horizontal"),

    /// Function: set_color2
    set_color2: gen_color_setter("color2")
})

/**
    Derived from $Filler. Represents a line.

    Properties:
        - color - see $ColorFiller.
*/
M.Line = register_type("Line", Filler, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.color = init_color(kwargs.color)
        return Filler::__ctor(self, kwargs, ...)
    },

    start_draw: func(self) {
        shader_hudnotexture_set()
        gle_defvertexf(2)
    },

    draw: func(self, sx, sy) {
        var color, w, h in self

        self.change_draw(M.changes.SHADER | M.changes.COLOR)
        color.init()

        gle_begin(gl.LINE_LOOP)
        gle_attrib2f(sx,     sy)
        gle_attrib2f(sx + w, sy + h)
        gle_end()

        return Filler::draw(self, sx, sy)
    },

    /// Function: set_color
    set_color: gen_color_setter("color")
})

/**
    Derived from $Filler. Represents an outline.

    Properties:
        - color - see $ColorFiller.
*/
M.Outline = register_type("Outline", Filler, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.color = init_color(kwargs.color)
        return Filler::__ctor(self, kwargs, ...)
    },

    start_draw: func(self) {
        shader_hudnotexture_set()
        gle_defvertexf(2)
    },

    draw: func(self, sx, sy) {
        var color, w, h in self

        self.change_draw(M.changes.SHADER | M.changes.COLOR)
        color.init()

        gle_begin(gl.LINE_LOOP)
        gle_attrib2f(sx,     sy)
        gle_attrib2f(sx + w, sy)
        gle_attrib2f(sx + w, sy + h)
        gle_attrib2f(sx,     sy + h)
        gle_end()

        return Filler::draw(self, sx, sy)
    },

    /// Function: set_color
    set_color: gen_color_setter("color")
})

var check_alpha_mask = func(tex, x, y) {
    if tex.alphamask == undef {
        if texture_load_alpha_mask(tex) == undef {
            return true
        }
    }

    var xs, ys = tex.xs, tex.ys
    var tx, ty = clamp(floor(x * tex.xs), 0, tex.xs - 1),
                 clamp(floor(y * tex.ys), 0, tex.ys - 1)

    if (tex.alphamask[ty * ((tex.xs + 7) / 8)] & (1 << (tx % 8))) != 0 {
        return true
    }

    return false
}

var lasttex

/** Struct: Image
    Derived from $Filler. Represents a basic image with basic stretching.

    Images are basically containers for texture objects. Texture objects
    are low-level and documented elsewhere.

    The file and alt_file properties are not saved in the image.

    Properties:
        - file - filename of the texture.
        - alt_file - alternative filename assuming file fails.
        - min_filter, mag_filter - see GL_TEXTURE_MIN_FILTER and
          GL_TEXTURE_MAG_FILTER as well as filters later in this module.
        - color - see $ColorFiller.
*/
M.Image = register_type("Image", Filler, {
    __ctor: func(self, kwargs, ...) {
        kwargs    = kwargs || {}
        var tex = kwargs.file && texture_load(kwargs.file)

        var notexture = texture_get_notexture()
        var af = kwargs.alt_file
        if (!tex || tex == notexture) && af {
            tex = texture_load(af)
        }

        self.texture = tex || notexture
        self.min_filter = kwargs.min_filter
        self.mag_filter = kwargs.mag_filter
        self.color = init_color(kwargs.color)

        return Filler::__ctor(self, kwargs, ...)
    },

    ///  Returns the loaded texture filename.
    get_tex: func(self) {
        return self.texture.name
    },

    /**
        Given the filename and an alternative filename, this reloads the
        texture this holds. If the file argument is undef/false, this
        disables the texture (sets the texture to notexture).
    */
    set_tex: func(self, file, alt) {
        if !file {
            self.texture = texture_get_notexture()
            return
        }
        var tex = texture_load(file)
        if  tex == texture_get_notexture() && alt {
            tex = texture_load(alt)
        }
        self.texture = tex
    },

    /**
        Images are normally targetable (they're not only where they're
        completely transparent). See also {{$Widget.target}}.
    */
    target: func(self, cx, cy) {
        var o = Widget::target(self, cx, cy)
        if    o { return o }

        var tex = self.texture
        return (tex.bpp < 32 || check_alpha_mask(tex, cx / self.w,
                                                       cy / self.h)) && self
    },

    start_draw: func(self) {
        lasttex = undef
        gle_defvertexf(2)
        gle_deftexcoord0f(2)
        gle_begin(gl.TRIANGLE_STRIP)
    },

    end_draw: func(self) {
        gle_end()
    },

    draw: func(self, sx, sy) {
        var minf, magf, tex = self.min_filter,
                              self.mag_filter, self.texture
        var color = self.color

        if tex == texture_get_notexture() {
            return Filler::draw(self, sx, sy)
        }

        self.change_draw()
        color.init()

        if lasttex != tex {
            if lasttex {
                gle_end()
            }
            lasttex = tex
            shader_hud_set_variant(tex)
            gl_bind_texture(tex.id)
        }

        if minf && minf != 0 {
            gl_texture_param(gl.TEXTURE_MIN_FILTER, minf)
        }
        if magf && magf != 0 {
            gl_texture_param(gl.TEXTURE_MAG_FILTER, magf)
        }

        quadtri(sx, sy, self.w, self.h)

        return Filler::draw(self, sx, sy)
    },

    layout: func(self) {
        Widget::layout(self)

        var min_w = self.min_w
        var min_h = self.min_h
        if typeof min_w == "function" { min_w = min_w(self) }
        if typeof min_h == "function" { min_h = min_h(self) }

        var r = self.get_root()

        if min_w < 0 { min_w = r.get_ui_size(abs(min_w)) }
        if min_h < 0 { min_h = r.get_ui_size(abs(min_h)) }

        var proj = r.get_projection()
        if min_w == huge { min_w = proj.pw }
        if min_h == huge { min_h = proj.ph }

        if  min_w == 0 || min_h == 0 {
            var tex = self.texture
            if min_w == 0 { min_w = r.get_ui_size(tex.w) }
            if min_h == 0 { min_h = r.get_ui_size(tex.h) }
        }

        self._min_w, self._min_h = min_w, min_h
        self.w = max(self.w, min_w)
        self.h = max(self.h, min_h)
    },

    /// Function: set_min_filter
    set_min_filter: gen_setter("min_filter"),

    /// Function: set_mag_filter
    set_min_filter: gen_setter("mag_filter"),

    /// Function: set_color
    set_color: gen_color_setter("color")
})
var Image = M.Image

/**
    Represents a raw texture. Not meant for regular use. It's here to aid
    some of the internal OF UIs. Has only a subset of $Image's features.
*/
M.Texture = register_type("Texture", Filler, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.texture_id = kwargs.texture_id
        return Filler::__ctor(self, kwargs, ...)
    },

    target: func(self, cx, cy) {
        var o = Widget::target(self, cx, cy)
        if    o { return o }
        return self
    },

    start_draw: func(self) {
        lasttex = undef
        gle_defvertexf(2)
        gle_deftexcoord0f(2)
        gle_begin(gl.TRIANGLE_STRIP)
    },

    end_draw: func(self) {
        gle_end()
    },

    draw: func(self, sx, sy) {
        self.change_draw()
        gl_bind_texture(self.texture_id)
        quadtri(sx, sy, self.w, self.h)
        return Filler::draw(self, sx, sy)
    },

    layout: func(self) {
        Widget::layout(self)

        var min_w = self.min_w
        var min_h = self.min_h
        if typeof min_w == "function" { min_w = min_w(self) }
        if typeof min_h == "function" { min_h = min_h(self) }

        var r = self.get_root()

        if min_w < 0 { min_w = r.get_ui_size(abs(min_w)) }
        if min_h < 0 { min_h = r.get_ui_size(abs(min_h)) }

        var proj = r.get_projection()
        if min_w == huge { min_w = proj.pw }
        if min_h == huge { min_h = proj.ph }

        self.w = max(self.w, min_w)
        self.h = max(self.h, min_h)
    }
})

var get_border_size = func(tex, size, vert) {
    if size >= 0 {
        return size
    }
    return abs(size) / (vert && tex.ys || tex.xs)
}

/**
    Deriving from $Image, this represents a cropped image. Negative crop
    values are in pixels.

    Properties:
        - crop_x, crop_y - the crop x and y position, they default to 0.
        - crop_w, crop_h - the crop dimensions, they default to 1.
*/
M.CroppedImage = register_type("CroppedImage", Image, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}

        Image::__ctor(self, kwargs, ...)
        var tex = self.texture

        self.crop_x = get_border_size(tex, kwargs.crop_x || 0, false)
        self.crop_y = get_border_size(tex, kwargs.crop_y || 0, true)
        self.crop_w = get_border_size(tex, kwargs.crop_w || 1, false)
        self.crop_h = get_border_size(tex, kwargs.crop_h || 1, true)
    },

    target: func(self, cx, cy) {
        var o = Widget::target(self, cx, cy)
        if    o { return o }

        var tex = self.texture
        return (tex.bpp < 32 || check_alpha_mask(tex,
            self.crop_x + cx / self.w * self.crop_w,
            self.crop_y + cy / self.h * self.crop_h)) && self
    },

    start_draw: func(self) {
        lasttex = undef
        gle_defvertexf(2)
        gle_deftexcoord0f(2)
        gle_begin(gl.TRIANGLE_STRIP)
    },

    end_draw: func(self) {
        gle_end()
    },

    draw: func(self, sx, sy) {
        var minf, magf, tex = self.min_filter,
                              self.mag_filter, self.texture
        var color = self.color

        if tex == texture_get_notexture() {
            return Filler::draw(self, sx, sy)
        }

        self.change_draw()
        color.init()

        if lasttex != tex {
            if lasttex {
                gle_end()
            }
            lasttex = tex
            shader_hud_set_variant(tex)
            gl_bind_texture(tex.id)
        }

        if minf && minf != 0 {
            gl_texture_param(gl.TEXTURE_MIN_FILTER, minf)
        }
        if magf && magf != 0 {
            gl_texture_param(gl.TEXTURE_MAG_FILTER, magf)
        }

        quadtri(sx, sy, self.w, self.h,
            self.crop_x, self.crop_y, self.crop_w, self.crop_h)

        return Filler::draw(self, sx, sy)
    },

    ///
    set_crop_x: func(self, cx) {
        cx = get_border_size(self.texture, cx, false)
        self.crop_x = cx
        emit(self, "crop_x,changed", cx)
    },

    ///
    set_crop_y: func(self, cy) {
        cy = get_border_size(self.texture, cy, true)
        self.crop_y = cy
        emit(self, "crop_y,changed", cy)
    },

    ///
    set_crop_w: func(self, cw) {
        cw = get_border_size(self.texture, cw, false)
        self.crop_w = cw
        emit(self, "crop_w,changed", cw)
    },

    ///
    set_crop_h: func(self, ch) {
        ch = get_border_size(self.texture, ch, true)
        self.crop_h = ch
        emit(self, "crop_h,changed", ch)
    }
})

/**
    Derives from $Image and represents a stretched image type. Regular
    images stretch as well, but this uses better quality (and more expensive)
    computations instead of basic stretching.
*/
M.StretchedImage = register_type("StretchedImage", Image, {
    target: func(self, cx, cy) {
        var o = Widget::target(self, cx, cy)
        if    o { return o }
        if self.texture.bpp < 32 { return self }

        var mx, my, mw, mh, pw, ph = 0, 0, self._min_w, self._min_h,
                                             self.w,      self.h

        if     pw <= mw          { mx = cx / pw
        } else if cx <  mw / 2      { mx = cx / mw
        } else if cx >= pw - mw / 2 { mx = 1 - (pw - cx) / mw
        } else {  mx = 0.5 }

        if     ph <= mh          { my = cy / ph
        } else if cy <  mh / 2      { my = cy / mh
        } else if cy >= ph - mh / 2 { my = 1 - (ph - cy) / mh
        } else {  my = 0.5 }

        return check_alpha_mask(self.texture, mx, my) && self
    },

    start_draw: func(self) {
        lasttex = undef
        gle_defvertexf(2)
        gle_deftexcoord0f(2)
        gle_begin(gl.QUADS)
    },

    end_draw: func(self) {
        gle_end()
    },

    draw: func(self, sx, sy) {
        var minf, magf, tex = self.min_filter,
                              self.mag_filter, self.texture
        var color = self.color

        if tex == texture_get_notexture() {
            return Filler::draw(self, sx, sy)
        }

        self.change_draw()
        color.init()

        if lasttex != tex {
            if lasttex {
                gle_end()
            }
            lasttex = tex
            shader_hud_set_variant(tex)
            gl_bind_texture(tex.id)
        }

        if minf && minf != 0 {
            gl_texture_param(gl.TEXTURE_MIN_FILTER, minf)
        }
        if magf && magf != 0 {
            gl_texture_param(gl.TEXTURE_MAG_FILTER, magf)
        }

        var mw, mh, pw, ph = self._min_w, self._min_h, self.w, self.h

        var splitw = (mw != 0 && min(mw, pw) || pw) / 2
        var splith = (mh != 0 && min(mh, ph) || ph) / 2
        var vy, ty = sy, 0

        for i in 1 to 3 {
            var vh, th = 0, 0
            if i == 1 {
                if splith < ph - splith {
                    vh, th = splith, 0.5
                } else {
                    vh, th = ph, 1
                }
            } else if i == 2 {
                vh, th = ph - 2 * splith, 0
            } else if i == 3 {
                vh, th = splith, 0.5
            }

            var vx, tx = sx, 0

            for j in 1 to 3 {
                var vw, tw = 0, 0
                if j == 1 {
                    if splitw < pw - splitw {
                        vw, tw = splitw, 0.5
                    } else {
                        vw, tw = pw, 1
                    }
                } else if j == 2 {
                    vw, tw = pw - 2 * splitw, 0
                } else if j == 3 {
                    vw, tw = splitw, 0.5
                }
                quad(vx, vy, vw, vh, tx, ty, tw, th)
                vx, tx = vx + vw, tx + tw
                if  tx >= 1 { break }
            }
            vy, ty = vy + vh, ty + th
            if  ty >= 1 { break }
        }

        return Filler::draw(self, sx, sy)
    }
})

/**
    Derives from $Image. Turns the provided image into a border or a frame.
    Use a <Spacer> with screen_border as padding to offset the children away
    from the border. Without any children, this renders only the corners.
    Negative tex_border represents the value in pixels.

    Properties:
        - screen_border - determines the border size.
        - tex_border - determines a texture offset from which to create the
          borders.
*/
M.BorderedImage = register_type("BorderedImage", Image, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        Image::__ctor(self, kwargs, ...)
        self.tex_border = get_border_size(self.texture, kwargs.tex_border || 0)
        self.screen_border = kwargs.screen_border || 0
    },

    layout: func(self) {
        Widget::layout(self)

        var sb = self.screen_border
        self.w = max(self.w, 2 * sb)
        self.h = max(self.h, 2 * sb)
    },

    target: func(self, cx, cy) {
        var o = Widget::target(self, cx, cy)
        if    o { return o }

        var tex = self.texture

        if tex.bpp < 32 {
            return self
        }

        var mx, my, tb, sb = 0, 0, self.tex_border, self.screen_border
        var pw, ph = self.w, self.h

        if     cx <  sb      { mx = cx / sb * tb
        } else if cx >= pw - sb { mx = 1 - tb + (cx - (pw - sb)) / sb * tb
        } else {  mx = tb + (cx - sb) / (pw - 2 * sb) * (1 - 2 * tb) }

        if     cy <  sb      { my = cy / sb * tb
        } else if cy >= ph - sb { my = 1 - tb + (cy - (ph - sb)) / sb * tb
        } else {  my = tb + (cy - sb) / (ph - 2 * sb) * (1 - 2 * tb) }

        return check_alpha_mask(tex, mx, my) && self
    },

    start_draw: func(self) {
        lasttex = undef
        gle_defvertexf(2)
        gle_deftexcoord0f(2)
        gle_begin(gl.QUADS)
    },

    end_draw: func(self) {
        gle_end()
    },

    draw: func(self, sx, sy) {
        var minf, magf, tex = self.min_filter,
                              self.mag_filter, self.texture
        var color = self.color

        if tex == texture_get_notexture() {
            return Filler::draw(self, sx, sy)
        }

        self.change_draw()
        color.init()

        if lasttex != tex {
            if lasttex {
                gle_end()
            }
            lasttex = tex
            shader_hud_set_variant(tex)
            gl_bind_texture(tex.id)
        }

        if minf && minf != 0 {
            gl_texture_param(gl.TEXTURE_MIN_FILTER, minf)
        }
        if magf && magf != 0 {
            gl_texture_param(gl.TEXTURE_MAG_FILTER, magf)
        }

        var tb, sb = self.tex_border, self.screen_border

        var vy, ty = sy, 0
        for i in 1 to 3 {
            var vh, th = 0, 0
            if i == 2 {
                vh, th = self.h - 2 * sb, 1 - 2 * tb
            } else {
                vh, th = sb, tb
            }
            var vx, tx = sx, 0
            for j in 1 to 3 {
                var vw, tw = 0, 0
                if j == 2 {
                    vw, tw = self.w - 2 * sb, 1 - 2 * tb
                } else {
                    vw, tw = sb, tb
                }
                quad(vx, vy, vw, vh, tx, ty, tw, th)
                vx, tx = vx + vw, tx + tw
            }
            vy, ty = vy + vh, ty + th
        }

        return Filler::draw(self, sx, sy)
    },

    ///
    set_tex_border: func(self, tb) {
        tb = get_border_size(self.texture, tb)
        self.tex_border = tb
        emit(self, "tex_border,changed", tb)
    },

    /// Function: set_screen_border
    set_screen_border: gen_setter("screen_border")
})

/**
    Derived from $Image. Represents a tiled image.

    Properties:
        - tile_w, tile_h - tile width and height, they default to 1.
*/
M.TiledImage = register_type("TiledImage", Image, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}

        self.tile_w = kwargs.tile_w || 1
        self.tile_h = kwargs.tile_h || 1

        return Image::__ctor(self, kwargs, ...)
    },

    target: func(self, cx, cy) {
        var o = Widget::target(self, cx, cy)
        if    o { return o }

        var tex = self.texture

        if tex.bpp < 32 { return self }

        var tw, th = self.tile_w, self.tile_h
        var dx, dy = cx % tw, cy % th

        return check_alpha_mask(tex, dx / tw, dy / th) && self
    },

    start_draw: func(self) {
        var tex in self
        lasttex = undef
        gle_defvertexf(2)
        gle_deftexcoord0f(2)
        if tex.clamp != 0 {
            gle_begin(gl.QUADS)
        } else {
            gle_begin(gl.TRIANGLE_STRIP)
        }
    },

    end_draw: func(self) {
        gle_end()
    },

    draw: func(self, sx, sy) {
        var minf, magf, tex = self.min_filter,
                              self.mag_filter, self.texture
        var color = self.color

        if tex == texture_get_notexture() {
            return Filler::draw(self, sx, sy)
        }

        self.change_draw()
        color.init()

        if lasttex != tex {
            if lasttex {
                gle_end()
            }
            lasttex = tex
            shader_hud_set_variant(tex)
            gl_bind_texture(tex.id)
        }

        if minf && minf != 0 {
            gl_texture_param(gl.TEXTURE_MIN_FILTER, minf)
        }
        if magf && magf != 0 {
            gl_texture_param(gl.TEXTURE_MAG_FILTER, magf)
        }

        var pw, ph, tw, th = self.w, self.h, self.tile_w, self.tile_h

        // we cannot use the built in OpenGL texture
        // repeat with clamped textures
        if tex.clamp != 0 {
            var dx, dy = 0, 0
            while dx < pw {
                while dy < ph {
                    var dw, dh = min(tw, pw - dx), min(th, ph - dy)
                    quad(sx + dx, sy + dy, dw, dh, 0, 0, dw / tw, dh / th)
                    dy = dy + th
                }
                dx, dy = dy + tw, 0
            }
        } else {
            quadtri(sx, sy, pw, ph, 0, 0, pw / tw, ph / th)
        }

        return Filler::draw(self, sx, sy)
    },

    draw: func(self, sx, sy) {
        var minf, magf, tex = self.min_filter,
                                self.mag_filter, self.texture

        if tex == texture_get_notexture() {
            return Filler::draw(self, sx, sy)
        }

        shader_hud_set_variant(tex)
        gl_bind_texture(tex.id)

        if minf && minf != 0 {
            gl_texture_param(gl.TEXTURE_MIN_FILTER, minf)
        }
        if magf && magf != 0 {
            gl_texture_param(gl.TEXTURE_MAG_FILTER, magf)
        }

        self.color.init()



        return Filler::draw(self, sx, sy)
    },

    /// Function: set_tile_w
    set_tile_w: gen_setter("tile_w"),

    /// Function: set_tile_h
    set_tile_h: gen_setter("tile_h")
})

/**
    Derived from $Image. Represents a thumbnail. You can't supply an alt
    image via kwargs, you can supply the other stuff. A thumbnail's default
    texture is notexture and the delay between loads of different
    thumbnails is defined using the "thumbtime" engine variable which
    defaults to 25 milliseconds. If the thumbnail is requested (by
    targeting it), it loads immediately.
*/
M.Thumbnail = register_type("Thumbnail", Image, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.file = kwargs.file
        self.texture = kwargs.fallback && texture_load(kwargs.fallback)
            || texture_get_notexture()

        self.min_filter = kwargs.min_filter
        self.mag_filter = kwargs.mag_filter
        self.color = init_color(kwargs.color)

        return Filler::__ctor(self, kwargs, ...)
    },

    load: func(self, force) {
        if self.loaded { return }
        var tex = thumbnail_load(self.file, force)
        if tex != texture_get_notexture() {
            self.loaded = true
            self.texture = tex
        }
    },

    /**
        Unlike the regular target in $Image, this force-loads the thumbnail
        texture and do targets. See also {{$Image.target}}.
    */
    target: func(self, cx, cy) {
        self.load(true)
        return Image::target(self, cx, cy)
    },

    /**
        Before drawing, this tries to load the thumbnail, but without forcing
        it like $target.
    */
    draw: func(self, sx, sy) {
        self.load()
        return Image::draw(self, sx, sy)
    },

    /**
        Loads the fallback texture. If the thumbnail is already loaded,
        doesn't do anything.
    */
    set_fallback: func(self, fallback) {
        if self.loaded { return }
        if fallback { self.texture = texture_load(fallback) }
    }
})

/**
    Derived from $Filler. Represents a texture slot thumbnail, for example
    in a texture selector. Regular thumbnail rules and delays are followed
    like in $Thumbnail. See also $VSlotViewer.

    Properties:
        - index - the texture slot index (starting with 0, defaults to 0).
*/
M.SlotViewer = register_type("SlotViewer", Filler, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.index = kwargs.index || 0
        self.tex_w, self.tex_h = 0, 0

        return Filler::__ctor(self, kwargs, ...)
    },

    target: func(self, cx, cy) {
        return Widget::target(self, cx, cy) || self
    },

    draw: func(self, sx, sy) {
        self.change_draw(M.changes.SHADER | M.changes.COLOR)
        self.__update_dimensions(texture_draw_slot(self.index, self.w, self.h, sx, sy))
        return Widget::draw(self, sx, sy)
    },

    __update_dimensions: func(self, tw, th) {
        if self.tex_w != tw || self.tex_h != th {
            self.tex_w, self.tex_h = tw, th
            emit(self, "tex_size,changed", tw, th)
        }
    },

    /// Function: set_index
    set_index: gen_setter("index")
})

/**
    Similar to (and derives from) $SlotViewer, but previews vslots.
*/
M.VSlotViewer = register_type("VSlotViewer", M.SlotViewer, {
    draw: func(self, sx, sy) {
        self.change_draw(M.changes.SHADER | M.changes.COLOR)
        self.__update_dimensions(texture_draw_vslot(self.index, self.w, self.h, sx, sy))
        return Widget::draw(self, sx, sy)
    }
})

var view_start_draw = func(self) {
    gl_blend_disable()
    gle_disable()
    var root = self.get_root()
    var csl = !root._clip_stack.empty()
    if csl { gl_scissor_disable() }
}

var view_end_draw = func(self) {
    gl_blend_enable()
    var root = self.get_root()
    var csl = !root._clip_stack.empty()
    if csl { gl_scissor_enable() }
}

var build_attachments = func(self) {
    var att = self.attachments
    if att == self._last_attachments {
        return self._c_attachments, att.len() * 2
    }
    var n = att.len() * 2
    var stor = apiutil::make_strarray(n)
    for i in 0 to att.len() - 1 {
        var at = att[i]
        stor[i * 2], stor[i * 2 + 1] = at[0], at[1]
    }
    self._c_attachments = stor
    self._last_attachments = att
    return stor, n
}

/**
    Derived from $Filler. Represents a 3D model preview.

    Properties:
        - model - the model name (like mapmodel paths).
        - anim - an integer.
        - attachments - an array of tag-attachment pairs.
*/
M.ModelViewer = register_type("ModelViewer", Filler, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.model = kwargs.model
        self.anim = kwargs.anim || 0
        self.attachments = kwargs.attachments || []

        return Filler::__ctor(self, kwargs, ...)
    },

    start_draw: view_start_draw,
    end_draw: view_end_draw,

    draw: func(self, sx, sy) {
        self.change_draw(M.changes.SHADER)
        var w, h in self
        var root = self.get_root()
        var csl = !root._clip_stack.empty()
        var sx1, sy1, sx2, sy2 = root.get_projection().calc_scissor(sx, sy,
            sx + w, sy + h, true)
        model_preview_start(sx1, sy1, sx2 - sx1, sy2 - sy1, csl)
        var anim = self.anim
        model_preview(self.model, anim, build_attachments(self))
        if csl { root.clip_scissor() }
        model_preview_end()
        return Widget::draw(self, sx, sy)
    },

    /// Function: set_model
    set_model: gen_setter("model"),

    /// Function: set_anim
    set_anim: gen_setter("anim"),

    /// Function: set_attachments
    set_attachments: gen_setter("attachments")
})

/**
    Derived from $Filler. Represents a 3D prefab preview.

    Properties:
        - prefab - the prefab name.
        - color - the color (alpha is ignored).
*/
M.PrefabViewer = register_type("PrefabViewer", Filler, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.prefab = kwargs.prefab
        self.color  = init_color(kwargs.color)

        return Filler::__ctor(self, kwargs, ...)
    },

    start_draw: view_start_draw,
    end_draw: view_end_draw,

    draw: func(self, sx, sy) {
        self.change_draw(M.changes.SHADER)
        var prefab = self.prefab
        if !prefab { return Widget::draw(self, sx, sy) }
        var w, h in self
        var root = self.get_root()
        var csl = !root._clip_stack.empty()
        var sx1, sy1, sx2, sy2 = root.get_projection().calc_scissor(sx, sy,
            sx + w, sy + h, true)
        model_preview_start(sx1, sy1, sx2 - sx1, sy2 - sy1, csl)
        var col = self.color
        prefab_preview(prefab, col.r / 255, col.g / 255, col.b / 255)
        if csl { root.clip_scissor() }
        model_preview_end()
        return Widget::draw(self, sx, sy)
    },

    /// Function: set_prefab
    set_prefab: gen_setter("prefab"),

    /// Function: set_color
    set_color: gen_color_setter("color")
})

/// A full console widget that derives from $Filler.
M.Console = register_type("Console", Filler, {
    draw_scale: func(self) {
        return self.get_root().get_text_scale(true) / text_font_get_h()
    },

    draw: func(self, sx, sy) {
        self.change_draw(M.changes.SHADER | M.changes.COLOR)

        var k = self.draw_scale()
        hudmatrix_push()
        hudmatrix_translate(sx, sy, 0)
        hudmatrix_scale(k, k, 1)
        hudmatrix_flush()
        console_render_full(self.w / k, self.h / k)
        hudmatrix_pop()
        return Filler::draw(self, sx, sy)
    }
})

var SOLID    = 0
var OUTLINE  = 1
var MODULATE = 2

/**
    Represents a generic shape that derives from $Filler.

    Properties:
        - style - can be Shape.SOLID, Shape.OUTLINE, Shape.MODULATE (defaults
          to solid).
        - color - see $ColorFiller.
*/
M.Shape = register_type("Shape", Filler, {
    SOLID   : SOLID,
    OUTLINE : OUTLINE,
    MODULATE: MODULATE,

    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.style = kwargs.style || 0
        self.color = init_color(kwargs.color)
        return Filler::__ctor(self, kwargs, ...)
    },

    start_draw: func(self) {
        shader_hudnotexture_set()
        gle_defvertexf(2)
    },

    /// Function: set_style
    set_style: gen_setter("style"),

    /// Function: set_color
    set_color: gen_color_setter("color")
})
var Shape = M.Shape

/**
    A regular triangle that derives from $Shape.  Its width and height is
    determined by min_w and min_h (same conventions as on $Filler apply).

    Properties:
        - angle - the triangle rotation (in degrees).
*/
M.Triangle = register_type("Triangle", Shape, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.angle = kwargs.angle || 0
        return Shape::__ctor(self, kwargs, ...)
    },

    layout: func(self) {
        Widget::layout(self)

        var w, h = self.min_w, self.min_h
        if typeof w == "function" { w = w(self) }
        if typeof h == "function" { h = h(self) }
        var angle = self.angle
        var r = self.get_root()

        if w < 0 { w = r.get_ui_size(abs(w)) }
        if h < 0 { h = r.get_ui_size(abs(h)) }

        var proj = r.get_projection()
        if w == huge { w = proj.pw }
        if h == huge { h = proj.ph }

        var a = Vec2(0, -h * 2 / 3)
        var b = Vec2(-w / 2, h / 3)
        var c = Vec2( w / 2, h / 3)

        if angle != 0 {
            var rot = sincosmod360(-angle)
            a.rotate_around_z(rot)
            b.rotate_around_z(rot)
            c.rotate_around_z(rot)
        }

        var bbmin = Vec2(a).min(b).min(c)
        a.sub(bbmin)
        b.sub(bbmin)
        c.sub(bbmin)
        var bbmax = Vec2(a).max(b).max(c)

        self.ta, self.tb, self.tc = a, b, c

        self.w = max(self.w, bbmax.x)
        self.h = max(self.h, bbmax.y)
    },

    target: func(self, cx, cy) {
        var o = Widget::target(self, cx, cy)
        if o { return o }
        if self.style == OUTLINE { return undef }
        var a, b, c = self.ta, self.tb, self.tc
        var side = Vec2(cx, cy).sub(b).cross(Vec2(a).sub(b)) < 0
        return ((Vec2(cx, cy).sub(c).cross(Vec2(b).sub(c)) < 0) == side
            && (Vec2(cx, cy).sub(a).cross(Vec2(c).sub(a)) < 0) == side)
            && self || undef
    },

    draw: func(self, sx, sy) {
        var color, style in self
        self.change_draw(M.changes.SHADER | M.changes.COLOR | M.changes.BLEND)
        if style == MODULATE { M::blend_mod() } else { M::blend_reset() }
        color.init()
        gle_begin(style == OUTLINE && gl.LINE_LOOP || gl.TRIANGLES)
        gle_attrib2f(Vec2(sx, sy).add(self.ta).unpack())
        gle_attrib2f(Vec2(sx, sy).add(self.tb).unpack())
        gle_attrib2f(Vec2(sx, sy).add(self.tc).unpack())
        gle_end()
        return Shape::draw(self, sx, sy)
    },

    /// Function: set_angle
    set_angle: gen_setter("angle")
})

/**
    A regular circle that derives from $Shape. Its radius is determined
    by min_w and min_h (same conventions as on $Filler apply when it comes
    to widget bounds and the smaller one is used to determine radius).

    Properties:
        - sides - defaults to 15, specifying the number of sides this circle
          will have (it's not a perfect circle, but rather a polygon).
*/
M.Circle = register_type("Circle", Shape, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        self.sides = kwargs.sides || 15
        return Shape::__ctor(self, kwargs, ...)
    },

    target: func(self, cx, cy) {
        var o = Widget::target(self, cx, cy)
        if o { return o }
        if self.style == OUTLINE { return undef }
        var r = min(self.w, self.h)
        return (Vec2(cx, cy).sub(r).squared_len() <= (r * r)) && self || undef
    },

    draw: func(self, sx, sy) {
        var color, style in self
        self.change_draw(M.changes.SHADER | M.changes.COLOR | M.changes.BLEND)
        if style == MODULATE { M::blend_mod() } else { M::blend_reset() }
        color.init()
        var radius = min(self.w, self.h) / 2
        var center = Vec2(sx + radius, sy + radius)
        if style == OUTLINE {
            gle_begin(gl.LINE_LOOP)
            for angle in 0 to 359 by 360 / self.sides {
                gle_attrib2f(sincos360(angle).mul_new(radius)
                    .add(center).unpack())
            }
            gle_end()
        } else {
            gle_begin(gl.TRIANGLE_FAN)
            gle_attrib2f(center.x,          center.y)
            gle_attrib2f(center.x + radius, center.y)
            var sides = self.sides
            for angle in (360 / sides) to 359 by 360 / sides {
                var p = sincos360(angle).mul_new(radius).add(center)
                gle_attrib2f(p.unpack())
                gle_attrib2f(p.unpack())
            }
            gle_attrib2f(center.x + radius, center.y)
            gle_end()
        }
        return Shape::draw(self, sx, sy)
    },

    /// Function: set_sides
    set_sides: gen_setter("sides")
})

/**
    A regular label. If the scale is negative, it uses console text scaling
    multiplier instead of regular one.

    Properties:
         - text - the label.
         - font - the font (optional).
         - scale - the font scale, defaults to 1.
         - wrap - whether to wrap the text, defaults to -1 - not wrapping,
           otherwise it's a number of characters.
         - color - see $ColorFiller.
*/
M.Label = register_type("Label", Widget, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}

        self.text  = kwargs.text  || ""
        self.font  = kwargs.font  || undef
        self.scale = kwargs.scale ||  1
        self.wrap  = kwargs.wrap  || -1
        self.color = init_color(kwargs.color)

        return Widget::__ctor(self, kwargs, ...)
    },

    /**
        Labels are always targetable. See also {{$Widget.target}}.
    */
    target: func(self, cx, cy) {
        return Widget::target(self, cx, cy) || self
    },

    draw_scale: func(self) {
        var scale = self.scale
        return (abs(scale) * self.get_root().get_text_scale(scale < 0))
            / text_font_get_h()
    },

    draw: func(self, sx, sy) {
        self.change_draw(M.changes.SHADER | M.changes.COLOR)

        text_font_push()
        text_font_set(self.font)
        hudmatrix_push()

        var k = self.draw_scale()
        hudmatrix_scale(k, k, 1)
        hudmatrix_flush()

        var w = self.wrap
        var text = tostring(self.text)
        var r, g, b, a = self.color.get_final_rgba(self)
        text_draw(text, sx / k, sy / k, r, g, b, a, -1, w <= 0 && -1 || w / k)

        gle_color4f(1, 1, 1, 1)
        hudmatrix_pop()
        text_font_pop()

        return Widget::draw(self, sx, sy)
    },

    layout: func(self) {
        Widget::layout(self)

        text_font_push()
        text_font_set(self.font)
        var k = self.draw_scale()

        var w, h = text_get_bounds(self.text,
            self.wrap <= 0 && -1 || self.wrap / k)

        if self.wrap <= 0 {
            self.w = max(self.w, w * k)
        } else {
            self.w = max(self.w, min(self.wrap, w * k))
        }

        self.h = max(self.h, h * k)
        text_font_pop()
    },

    /// Function: set_text
    set_text: gen_setter("text"),

    /// Function: set_font
    set_font: gen_setter("font"),

    /// Function: set_scale
    set_scale: gen_setter("scale"),

    /// Function: set_wrap
    set_wrap: gen_setter("wrap"),

    /// Function: set_color
    set_color: gen_color_setter("color")
})

/**
    See $Label. Instead of the property "text", there is "func", which is
    a callable value that returns the text to display.
*/
M.EvalLabel = register_type("EvalLabel", Widget, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}

        self.callback = kwargs.callback || undef
        self.font     = kwargs.font  || undef
        self.scale    = kwargs.scale    ||  1
        self.wrap     = kwargs.wrap     || -1
        self.color    = init_color(kwargs.color)

        return Widget::__ctor(self, kwargs, ...)
    },

    target: func(self, cx, cy) {
        return Widget::target(self, cx, cy) || self
    },

    draw_scale: func(self) {
        var scale = self.scale
        return (abs(scale) * self.get_root().get_text_scale(scale < 0))
            / text_font_get_h()
    },

    draw: func(self, sx, sy) {
        var val = self.val_saved
        if !val { return Widget::draw(self, sx, sy) }

        self.change_draw(M.changes.SHADER | M.changes.COLOR)

        text_font_push()
        text_font_set(self.font)
        hudmatrix_push()

        var k = self.draw_scale()
        hudmatrix_scale(k, k, 1)
        hudmatrix_flush()

        var w = self.wrap
        var text = tostring(val) || ""
        var r, g, b, a = self.color.get_final_rgba(self)
        text_draw(text, sx / k, sy / k, r, g, b, a, -1, w <= 0 && -1 || w / k)

        gle_color4f(1, 1, 1, 1)
        hudmatrix_pop()
        text_font_pop()

        return Widget::draw(self, sx, sy)
    },

    layout: func(self) {
        Widget::layout(self)

        var cmd = self.callback
        if !cmd { return }
        var val = cmd(self)
        self.val_saved = val

        text_font_push()
        text_font_set(self.font)
        var k = self.draw_scale()

        var w, h = text_get_bounds(val || "",
            self.wrap <= 0 && -1 || self.wrap / k)

        if self.wrap <= 0 {
            self.w = max(self.w, w * k)
        } else {
            self.w = max(self.w, min(self.wrap, w * k))
        }

        self.h = max(self.h, h * k)
        text_font_pop()
    },

    /// Function: set_callback
    set_callback: gen_setter("callback"),

    /// Function: set_scale
    set_scale: gen_setter("scale"),

    /// Function: set_wrap
    set_wrap: gen_setter("wrap"),

    /// Function: set_color
    set_color: gen_color_setter("color")
})

/** Variable: FILTER_LINEAR
    A texture fitler equivalent to GL_LINEAR.
*/
M.FILTER_LINEAR = gl.LINEAR

/** Variable: FILTER_LINEAR_MIPMAP_LINAER
    A texture fitler equivalent to GL_LINEAR_MIPMAP_LINEAR.
*/
M.FILTER_LINEAR_MIPMAP_LINEAR = gl.LINEAR_MIPMAP_LINEAR

/** Variable: FILTER_LINEAR_MIPMAP_NEAREST
    A texture fitler equivalent to GL_LINEAR_MIPMAP_NEAREST.
*/
M.FILTER_LINEAR_MIPMAP_NEAREST = gl.LINEAR_MIPMAP_NEAREST

/** Variable: FILTER_NEAREST
    A texture fitler equivalent to GL_NEAREST.
*/
M.FILTER_NEAREST = gl.NEAREST

/** Variable: FILTER_NEAREST_MIPMAP_LINEAR
    A texture fitler equivalent to GL_NEAREST_MIPMAP_LINEAR.
*/
M.FILTER_NEAREST_MIPMAP_LINEAR = gl.NEAREST_MIPMAP_LINEAR

/** Variable: FILTER_NEAREST_MIPMAP_NEAREST
    A texture fitler equivalent to GL_NEAREST_MIPMAP_NEAREST.
*/
M.FILTER_NEAREST_MIPMAP_NEAREST = gl.NEAREST_MIPMAP_NEAREST
