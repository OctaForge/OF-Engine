/**<
    Text editors and fields.

    Author:
        q66 <quaker66@gmail.com>

    License:
        See COPYING.txt.
*/

import capi
import core.octascript.stream
import core.events.signal
import core.engine.cubescript as cs
import std.ffi

var clipboard_set_text, clipboard_get_text, clipboard_has_text, text_draw,
text_get_bounds, text_get_position, text_is_visible, input_is_modifier_pressed,
input_textinput, input_keyrepeat, input_get_key_name, hudmatrix_push,
hudmatrix_translate, hudmatrix_flush, hudmatrix_scale, hudmatrix_pop,
shader_hudnotexture_set, shader_hud_set, gle_color4ub, gle_defvertexf,
gle_begin, gle_end, gle_attrib2f, text_font_push, text_font_pop, text_font_set,
text_font_get_w, text_font_get_h in capi

var emit = signal.emit

from std.math import min, max, abs, clamp, floor
from std.conv import tostring, tonumber
from std.util import select, assert

/// Module: core
import core.gui.core as M

// consts
var gl, key = M.gl, M.key

// widget types
var register_type = M.register_type

// color
var Color = M.Color

// base widgets
var Widget = M::get_type("Widget")

// setters
var gen_setter = M.gen_setter

from core.gui.constants import mod

var floor_to_fontw = func(n) {
    var fw = text_font_get_w()
    return floor(n / fw) * fw
}

var floor_to_fonth = func(n) {
    var fh = text_font_get_h()
    return floor(n / fh) * fh
}

var gen_ed_setter = func(name) {
    var sname = name ~ ",changed"
    return func(self, val) {
        self._needs_calc = true
        self[name] = val
        emit(self, sname, val)
    }
}

var chunksize = 256
var ffi_new, ffi_cast, ffi_copy, ffi_string, ffi_gc = ffi.new, ffi.cast,
ffi.copy, ffi.string, ffi.gc

var ffi_move = func(dest, src, nbytes) {
    capi::raw_move(dest, src, nbytes)
}

if !(try ffi["typeof"]("editline_t")) {
    ffi::cdef(r"""
        typedef struct editline_t {
            char *text;
            int len, maxlen;
            int w, h;
        } editline_t;
    """)
}
var C = ffi.C

var editline_grow = func(self, total, nocopy) {
    if total + 1 <= self.maxlen { return false }
    self.maxlen = (total + chunksize) - total % chunksize
    var newtext = ffi_cast("char*", capi::raw_alloc(self.maxlen))
    if !nocopy {
        ffi_copy(newtext, self.text, self.len + 1)
    }
    capi::raw_free(self.text)
    self.text = newtext
    return true
}

var editline_set = func(self, str) {
    editline_grow(self, str.len(), true)
    ffi_copy(self.text, str)
    self.len = str.len()
    return self
}

var editline_insert = func(self, str, start, count) {
    if !count || count <= 0 { count = str.len() }
    start = clamp(start, 0, self.len)
    editline_grow(self, self.len + count)
    if self.len == 0 { self.text[0] = 0 }
    ffi_move(self.text + start + count, self.text + start,
        self.len - start + 1)
    ffi_copy(self.text + start, str, count)
    self.len += count
    return self
}

var editline_prepend = func(self, str) {
    var slen = str.len()
    editline_grow(self, self.len + slen)
    ffi_move(self.text + slen, self.text, self.len + 1)
    ffi_copy(self.text, str)
    self.len += slen
    return self
}

var editline_append = func(self, str) {
    editline_grow(self, self.len + str.len())
    ffi_copy(self.text + self.len, str)
    self.len += str.len()
    return self
}

var editline_combine_lines = func(self, src) {
    if src.len <= 0 { editline_set(self, "")
    } else { for i, v in src.each() {
        if i != 0 { editline_append(self, "\n") }
        if i == 0 { editline_set(self, v.text, v.len)
        } else { editline_insert(self, v.text, self.len, v.len) }
    } }
    return self
}

var editline_chop = func(self, newlen) {
    if !self.text { return self }
    self.len = clamp(newlen, 0, self.len)
    self.text[self.len] = 0
    return self
}

var editline_del = func(self, start, count) {
    if !self.text { return self }
    if start < 0 {
        count, start = count + start, 0
    }
    if count <= 0 || start >= self.len { return self }
    if start + count > self.len { count = self.len - start - 1 }
    ffi_move(self.text + start, self.text + start + count,
        self.len + 1 - (start + count))
    self.len -= count
    return self
}

var editline_gc = func(self) {
    capi::raw_free(self.text)
    self.text = undef
    self.len, self.maxlen = 0, 0
}

var editline_tostr = func(self) {
    return ffi_string(self.text, self.len)
}

var editline_new = func(x) {
    return editline_set(ffi_gc(ffi_new("editline_t"), editline_gc), x || "")
}

var get_aw = func(self) { return self.w - self.pad_l - self.pad_r }

var init_color = func(col) {
    return col && (typeof col == "number" && Color(col) || col) || Color()
}

var gen_color_setter = func(name) {
    var sname = name ~ ",changed"
    return func(self, val) {
        self[name] = init_color(val)
        emit(self, sname, val)
    }
}

/**
    Implements a text editor widget. It's a basic editor that supports
    scrolling of text and some extra features like key filter and so on.
    It supports copy-paste that interacts with native system clipboard.
    It doesn't have any states.

    The editor implements the same interface and internal members as Scroller,
    allowing scrollbars to be used with it. The functions are not documented
    here because they follow Scroller semantics.

    Note that children of the editor are drawn first - that allows themes to
    define various backgrounds and stuff while keeping the text on top.

    Properties:
        - clip_w, clip_h - see also $Clipper.
        - multiline - if true, the editor will have only one line, clip_h
          will be ignored and the height will be calculated using line text
          bounds, true is default.
        - font - the font (a string) the editor will use.
        - key_filter - a string of characters that can be used in the editor.
        - value - the initial editor value and the fallback value on reset.
        - scale - the text scale, defaults to 1.
        - line_wrap - if true, the text will wrap when it has reached editor
          width.
        - text_color - the text color (0xFFFFFFFF). See $ColorFiller for
          how you can initialize colors.
        - sel_color - the selection color (ARGB: 0xC07B68EE).
        - wrap_color - the wrap symbol color (ARGB: 0xFF3C3C3C).
        - pad_l, pad_r - text left and right padding (both 0 by default).
*/
M.TextEditor = register_type("TextEditor", Widget, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}

        self.clip_w = kwargs.clip_w || 0
        self.clip_h = kwargs.clip_h || 0

        self.virt_w, self.virt_h = 0, 0
        self.text_w, self.text_h = 0, 0

        self.offset_h, self.offset_v = 0, 0
        self.can_scroll = false

        var mline = kwargs.multiline != false && true || false
        self.multiline = mline

        self.key_filter = kwargs.key_filter
        self.value = kwargs.value || ""

        var font = kwargs.font
        self.font  = font
        self.scale = kwargs.scale || 1

        self.text_color = init_color(kwargs.text_color)
        self.sel_color  = init_color(kwargs.sel_color  || 0xC07B68EE)
        self.wrap_color = init_color(kwargs.wrap_color || 0xFF3C3C3C)

        self.pad_l = kwargs.pad_l || 0
        self.pad_r = kwargs.pad_r || 0

        // cursor position - ensured to be valid after a region() or
        // currentline()
        self.cx, self.cy = 0, 0
        // selection mark, mx = -1 if following cursor - avoid direct access,
        // instead use region()
        self.mx, self.my = -1, -1

        self.line_wrap = kwargs.line_wrap || false

        // must always contain at least one line
        self.lines = [ editline_new(kwargs.value) ]

        self._needs_calc = true
        self._needs_offset = false

        return Widget::__ctor(self, kwargs, ...)
    },

    /**
        Given a readable stream, this loads its contents into the editor.
        It doesn't close the stream and it clears the editor beforehand.
    */
    load_stream: func(self, stream) {
        if !stream { return }
        self.edit_clear(false)
        var lines = self.lines
        var mline = self.multiline
        for line in stream.lines() {
            lines.push(editline_new(line))
            if mline { break }
        }
        if lines.empty() { lines.push(editline_new()) }
    },

    /**
        Given a writable stream, this writes the contents of the editor
        into it. It doesn't close the stream.
    */
    save_stream: func(self, stream) {
        if !stream { return }
        for i, line in self.lines.each() {
            stream.write(line.text, "\n")
        }
    },

    /**
        Marks a selection. If the provided argument is true, the selection
        position is set to the cursor position (and any change in cursor
        position effectively extends the selection). Otherwise the
        selection is disabled.
    */
    mark: func(self, enable) {
        self.mx = enable && self.cx || -1
        self.my = self.cy
    },

    /// Selects everything in the editor.
    select_all: func(self) {
        self.cx, self.cy = 0, 0
        self.mx, self.my = 1 / 0, 1 / 0
    },

    /// Returns true if the editor contains nothing, false otherwise.
    is_empty: func(self) {
        var lines = self.lines
        return lines.len() == 1 && lines[0].text[0] == 0
    },

    // constrain results to within buffer - s = start, e = }, return true if
    // a selection range also ensures that cy is always within lines[] and cx
    // is valid
    region: func(self) {
        var sx, sy, ex, ey

        var n = self.lines.len()
        var cx, cy, mx, my = self.cx, self.cy, self.mx, self.my

        if  cy < 0 {
            cy = 0
        } else if cy >= n {
            cy = n - 1
        }
        var len = self.lines[cy].len
        if  cx < 0 {
            cx = 0
        } else if cx > len {
            cx = len
        }
        if mx >= 0 {
            if  my < 0 {
                my = 0
            } else if my >= n {
                my = n - 1
            }
            len = self.lines[my].len
            if  mx > len {
                mx = len
            }
        }
        sx, sy = (mx >= 0) && mx || cx, (mx >= 0) && my || cy
        ex, ey = cx, cy
        if sy > ey {
            sy, ey = ey, sy
            sx, ex = ex, sx
        } else if sy == ey && sx > ex {
            sx, ex = ex, sx
        }

        self.cx, self.cy, self.mx, self.my = cx, cy, mx, my

        return ((sx != ex) || (sy != ey)), sx, sy, ex, ey
    },

    // also ensures that cy is always within lines[] and cx is valid
    current_line: func(self) {
        var n = self.lines.len()
        assert(n != 0)

        if   self.cy <  0 { self.cy = 0
        } else if self.cy >= n { self.cy = n - 1 }

        var len = self.lines[self.cy].len

        if   self.cx < 0   { self.cx = 0
        } else if self.cx > len { self.cx = len }

        return self.lines[self.cy]
    },

    /// Returns all contents of the editor as a string.
    to_string: func(self) {
        return editline_tostr(editline_combine_lines(editline_new(), self.lines))
    },

    /**
        Returns the selected portion of the editor as a string (assuming
        there is one, otherwise it returns undef).
    */
    selection_to_string: func(self) {
        var buf = []
        var sx, sy, ex, ey = select(2, self.region())

        for i in 1 to 1 + ey - sy {
            var y = sy + i - 1
            var line = editline_tostr(self.lines[y])
            var len  = line.len()
            if y == sy { line = line.sub(sx) }
            buf.push(line)
            buf.push("\n")
        }

        if buf.len() > 0 {
            return buf.concat()
        }
    },

    /**
        Removes "count" lines from line number "start".
    */
    remove_lines: func(self, start, count) {
        self._needs_calc = true
        var lines = self.lines
        for i in start + count - 1 to lines.len() - 1 {
            lines[i - count] = lines[i]
        }
        lines.resize(lines.len() - min(lines.len() - start + 1, count))
    },

    /**
        Resets the editor contents - they're set to the "value" property
        (which acts differently on editors and fields - on editors it's just
        an "initial" value, on fields it's the current value, so on fields
        it pretty much cancels out unsaved changes). If "value" is undef,
        do an empty string is used.
    */
    reset_value: func(self) {
        var str = self.value || ""
        var strlines = str.split("\n")
        var lines = self.lines
        var cond = strlines.len() != lines.len()
        if !cond {
            for i, strl in strlines.each() {
                if strl != editline_tostr(lines[i]) {
                    cond = true
                    break
                }
            }
        }
        if cond { self.edit_clear(strlines) }
    },

    /**
        Copies the current selection into system clipboard. Returns the
        copied string or undef if nothing was copied.
    */
    copy: func(self) {
        if !self.region() { return undef }
        self._needs_calc = true
        var str = self.selection_to_string()
        if str {
            clipboard_set_text(str)
            return str
        }
    },

    /**
        Pastes a string from the clipboard into the editor on cursor position.
        Returns the pasted string or undef if nothing was pasted. Deletes the
        current selection if there is one and there is something to paste.
    */
    paste: func(self) {
        if !clipboard_has_text() { return undef }
        self._needs_calc = true
        if self.region() { self.delete_selection() }
        var  str = clipboard_get_text()
        if !str { return undef }
        self.insert(str)
        return str
    },

    /// Deletes the current selection if any, returns true if there was one.
    delete_selection: func(self) {
        var b, sx, sy, ex, ey = self.region()
        if !b {
            self.mark()
            return false
        }

        self._needs_calc = true

        if sy == ey {
            if sx == 0 && ex == self.lines[ey].len {
                self.remove_lines(sy + 1, 1)
            } else { editline_del(self.lines[sy], sx, ex - sx)
            }
        } else {
            if ey > sy + 1 {
                self.remove_lines(sy + 2, ey - (sy + 1))
                ey = sy + 1
            }

            if ex == self.lines[ey].len {
                self.remove_lines(ey + 1, 1)
            } else {
                editline_del(self.lines[ey], 0, ex)
            }

            if sx == 0 {
                self.remove_lines(sy + 1, 1)
            } else {
                editline_del(self.lines[sy], sx, self.lines[sy].len - sx)
            }
        }

        if self.lines.empty() { self.lines = [ editline_new() ] }
        self.mark()
        self.cx, self.cy = sx, sy

        var current = self.current_line()
        if self.cx > current.len && self.cy < self.lines.len() - 1 {
            editline_append(current, editline_tostr(self.lines[self.cy + 1]))
            self.remove_lines(self.cy + 2, 1)
        }

        return true
    },

    /**
        Given a string, this inserts the string into the editor on cursor
        position (and deletes any selection before that if there is one).
    */
    insert: func(self, ch) {
        if ch.len() > 1 {
            for c in ch.gmatch(".") {
                self.insert(c)
            }
            return
        }

        self._needs_calc = true

        self.delete_selection()
        var current = self.current_line()

        if ch == "\n" {
            if self.multiline {
                var newline = editline_new(editline_tostr(current).sub(self.cx))
                editline_chop(current, self.cx)
                self.cy = min(self.lines.len(), self.cy + 1)
                self.lines.insert(self.cy, newline)
            } else {
                editline_chop(current, self.cx)
            }
            self.cx = 0
        } else {
            if self.cx <= current.len {
                editline_insert(current, ch, self.cx, 1)
                self.cx = self.cx + 1
            }
        }
    },

    ///
    bind_h_scrollbar: func(self, sb) {
        if !sb {
            sb = self.h_scrollbar
            if !sb { return undef }
            sb.scroller, self.h_scrollbar = undef, undef
            return sb
        }
        self.h_scrollbar = sb
        sb.scroller = self
    },

    ///
    bind_v_scrollbar: func(self, sb) {
        if !sb {
            sb = self.v_scrollbar
            if !sb { return undef }
            sb.scroller, self.v_scrollbar = undef, undef
            return sb
        }
        self.v_scrollbar = sb
        sb.scroller = self
    },

    ///
    get_h_limit: func(self) { return max(self.virt_w - get_aw(self), 0) },
    ///
    get_v_limit: func(self) { return max(self.virt_h - self.h, 0) },

    ///
    get_h_offset: func(self) {
        return self.offset_h / max(self.virt_w, get_aw(self))
    },

    ///
    get_v_offset: func(self) {
        return self.offset_v / max(self.virt_h, self.h)
    },

    ///
    get_h_scale: func(self) {
        var w = get_aw(self)
        return w / max(self.virt_w, w)
    },
    ///
    get_v_scale: func(self) {
        var h = self.h
        return h / max(self.virt_h, h)
    },

    ///
    set_h_scroll: func(self, hs) {
        self.offset_h = clamp(hs, 0, self.get_h_limit())
        emit(self, "h_scroll,changed", self.get_h_offset())
    },

    ///
    set_v_scroll: func(self, vs) {
        self.offset_v = clamp(vs, 0, self.get_v_limit())
        emit(self, "v_scroll,changed", self.get_v_offset())
    },

    ///
    scroll_h: func(self, hs) { self.set_h_scroll(self.offset_h + hs) },
    ///
    scroll_v: func(self, vs) { self.set_v_scroll(self.offset_v + vs) },

    /// Function: set_clip_w
    set_clip_w: gen_ed_setter("clip_w"),
    /// Function: set_clip_h
    set_clip_h: gen_ed_setter("clip_h"),

    /// Function: set_pad_l
    set_pad_l: gen_ed_setter("pad_l"),
    /// Function: set_pad_r
    set_pad_r: gen_ed_setter("pad_r"),

    /// Function: set_multiline
    set_multiline: gen_ed_setter("multiline"),

    /// Function: set_key_filter
    set_key_filter: gen_setter("key_filter"),

    /**
        Sets the value property, emits value,changed and calls $reset_value.
    */
    set_value: func(self, val) {
        val = tostring(val)
        self.value = val
        emit(self, "value,changed", val)
        self.reset_value()
    },

    /// Function: set_font
    set_font: gen_ed_setter("font"),
    /// Function: set_line_wrap
    set_line_wrap: gen_ed_setter("line_wrap"),

    clear: func(self) {
        self.set_focused(false)
        self.bind_h_scrollbar()
        self.bind_v_scrollbar()
        return Widget::clear(self)
    },

    edit_clear: func(self, init) {
        self._needs_calc = true
        self.cx, self.cy =  0,  0
        self.mx, self.my = -1, -1
        self.offset_h, self.offset_v = 0, 0
        self.mark()
        if init == false {
            self.lines = []
        } else {
            init = init || ""
            var lines = []
            if typeof init != "array" {
                init = init.split("\n")
            }
            for i, v in init.each() { lines.push(editline_new(v)) }
            if lines.empty() { lines.push(editline_new()) }
            self.lines = lines
        }
    },

    movement_mark: func(self) {
        self._needs_offset = true
        if input_is_modifier_pressed(mod.SHIFT) {
            if !self.region() { self.mark(true) }
        } else {
            self.mark(false)
        }
    },

    key: func(self, code, isdown) {
        if Widget::key(self, code, isdown) { return true }
        if !self.is_focused() { return false }

        if code == key.ESCAPE {
            if isdown { self.set_focused(false) }
            return true
        } else if code == key.RETURN {
            if !self.multiline {
                if isdown { self.commit() }
                return true
            }
        } else if code == key.KP_ENTER {
            if isdown { self.commit() }
            return true
        }
        if isdown { self.key_edit(code) }
        return true
    },

    key_hover: func(self, code, isdown) {
        if !self.multiline {
            return Widget::key_hover(self, code, isdown)
        }
        var hoverkeys = {
            (key.MOUSEWHEELUP  ): true,
            (key.MOUSEWHEELDOWN): true,
            (key.PAGEUP        ): true,
            (key.PAGEDOWN      ): true,
            (key.HOME          ): true
        }
        if hoverkeys[code] {
            if isdown { self.key_edit(code) }
            return true
        }
        return Widget::key_hover(self, code, isdown)
    },

    key_edit: func(self, code) {
        var mod_keys = (ffi.os == "OSX") && mod.GUI || mod.CTRL
        if code == key.UP {
            self.movement_mark()
            if self.line_wrap {
                var str = editline_tostr(self.current_line())
                text_font_push()
                text_font_set(self.font)
                var pw = floor(get_aw(self) / self.draw_scale())
                var x, y = text_get_position(str, self.cx + 1, pw)
                if y > 0 {
                    self.cx = text_is_visible(str, x, y - text_font_get_h(),
                        pw)
                    self._needs_offset = true
                    text_font_pop()
                    return
                }
                text_font_pop()
            }
            self.cy = self.cy - 1
            self._needs_offset = true
        } else if code == key.DOWN {
            self.movement_mark()
            if self.line_wrap {
                var str = editline_tostr(self.current_line())
                text_font_push()
                text_font_set(self.font)
                var pw = floor(get_aw(self) / self.draw_scale())
                var x, y = text_get_position(str, self.cx, pw)
                var width, height = text_get_bounds(str, pw)
                y = y + text_font_get_h()
                if y < height {
                    self.cx = text_is_visible(str, x, y, pw)
                    self._needs_offset = true
                    text_font_pop()
                    return
                }
                text_font_pop()
            }
            self.cy = self.cy + 1
            self._needs_offset = true
        } else if code == key.MOUSEWHEELUP || code == key.MOUSEWHEELDOWN {
            if self.can_scroll {
                var sb = self.v_scrollbar
                var fac = 6 * text_font_get_h() * self.draw_scale()
                self.scroll_v((code == key.MOUSEWHEELUP && -fac || fac)
                    * (sb && sb.arrow_speed || 0.5))
            }
        } else if code == key.PAGEUP {
            self.movement_mark()
            if input_is_modifier_pressed(mod_keys) {
                self.cy = 0
            } else {
                self.cy = self.cy - floor(self.h / (self.draw_scale()
                    * text_font_get_h()))
            }
            self._needs_offset = true
        } else if code == key.PAGEDOWN {
            self.movement_mark()
            if input_is_modifier_pressed(mod_keys) {
                self.cy = 1 / 0
            } else {
                self.cy = self.cy + floor(self.h / (self.draw_scale()
                    * text_font_get_h()))
            }
            self._needs_offset = true
        } else if code == key.HOME {
            self.movement_mark()
            self.cx = 0
            if input_is_modifier_pressed(mod_keys) {
                self.cy = 0
            }
            self._needs_offset = true
        } else if code == key.END {
            self.movement_mark()
            self.cx = 1 / 0
            if input_is_modifier_pressed(mod_keys) {
                self.cy = 1 / 0
            }
            self._needs_offset = true
        } else if code == key.LEFT {
            self.movement_mark()
            if     self.cx > 0 { self.cx = self.cx - 1
            } else if self.cy > 0 {
                self.cx = 1 / 0
                self.cy = self.cy - 1
            }
            self._needs_offset = true
        } else if code == key.RIGHT {
            self.movement_mark()
            if self.cx < self.lines[self.cy].len {
                self.cx = self.cx + 1
            } else if self.cy < self.lines.len() - 1 {
                self.cx = 0
                self.cy = self.cy + 1
            }
            self._needs_offset = true
        } else if code == key.DELETE {
            if !self.delete_selection() {
                self._needs_calc = true
                var current = self.current_line()
                if self.cx < current.len {
                    editline_del(current, self.cx, 1)
                } else if self.cy < self.lines.len() - 1 {
                    // combine with next line
                    editline_append(current, editline_tostr(self.lines[self.cy + 1]))
                    self.remove_lines(self.cy + 2, 1)
                }
            }
            self._needs_offset = true
        } else if code == key.BACKSPACE {
            if !self.delete_selection() {
                self._needs_calc = true
                var current = self.current_line()
                if self.cx > 0 {
                    editline_del(current, self.cx - 1, 1)
                    self.cx = self.cx - 1
                } else if self.cy > 0 {
                    // combine with previous line
                    self.cx = self.lines[self.cy - 1].len
                    editline_append(self.lines[self.cy - 1], editline_tostr(current))
                    self.remove_lines(self.cy, 1)
                    self.cy = self.cy - 1
                }
            }
            self._needs_offset = true
        } else if code == key.RETURN {
            // maintain indentation
            self._needs_calc = true
            var str = editline_tostr(self.current_line())
            self.insert("\n")
            for c in str.gmatch(".") { if c == " " || c == "\t" {
                self.insert(c) } else { break
            } }
            self._needs_offset = true
        } else if code == key.TAB {
            var b, sx, sy, ex, ey = self.region()
            if b {
                self._needs_calc = true
                for i in sy to ey {
                    if input_is_modifier_pressed(mod.SHIFT) {
                        var rem = 0
                        for j in 1 to min(4, self.lines[i].len) {
                            if editline_tostr(self.lines[i]).sub(j - 1, j) == " "
                            {
                                rem = rem + 1
                            } else {
                                if editline_tostr(self.lines[i]).sub(j - 1, j)
                                == "\t" && j == 0 {
                                    rem = rem + 1
                                }
                                break
                            }
                        }
                        editline_del(self.lines[i], 0, rem)
                        if i == self.my { self.mx = self.mx
                            - (rem > self.mx && self.mx || rem) }
                        if i == self.cy { self.cx = self.cx -  rem }
                    } else {
                        editline_prepend(self.lines[i], "\t")
                        if i == self.my { self.mx = self.mx + 1 }
                        if i == self.cy { self.cx = self.cx + 1 }
                    }
                }
            } else if input_is_modifier_pressed(mod.SHIFT) {
                if self.cx > 0 {
                    self._needs_calc = true
                    var cy = self.cy
                    var lines = self.lines
                    if editline_tostr(lines[cy]).sub(0, 1) == "\t" {
                        editline_del(lines[cy], 0, 1)
                        self.cx = self.cx - 1
                    } else {
                        for j in 1 to min(4, lines[cy].len) {
                            if editline_tostr(lines[cy]).sub(0, 1) == " " {
                                editline_del(lines[cy], 0, 1)
                                self.cx = self.cx - 1
                            }
                        }
                    }
                }
            } else {
                self.insert("\t")
            }
            self._needs_offset = true
        } else if code == key.A {
            if !input_is_modifier_pressed(mod_keys) {
                self._needs_offset = true
                return
            }
            self.select_all()
            self._needs_offset = true
        } else if code == key.C || code == key.X {
            if !input_is_modifier_pressed(mod_keys)
            || !self.region() {
                self._needs_offset = true
                return
            }
            self.copy()
            if code == key.X { self.delete_selection() }
            self._needs_offset = true
        } else if code == key.V {
            if !input_is_modifier_pressed(mod_keys) {
                self._needs_offset = true
                return
            }
            self.paste()
            self._needs_offset = true
        } else {
            self._needs_offset = true
        }
    },

    hit: func(self, hitx, hity, dragged) {
        var k = self.draw_scale()
        var pw, ph = floor(get_aw(self) / k), floor(self.h / k)
        var max_width = self.line_wrap && pw || -1
        text_font_push()
        text_font_set(self.font)
        var fd = self.get_first_drawable_line()
        if fd {
            var h = 0
            hitx, hity = (hitx + self.offset_h) / k, hity / k
            for i in fd - 1 to self.lines.len() {
                if h > ph { break }
                var linestr = editline_tostr(self.lines[i])
                var width, height = self.lines[i].w, self.lines[i].h
                if hity >= h && hity <= h + height {
                    var x = text_is_visible(linestr, hitx, hity - h,
                        max_width)
                    if dragged {
                        self.mx, self.my = x, i
                    } else {
                        self.cx, self.cy = x, i
                    }
                    break
                }
                h = h + height
            }
        }
        text_font_pop()
    },

    target: func(self, cx, cy) {
        return Widget::target(self, cx, cy) || self
    },

    hover: func(self, cx, cy) {
        var oh, ov, vw, vh = self.offset_h, self.offset_v,
            self.virt_w, self.virt_h
        self.can_scroll = ((cx + oh) < vw) && ((cy + ov) < vh)
        return self.target(cx, cy) && self
    },

    click: func(self, cx, cy) {
        var oh, ov, vw, vh = self.offset_h, self.offset_v,
            self.virt_w, self.virt_h
        self.can_scroll = ((cx + oh) < vw) && ((cy + ov) < vh)
        return self.target(cx, cy) && self
    },

    commit: func(self) {
        self.set_focused(false)
    },

    holding: func(self, cx, cy, code) {
        if code == key.MOUSELEFT {
            var w, h, hs, vs = self.w, self.h, 0, 0
            if     cy > h { vs = cy - h
            } else if cy < 0 { vs = cy }
            if     cx > w { hs = cx - w
            } else if cx < 0 { hs = cx }
            cx, cy = clamp(cx, 0, w), clamp(cy, 0, h)
            if vs != 0 { self.scroll_v(vs) }
            if hs != 0 { self.scroll_h(hs) }
            self.hit(cx, cy, max(abs(cx - self._oh), abs(cy - self._ov))
                > (text_font_get_h() / 8 * self.draw_scale()))
        }
        Widget::holding(self, cx, cy, code)
    },

    set_focused: func(self, foc) {
        Widget::set_focused(self, foc)
        var ati = foc && self.allow_text_input() || false
        input_textinput(ati, 1 << 1) // TI_GUI
        input_keyrepeat(ati, 1 << 1) // KR_GUI
    },

    clicked: func(self, cx, cy, code) {
        self.set_focused(true)
        self.mark()
        self._oh, self._ov = cx, cy

        return Widget::clicked(self, cx, cy, code)
    },

    allow_text_input: func(self) { return true },

    text_input: func(self, str) {
        if Widget::text_input(self, str) { return true }
        if !self.is_focused() || !self.allow_text_input() {
            return false
        }
        var filter = self.key_filter
        if !filter {
            self.insert(str)
        } else {
            var buf = []
            for ch in str.gmatch(".") {
                if filter.find(ch) { buf.push(ch) }
            }
            self.insert(buf.concat())
        }
        return true
    },

    draw_scale: func(self) {
        var scale = self.scale
        return (abs(scale) * self.get_root().get_text_scale(scale < 0))
            / text_font_get_h()
    },

    calc_dimensions: func(self, maxw) {
        if !self._needs_calc {
            return self.text_w, self.text_h
        }
        self._needs_calc = false
        var w, h = 0, 0
        var ov = 0
        var k = self.draw_scale()
        maxw -= (self.pad_l + self.pad_r) / k
        for i, line in self.lines.each() {
            var tw, th = text_get_bounds(editline_tostr(line), maxw)
            line.w, line.h = tw, th
            w, h = max(w, tw), h + th
        }
        w, h = w * k, h * k
        self.text_w, self.text_h = w, h
        return w, h
    },

    get_first_drawable_line: func(self) {
        var ov = self.offset_v / self.draw_scale()
        for i, line in self.lines.each() {
            var tw, th = line.w, line.h
            ov -= th
            if ov < 0 { return i + 1 }
        }
    },

    get_last_drawable_line: func(self) {
        var ov = (self.offset_v + self.h) / self.draw_scale()
        for i, line in self.lines.each() {
            var tw, th = line.w, line.h
            ov -= th
            if ov <= 0 { return i + 1 }
        }
    },

    fix_h_offset: func(self, k, maxw, del) {
        var fontw = text_font_get_w() * k
        var x, y = text_get_position(editline_tostr(self.lines[self.cy]),
            self.cx, maxw)

        x *= k
        var w, oh = get_aw(self), self.offset_h + self.pad_l
        if (x + fontw) > w + (del && 0 || oh) {
           self.offset_h = x + fontw - w
        } else if x < oh {
            self.offset_h = x
        } else if (x + fontw) <= w && oh >= fontw {
            self.offset_h = 0
        }
    },

    fix_v_offset: func(self, k) {
        var lines = self.lines

        var cy = self.cy
        var oov = self.offset_v

        var yoff = 0
        for i in 0 to cy {
            var tw, th = lines[i].w, lines[i].h
            yoff += th
        }

        var h = self.h
        if yoff <= (oov / k) {
            self.offset_v += yoff * k - oov - text_font_get_h() * k
        } else if yoff > ((oov + h) / k) {
            self.offset_v += yoff * k - (oov + h)
        }
    },

    layout: func(self) {
        Widget::layout(self)

        self._prev_tw = self.text_w

        text_font_push()
        text_font_set(self.font)
        if !self.is_focused() {
            self.reset_value()
        }

        var lw, ml = self.line_wrap, self.multiline
        var k = self.draw_scale()
        var pw, ph = self.clip_w / k
        if ml {
            ph = self.clip_h / k
        } else {
            var w, h = text_get_bounds(editline_tostr(self.lines[0]),
                lw && pw || -1)
            ph = h
        }

        var maxw = lw && pw || -1
        var tw, th = self.calc_dimensions(maxw)

        self.virt_w = max(self.w, tw)
        self.virt_h = max(self.h, th)

        self.w = max(self.w, pw * k)
        self.h = max(self.h, ph * k)

        text_font_pop()
    },

    adjust_layout: func(self, px, py, pw, ph) {
        Widget::adjust_layout(self, px, py, pw, ph)
        if self._needs_offset {
            self.region()
            var k = self.draw_scale()
            var maxw = self.line_wrap && floor(get_aw(self) / k) || -1
            self.fix_h_offset(k, maxw, self._prev_tw > self.text_w)
            self.fix_v_offset(k)
            self._needs_offset = false
        }
    },

    draw_selection: func(self, first_drawable, x, x2, y) {
        var selection, sx, sy, ex, ey = self.region()
        if !selection { return }
        var k = self.draw_scale()
        var pw, ph = floor(get_aw(self) / k), floor(self.h / k)
        var max_width = self.line_wrap && pw || -1
        // convert from cursor coords into pixel coords
        var psx, psy = text_get_position(editline_tostr(self.lines[sy]), sx,
            max_width)
        var pex, pey = text_get_position(editline_tostr(self.lines[ey]), ex,
            max_width)
        var maxy = self.lines.len()
        var h = 0
        var sc = self.sel_color
        for i in first_drawable to maxy {
            if h > ph {
                maxy = i
                break
            }
            var width, height = text_get_bounds(editline_tostr(self.lines[i - 1]),
                max_width)
            if i == sy + 1 {
                psy = psy + h
            }
            if i == ey + 1 {
                pey = pey + h
                break
            }
            h = h + height
        }
        maxy = maxy - 1
        if ey >= first_drawable - 1 && sy <= maxy {
            var fonth = text_font_get_h()
            // crop top/bottom within window
            if  sy < first_drawable - 1 {
                sy = first_drawable - 1
                psy = 0
                psx = 0
            }
            if  ey > maxy {
                ey = maxy
                pey = ph - fonth
                pex = pw
            }

            shader_hudnotexture_set()
            gle_color4ub(sc.r, sc.g, sc.b, sc.a)
            gle_defvertexf(2)
            gle_begin(gl.QUADS)
            if psy == pey {
                // one selection line - arbitrary bounds
                gle_attrib2f(x + psx, psy)
                gle_attrib2f(x + pex, psy)
                gle_attrib2f(x + pex, pey + fonth)
                gle_attrib2f(x + psx, pey + fonth)
            } else {
                // multiple selection lines
                // first line - always ends in the end of the visible area
                gle_attrib2f(x  + psx, psy)
                gle_attrib2f(x  + psx, psy + fonth)
                gle_attrib2f(x2 + pw,  psy + fonth)
                gle_attrib2f(x2 + pw,  psy)
                // between first and last selected line
                // a quad that fills the whole space
                if (pey - psy) > fonth {
                    gle_attrib2f(x2,      psy + fonth)
                    gle_attrib2f(x2 + pw, psy + fonth)
                    gle_attrib2f(x2 + pw, pey)
                    gle_attrib2f(x2,      pey)
                }
                // last line - starts in the beginning of the visible area
                gle_attrib2f(x2,      pey)
                gle_attrib2f(x2,      pey + fonth)
                gle_attrib2f(x + pex, pey + fonth)
                gle_attrib2f(x + pex, pey)
            }
            gle_end()
        }
    },

    draw_line_wrap: func(self, h, height) {
        if !self.line_wrap { return }
        var fonth = text_font_get_h()
        shader_hudnotexture_set()
        var wc = self.wrap_color
        gle_color4ub(wc.r, wc.g, wc.b, wc.a)
        gle_defvertexf(2)
        gle_begin(gl.LINE_STRIP)
        gle_attrib2f(0, h + fonth)
        gle_attrib2f(0, h + height)
        gle_end()
    },

    draw: func(self, sx, sy) {
        Widget::draw(self, sx, sy)

        self.change_draw(M.changes.SHADER | M.changes.COLOR)

        text_font_push()
        text_font_set(self.font)

        var cw, ch = get_aw(self), self.h
        var fontw  = text_font_get_w()
        var clip = (cw != 0 && (self.virt_w + fontw) > cw)
                || (ch != 0 &&  self.virt_h          > ch)

        if clip { self.get_root().clip_push(sx + self.pad_l, sy, cw, ch) }

        hudmatrix_push()

        hudmatrix_translate(sx, sy, 0)
        var k = self.draw_scale()
        hudmatrix_scale(k, k, 1)
        hudmatrix_flush()

        var hit = self.is_focused()

        var pw, ph = floor(get_aw(self) / k), floor(self.h / k)
        var max_width = self.line_wrap && pw || -1

        var fd = self.get_first_drawable_line()
        if fd {
            var xoff = self.pad_l / k
            var txof = xoff - self.offset_h / k

            self.draw_selection(fd, txof, xoff)

            var h = 0
            var fonth = text_font_get_h()
            var tc = self.text_color
            for i in fd to self.lines.len() {
                var line = editline_tostr(self.lines[i - 1])
                var width, height = text_get_bounds(line,
                    max_width)
                if h >= ph { break }
                text_draw(line, txof, h, tc.r, tc.g, tc.b, tc.a,
                    (hit && (self.cy == i - 1)) && self.cx || -1, max_width)

                if height > fonth { self.draw_line_wrap(h, height) }
                h = h + height
            }
        }

        hudmatrix_pop()
        if clip { self.get_root().clip_pop() }

        text_font_pop()
    }
})
var TextEditor = M.TextEditor

/**
    Represents a field, a specialization of $TextEditor. It has the same
    properties. The "value" property changed meaning - now it stores the
    current value - there is no fallback for fields (it still is the default
    value though).

    Fields are also by default not multiline. You can still explicitly
    override this in kwargs or by setting the property.
*/
M.Field = register_type("Field", TextEditor, {
    __ctor: func(self, kwargs, ...) {
        kwargs = kwargs || {}
        kwargs.multiline = kwargs.multiline || false
        TextEditor::__ctor(self, kwargs, ...)
        if kwargs.variable {
            self.setup_from_var(kwargs.variable)
        }
    },

    commit: func(self) {
        TextEditor::commit(self)
        var val = editline_tostr(self.lines[0])
        self.value = val
        // trigger changed signal
        emit(self, "value,changed", val)
    },

    /// Set up a field from a Cubescript variable of the given name.
    setup_from_var: func(self, varn) {
        var curv = cs::var_get(varn)
        if !curv { return false }
        self.set_value(curv)
        var confunc = ((typeof curv) == "string") ? tostring : tonumber
        var fromhere = false
        var cid = signal::connect(cs, varn ~ ",changed", func(cs, v) {
            if !fromhere { self.set_value(v) }
            fromhere = false
        })
        signal::connect(self, "destroy", func() {
            signal::disconnect(cs, varn ~ ",changed", cid)
        })
        signal::connect(self, "value,changed", func(self, v) {
            fromhere = true
            cs::var_set(varn, confunc(v))
        })
        return true
    }
})

/**
    Derived from $Field. Represents a keyfield - it catches keypresses and
    inserts key names. Useful when creating an e.g. keybinding GUI.
*/
M.KeyField = register_type("KeyField", M.Field, {
    allow_text_input: func(self) { return false },

    key_insert: func(self, code) {
        var keyname = input_get_key_name(code)
        if keyname {
            if !self.is_empty() { self.insert(" ") }
            self.insert(keyname)
        }
    },

    /// Overloaded. Commits on the escape key, inserts the name otherwise.
    key_raw: func(self, code, isdown) {
        if Widget::key_raw(self, code, isdown) { return true }
        if !self.is_focused() || !isdown { return false }
        if code == key.ESCAPE { self.commit()
        } else { self.key_insert(code) }
        return true
    }
})
