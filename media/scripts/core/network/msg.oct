/**<
    Provides an API to the OctaForge message system.

    Author:
        q66 <daniel@octaforge.org>

    License:
        See COPYING.txt.
*/

/// Module: msg
var M = {}

from std.util import assert
from std.conv import tonumber
from std.string import char
from core.externals import set as setext

from core.octascript.messagepack import unpack as mp_unpack

import capi

var message_types = {}
// scripting messages start after the first byte
var current_mid = 256

/**
    A constant (value -1) used when sending messages. Specifying this constant
    means that the message will be sent to all clients.
*/
M.ALL_CLIENTS = -1

/**
    Registers a message receiver and returns its ID.
*/
M.register = func(receiver) {
    message_types[current_mid] = receiver
    current_mid += 1
    return current_mid - 1
}

import std.ffi
import capi

M.buf_get_int = func(self) {
    return tonumber(capi::ucharbuf_getint(self))
}

M.buf_get_uint = func(self) {
    return tonumber(capi::ucharbuf_getuint(self))
}

M.buf_get_float = func(self) {
    return tonumber(capi::ucharbuf_getfloat(self))
}

M.buf_get_string = func(self, n) {
    n = n || 5000 // our MAXTRANS value
    var buf = ffi::new("char[?]", n)
    capi::ucharbuf_getstring(self, buf, n)
    return ffi::string(buf)
}

var get_byte = func(c) {
    return tonumber(capi::ucharbuf_getuchar(c.p))
}

var bfuncs = {
    1: get_byte,
    2: func(c) { return get_byte(c), get_byte(c) },
    4: func(c) { return get_byte(c), get_byte(c), get_byte(c), get_byte(c) },
    8: func(c) { return get_byte(c), get_byte(c), get_byte(c), get_byte(c),
                        get_byte(c), get_byte(c), get_byte(c), get_byte(c)
    }
}

var msg_get_bytes = func(c, nb) {
    var bf = bfuncs[nb]
    if !bf { raise "bad number of bytes" }
    return bf(c)
}

var msg_get_string = func(c, n) {
    var rarr = []
    for i in 1 to n {
        rarr.push(char(get_byte(c)))
    }
    return rarr.concat()
}

var cursor_msg = func(p) {
    return { p: p,
        get_bytes: msg_get_bytes,
        get_string: msg_get_string
    }
}

M.buf_get_msgpack = func(self) {
    return mp_unpack(cursor_msg(self))
}

var ubuft = ffi["typeof"]("ucharbuf &")

setext("message_receive", func(tp, receiver, sender, p) {
    tp = tonumber(tp)
    var recv = message_types[tp]
    if  recv == undef {
        return false
    }
    recv(tp, tonumber(receiver), tonumber(sender), ffi::cast(ubuft, p))
    return true
})

M.is_local = @[server,func() { return true },func() {
    return capi::isconnected(false, true) && !capi::isconnected(false, false)
}]
var is_loc = M.is_local

M.is_server = @[server,func() { return true },func() {
    return capi::islistenserver() || is_loc()
}]

M.is_server_only = @[server,func() { return true },func() {
    return capi::islistenserver() && !capi::isconnected(false, true)
}]

return M
