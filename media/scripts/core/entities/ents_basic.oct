/**<
    A basic entity set (extends over the base entity).

    Author:
        q66 <daniel@octaforge.org>

    License:
        See COPYING.txt.
*/

import std.ffi
import capi
import core.logger as logging
var log = logging.log
var DEBUG = logging.DEBUG
var ERROR = logging.ERROR

import core.engine.camera
import core.engine.sound
import core.engine.model
import core.events.frame
import core.events.actions
import core.events.signal
import core.entities.svars
import core.entities.ents
import core.engine.cubescript as cs
import core.network.msg

from std.conv import hex_to_rgb as hextorgb

var var_get = cs.var_get

from core.externals import set as set_external

var Entity = ents.Entity

from std.conv import tonumber
from std.math import abs, min, max, clamp

var connect, emit = signal.connect, signal.emit

from std.util import assert

var set_attachments_dyn, set_attachments_ext in capi

// physics state flags
var MASK_MAT = 0x3
var FLAG_WATER = 1 << 0
var FLAG_LAVA  = 2 << 0
var MASK_LIQUID = 0xC
var FLAG_ABOVELIQUID = 1 << 2
var FLAG_BELOWLIQUID = 2 << 2
var MASK_GROUND = 0x30
var FLAG_ABOVEGROUND = 1 << 4
var FLAG_BELOWGROUND = 2 << 4

var animctl = model.anim_control
var anims = model.anims

var anim_dirs, anim_jump, anim_run
@[!server] {
    anim_dirs = [
        anims.run_SE, anims.run_S, anims.run_SW,
        anims.run_E,  0,           anims.run_W,
        anims.run_NE, anims.run_N, anims.run_NW
    ]

    anim_jump = {
        (anims.jump_N): true, (anims.jump_NE): true, (anims.jump_NW): true,
        (anims.jump_S): true, (anims.jump_SE): true, (anims.jump_SW): true,
        (anims.jump_E): true, (anims.jump_W ): true
    }

    anim_run = {
        (anims.run_N): true, (anims.run_NE): true, (anims.run_NW): true,
        (anims.run_S): true, (anims.run_SE): true, (anims.run_SW): true,
        (anims.run_E): true, (anims.run_W ): true
    }
}

var mrender = @[!server,model.render]

/// Module: ents
var M = ents
var get_by_centity = M.get_by_centity

/**
    Represents the base prototype for any character (NPC, player etc.). Players
    use the $Player entity prototype that inherits from this one.
    Inherited property model_name defaults to "player".

    This entity prototype defines several more properties that do not belong to
    any state variable. These mostly correspond to client_state == {{$State}}.*.
    More will be defined later as needed.

    Non-svar properties:
        - ping - the client ping.
        - plag - the client plag.
        - editing - client_state == EDITING.
        - lagged - client_state == LAGGED.

    Properties:
        - animation [{{$svars.Integer}}] - the entity's current animation.
        - start_time [{{$svars.StateInteger}}] - an internal property used for
          animation timing.
        - model_name [{{$svars.StateString}}] - name of the model associated
          with this entity.
        - attachments [{{$svars.StateArray}}] - an array of model attachments.
          Those are strings in format "tagname,attachmentname".
        - character_name [{{$svars.StateString}}] - name of the character.
        - facing_speed [{{$svars.StateInteger}}] - how fast can the character
          change facing (yaw/pitch) in degrees per second. Defaults to 120.
        - movement_speed [{{$svars.StateFloat}}] - how fast the character can
          move. Defaults to 50.
        - yaw [{{$svars.StateFloat}}] - the current character yaw in degrees.
        - pitch [{{$svars.StateFloat}}] - the current character pitch in
          degrees.
        - roll [{{$svars.StateFloat}}] - the current character roll in
          degrees.
        - move [{{$svars.StateInteger}}] - -1 when moving backwards, 0 when
          not moving, 1 when forward.
        - strafe [{{$svars.StateInteger}}] - -1 when strafing left, 0 when not
          strafing, 1 when right.
        - yawing [{{$svars.StateInteger}}] - -1 when turning left, 1 when
          right, 0 when not at all.
        - pitching [{{$svars.StateInteger}}] - -1 when looking down, 1 when
          up, 0 when not.
        - crouching [{{$svars.StateInteger}}] - -1 when crouching down, 1
          when up, 0 when not.
        - jumping [{{$svars.StateBoolean}}] - true when the character has
          jumped, false otherwise.
        - position [{{$svars.StateVec3}}] - the current position. Defaults to
          { 512, 512, 550 }.
        - velocity [{{$svars.StateVec3}}] - the current velocity.
        - falling [{{$svars.StateVec3}}] - the character's gravity falling.
        - radius [{{$svars.StateFloat}}] - the character's bounding box
          radius. Defaults to 4.1.
        - above_eye [{{$svars.StateFloat}}] - the height of the character
          above its eyes. Defaults to 2.0.
        - eye_height [{{$svars.StateFloat}}] - the distance from the ground to
          the eye position. Defaults to 18.0.
        - max_height [{{$svars.StateFloat}}] - the maximum distance from the
          ground to the eye position. Defaults to 18.0. Used when crouching.
        - crouch_height [{{$svars.StateFloat}}] - the fraction of max_height
          to use when crouched, defaults to 0.75.
        - crouch_speed [{{$svars.StateFloat}}] - the fraction of regular
          movement speed to use while crouching, defaults to 0.4.
        - crouch_time [{{$svars.StateInteger}}] - the time in milliseconds
          spent to crouch, adjust to change the speed.
        - jump_velocity [{{$svars.StateFloat}}] - the vertical velocity to
          apply when jumping, defaults to 125.
        - gravity [{{$svars.StateFloat}}] - a custom character gravity to
          override the global defaults. By default it's -1, which means the
          character will use the global gravity.
        - blocked [{{$svars.StateBoolean}}] - true when the character is
          currently blocked from moving. Floor is not considered an obstacle.
        - can_move [{{$svars.StateBoolean}}] - when false, the character can't
          move. Defaults to true.
        - client_state [{{$svars.StateInteger}}] - see $State.
        - physical_state [{{$svars.StateInteger}}] - see $PhysicalState.
        - in_liquid [{{$svars.StateInteger}}] - either 0 (in the air) or the
          liquid material id (water, lava).
        - time_in_air [{{$svars.StateInteger}}] - time in milliseconds spent
          in the air (TODO: unsigned).
*/
M.Character = Entity.clone({
    name: "Character",

    __storage: "dynamic",

    // so that it isn't nonsauer
    sauer_type: -1,

    /**
        Defines the "client states". 0 is ALIVE, 1 is DEAD, 2 is SPAWNING,
        3 is LAGGED, 4 is EDITING, 5 is SPECTATOR.
    */
    State: enum {
        ALIVE: 0, DEAD: 1, SPAWNING: 2, LAGGED: 3, EDITING: 4, SPECTATOR: 5
    },

    /**
        Defines the "physical states". 0 is FLOATING, 1 is FALLING,
        2 is SLIDING, 3 is SLOPING, 4 is ON_FLOOR, 5 is STEPPING_UP,
        6 is STEPPING_DOWN, 7 is BOUNCING.
    */
    PhysicalState: enum {
        FLOATING: 0, FALLING: 1, SLIDING: 2, SLOPING: 3, ON_FLOOR: 4,
        STEPPING_UP: 5, STEPPING_DOWN: 6, BOUNCING: 7
    },

    __properties: {
        animation: svars::StateInteger({
            setter: @[!server,capi.set_animation_dyn], client_set: true,
            client_cb: true
        }),
        start_time : svars::StateInteger({
            getter: @[!server,capi.get_start_time_dyn], client_cb: true
        }),
        model_name : svars::StateString(),
        attachments: svars::StateArray({
            setter: @[!server,func(self, val) {
                var arr = ffi::new("const char *[?]", val.len() + 1)
                for i, v in val.each() { arr[i] = v }
                set_attachments_dyn(self, arr)
            }], client_cb: true
        }),

        character_name: svars::StateString(),
        facing_speed  : svars::StateInteger(),

        movement_speed: svars::StateFloat({
            getter: @[!server,capi.get_maxspeed],
            setter: @[!server,capi.set_maxspeed],
            client_cb: true
        }),
        yaw: svars::StateFloat({
            getter: @[!server,capi.get_yaw],
            setter: @[!server,capi.set_yaw],
            custom_sync: true, client_cb: true
        }),
        pitch: svars::StateFloat({
            getter: @[!server,capi.get_pitch],
            setter: @[!server,capi.set_pitch],
            custom_sync: true, client_cb: true
        }),
        roll: svars::StateFloat({
            getter: @[!server,capi.get_roll],
            setter: @[!server,capi.set_roll],
            custom_sync: true, client_cb: true
        }),
        move: svars::StateInteger({
            getter: @[!server,capi.get_move],
            setter: @[!server,capi.set_move],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        strafe: svars::StateInteger({
            getter: @[!server,capi.get_strafe],
            setter: @[!server,capi.set_strafe],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        yawing: svars::StateInteger({
            getter: @[!server,capi.get_yawing],
            setter: @[!server,capi.set_yawing],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        pitching: svars::StateInteger({
            getter: @[!server,capi.get_pitching],
            setter: @[!server,capi.set_pitching],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        crouching: svars::StateInteger({
            getter: @[!server,capi.get_crouching],
            setter: @[!server,capi.set_crouching],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        jumping: svars::StateBoolean({
            getter: @[!server,capi.get_jumping],
            setter: @[!server,capi.set_jumping],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        position: svars::StateVec3({
            getter: @[!server,capi.get_dynent_position],
            setter: @[!server,capi.set_dynent_position],
            custom_sync: true, client_cb: true
        }),
        velocity: svars::StateVec3({
            getter: @[!server,capi.get_dynent_velocity],
            setter: @[!server,capi.set_dynent_velocity],
            custom_sync: true, client_cb: true
        }),
        falling: svars::StateVec3({
            getter: @[!server,capi.get_dynent_falling],
            setter: @[!server,capi.set_dynent_falling],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        radius: svars::StateFloat({
            getter: @[!server,capi.get_radius],
            setter: @[!server,capi.set_radius],
            client_cb: true
        }),
        above_eye: svars::StateFloat({
            getter: @[!server,capi.get_aboveeye],
            setter: @[!server,capi.set_aboveeye],
            client_cb: true
        }),
        eye_height: svars::StateFloat({
            getter: @[!server,capi.get_eyeheight],
            setter: @[!server,capi.set_eyeheight],
            client_cb: true
        }),
        max_height: svars::StateFloat({
            getter: @[!server,capi.get_maxheight],
            setter: @[!server,capi.set_maxheight],
            client_cb: true
        }),
        crouch_height: svars::StateFloat({
            getter: @[!server,capi.get_crouchheight],
            setter: @[!server,capi.set_crouchheight],
            client_cb: true
        }),
        crouch_speed: svars::StateFloat({
            getter: @[!server,capi.get_crouchspeed],
            setter: @[!server,capi.set_crouchspeed],
            client_cb: true
        }),
        crouch_time: svars::StateInteger({
            getter: @[!server,capi.get_crouchtime],
            setter: @[!server,capi.set_crouchtime],
            client_cb: true
        }),
        jump_velocity: svars::StateFloat({
            getter: @[!server,capi.get_jumpvel],
            setter: @[!server,capi.set_jumpvel],
            client_cb: true
        }),
        gravity: svars::StateFloat({
            getter: @[!server,capi.get_gravity],
            setter: @[!server,capi.set_gravity],
            client_cb: true
        }),
        blocked: svars::StateBoolean({
            getter: @[!server,capi.get_blocked],
            setter: @[!server,capi.set_blocked],
            gui_name: false, client_cb: true
        }),
        can_move: svars::StateBoolean({
            setter: @[!server,capi.set_can_move],
            client_set: true, client_cb: true
        }),
        client_state: svars::StateInteger({
            getter: @[!server,capi.get_clientstate],
            setter: @[!server,capi.set_clientstate],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        physical_state: svars::StateInteger({
            getter: @[!server,capi.get_physstate],
            setter: @[!server,capi.set_physstate],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        in_liquid: svars::StateInteger({
            getter: @[!server,capi.get_inwater],
            setter: @[!server,capi.set_inwater],
            custom_sync: true, gui_name: false, client_cb: true
        }),
        time_in_air: svars::StateInteger({
            getter: @[!server,capi.get_timeinair],
            setter: @[!server,capi.set_timeinair],
            custom_sync: true, gui_name: false, client_cb: true
        }),

        physics_trigger: svars::StateInteger({ gui_name: false }),

        jumping_sound: svars::StateString(),
        landing_sound: svars::StateString()
    },

    /**
        A handler called when the character is about to jump. By default sets
        `jumping` to value of its argument.

        Arguments:
            - down - whether the jump key is down.
    */
    jump: func(self, down) {
        self.set_attr("jumping", down)
    },

    /** Function: crouch
        A handler called when the character is about to crouch. By default
        checks if `down` is true and if it is, sets `crouching` to -1,
        otherwise sets `crouching` to `abs(crouching)`.

        Arguments:
            - down - whether the crouch key is down.
    */
    crouch: func(self, down) {
        if down {
            self.set_attr("crouching", -1)
        } else {
            self.set_attr("crouching", abs(self.get_attr("crouching")))
        }
    },

    get_plag: @[!server,func(self) { return capi::get_plag(self.__centity) }],
    get_ping: @[!server,func(self) { return capi::get_ping(self.__centity) }],
    get_editing: @[!server,func(self) { return self.get_attr("client_state") == 4 }],
    get_lagged: @[!server,func(self) { return self.get_attr("client_state") == 3 }],

    __init_svars: func(self, kwargs) {
        self.cn = kwargs && kwargs.cn || -1
        assert(self.cn >= 0)

        Entity::__init_svars(self, kwargs)

        if !msg::is_server_only() {
            self.__centity = capi::setup_character(self.cn)
            M::set_centity(self.__centity, self)
        }

        self.set_attr("model_name", "")
        self.set_attr("attachments", [])
        self.set_attr("animation", 3 | (1 << 9))
        self.set_attr("start_time", 0) // so that server has some value

        self.cn = kwargs && kwargs.cn || -1
        self.set_attr("character_name", "none")
        self.set_attr("model_name", "player")
        self.set_attr("eye_height", 18.0)
        self.set_attr("max_height", 18.0)
        self.set_attr("crouch_height", 0.75)
        self.set_attr("crouch_speed", 0.4)
        self.set_attr("crouch_time", 200)
        self.set_attr("jump_velocity", 125)
        self.set_attr("gravity", -1)
        self.set_attr("above_eye", 2.0)
        self.set_attr("movement_speed", 100.0)
        self.set_attr("facing_speed", 120)
        self.set_attr("radius", 4.1)
        self.set_attr("can_move", true)

        // initialize custom-synced with default vals
        self.set_attr("yaw", 0)
        self.set_attr("pitch", 0)
        self.set_attr("roll", 0)
        self.set_attr("move", 0)
        self.set_attr("strafe", 0)
        self.set_attr("yawing", 0)
        self.set_attr("pitching", 0)
        self.set_attr("crouching", 0)
        self.set_attr("jumping", false)
        self.set_attr("position", [ 512, 512, 550 ])
        self.set_attr("velocity", [ 0, 0, 0 ])
        self.set_attr("falling", [ 0, 0, 0 ])
        self.set_attr("client_state", 0)
        self.set_attr("physical_state", 0)
        self.set_attr("in_liquid", 0)
        self.set_attr("time_in_air", 0)

        self.set_attr("physics_trigger", 0)
        self.set_attr("jumping_sound", "gk/jump2.ogg")
        self.set_attr("landing_sound", "olpc/AdamKeshen/kik.wav")
    },

    __activate: @[server,func(self, kwargs) {
        self.cn = kwargs && kwargs.cn || -1
        assert(self.cn >= 0)

        self.setup()
        self.initialized = true
        self.send_notification_full(msg.ALL_CLIENTS)
        self.sent_notification_full = true

        self.set_attr("model_name", self.get_attr("model_name"))
    },func(self, kwargs) {
        self.cn = kwargs && kwargs.cn || -1
        assert(self.cn >= 0)

        self.__centity = capi::setup_character(self.cn)
        M::set_centity(self.__centity, self)

        self.setup()
        self.initialized = msg::is_server()
        if capi::isplayer(self.cn) { ents::__set_player(self) }

        if msg::is_server() {
            self.send_notification_full(msg.ALL_CLIENTS)
            self.sent_notification_full = true
        }

        self.render_args_timestamp = -1

        // see world.oct for field meanings
        connect(self, "physics_trigger,changed", func(self, val) {
            if val == 0 { return }
            self.set_attr("physics_trigger", 0)

            var pos = (self != ents::get_player())
                && self.get_attr("position") || undef

            var lst = val & MASK_LIQUID
            if lst == FLAG_ABOVELIQUID {
                if (val & MASK_MAT) != FLAG_LAVA {
                    sound::play("yo_frankie/amb_waterdrip_2.wav", pos)
                }
            } else if lst == FLAG_BELOWLIQUID {
                sound::play((val & MASK_MAT) == FLAG_LAVA
                    && "yo_frankie/DeathFlash.wav"
                    || "yo_frankie/watersplash2.wav", pos)
            }

            var gst = val & MASK_GROUND
            if gst == FLAG_ABOVEGROUND {
                sound::play(self.get_attr("jumping_sound"), pos)
            } else if gst == FLAG_BELOWGROUND {
                sound::play(self.get_attr("landing_sound"), pos)
            }
        })
    }],

    __deactivate: func(self) {
        if !msg::is_server_only() {
            M::set_centity(self.__centity, undef)
            self.__centity = undef
        }
        Entity::__deactivate(self)
    },

    /**
        Decides the base time to use for animation rendering of the character.
        By default simply returns `start_time`.
    */
    decide_base_time: func(self, anim) {
        return self.get_attr("start_time")
    },

    /** Function: __render
        Clientside and run per frame. It renders the character model. Decides
        all the parameters, including animation etc.

        When rendering HUD, the member `hud_model_offset` (vec3) is used to
        offset the HUD model (if available).

        There is one additional argument, fpsshadow - it's true if we're about
        to render a first person shadow (can be true only when needhud is true
        and hudpass is false).

        Arguments:
            - hudpass - a bool, true if we're rendering the HUD pass (whether
              we're rendering a HUD model right now).
            - needhud - true if we're in first person mode.
            - fpsshadow - true if we enabled a FPS player shadow.
    */
    __render: @[!server,func(self, hudpass, needhud, fpsshadow) {
        if !self.initialized { return }
        if !hudpass && needhud && !fpsshadow { return }

        var state = self.get_attr("client_state")
        // spawning or spectator
        if state == 5 || state == 2 { return }
        // editing
        if !hudpass && needhud && state == 4 { return }
        var mdn = (hudpass && needhud)
            && self.get_attr("hud_model_name")
            ||  self.get_attr("model_name")

        if mdn == "" { return }

        var yaw, pitch, roll = self.get_attr("yaw"),
            self.get_attr("pitch"),
            self.get_attr("roll")
        var o = self.get_attr("position").copy()

        if hudpass && needhud && self.hud_model_offset {
            o.add(self.hud_model_offset)
        }

        var pstate = self.get_attr("physical_state")
        var iw = self.get_attr("in_liquid")
        var mv, sf = self.get_attr("move"), self.get_attr("strafe")

        var vel, fall = self.get_attr("velocity").copy(),
            self.get_attr("falling").copy()
        var tia = self.get_attr("time_in_air")

        var cr = self.get_attr("crouching")

        var anim = self.decide_animation(state, pstate, mv,
            sf, cr, vel, fall, iw, tia)

        var bt = self.decide_base_time(anim)

        var flags = self.get_render_flags(hudpass, needhud)

        mrender(self, mdn, anim, o, yaw, pitch, roll, flags, bt)
    }],

    /** Function: get_render_flags
        Returns the rendering flags used when rendering the character. By
        default, it enables some occlusion stuff. Override as needed.
        Called from $__render. Clientside.

        Arguments:
            - hudpass, needhud - see $__render.
    */
    get_render_flags: @[!server,func(self, hudpass, needhud) {
        var flags
        if self != ents::get_player() {
            flags = model.render_flags.CULL_VFC
                | model.render_flags.CULL_OCCLUDED
                | model.render_flags.CULL_QUERY
        } else {
            flags = model.render_flags.FULLBRIGHT
        }
        if needhud {
            if hudpass {
                flags |= model.render_flags.NOBATCH
            } else {
                flags |= model.render_flags.ONLY_SHADOW
            }
        }
        return flags
    }],

    /** Function: get_animation
        Returns the base "action animation" used by $decide_animation. By
        default simply return the `animation` attribute.
    */
    get_animation: @[!server,func(self) {
        return self.get_attr("animation")
    }],

    /** Function: decide_animation
        Decides the current animation for the character. Starts with
        $get_animation, then adjusts it to take things like moving,
        strafing, swimming etc into account. Returns the animation
        (an array) and animation flags (by default 0).

        Arguments:
            - state - client state (see $State).
            - pstate - physical state (see $PhysicalState).
            - move, strafe, crouching, vel, falling, unwater, tinair - see
              the appropriate state variables.
    */
    decide_animation: @[!server,func(self, state, pstate, move,
    strafe, crouching, vel, falling, inwater, tinair) {
        var anim = self.get_animation()

        var mask = anims.INDEX | anims.DIR
        var panim, sanim = anim & mask, (anim >> anims.SECONDARY) & mask

        // editing or spectator
        if state == 4 || state == 5 {
            panim = anims.edit | animctl.LOOP
        // lagged
        } else if state == 3 {
            panim = anims.lag | animctl.LOOP
        } else {
            // in water and floating or falling
            if inwater != 0 && pstate <= 1 {
                sanim = (((move || strafe) || ((vel.z + falling.z) > 0))
                    && anims.swim || anims.sink) | animctl.LOOP
            // moving or strafing
            } else {
                var dir = anim_dirs[(move + 1) * 3 + strafe + 1]
                // jumping anim
                if tinair > 100 {
                    sanim = ((dir != 0) && (dir + anims.jump_N - anims.run_N)
                        || anims.jump) | animctl.END
                } else if dir != 0 {
                    sanim = dir | animctl.LOOP
                }
            }

            if crouching != 0 {
                var v = sanim & anims.INDEX
                if v == anims.idle {
                    sanim = sanim & ~anims.INDEX
                    sanim = sanim | anims.crouch
                } else if v == anims.jump {
                    sanim = sanim & ~anims.INDEX
                    sanim = sanim | anims.crouch_jump
                } else if v == anims.swim {
                    sanim = sanim & ~anims.INDEX
                    sanim = sanim | anims.crouch_swim
                } else if v == anims.sink {
                    sanim = sanim & ~anims.INDEX
                    sanim = sanim | anims.crouch_sink
                } else if v == 0 {
                    sanim = anims.crouch | animctl.LOOP
                } else if anim_run[v] {
                    sanim = sanim + anims.crouch_N - anims.run_N
                } else if anim_jump[v] {
                    sanim = sanim + anims.crouch_jump_N - anims.jump_N
                }
            }

            if (panim & anims.INDEX) == anims.idle &&
               (sanim & anims.INDEX) != 0 {
                panim = sanim
            }
        }

        if (sanim & anims.INDEX) == 0 {
            sanim = anims.idle | animctl.LOOP
        }
        return panim | (sanim << anims.SECONDARY)
    }],

    /**
        Gets the center position of a character, something like gravity center
        (approximate). Useful for e.g. bots (better to aim at this position,
        the actual `position` is feet position). Override if you need this
        non-standard. By default it's 0.75 * eye_height above feet.
    */
    get_center: func(self) {
        var r = self.get_attr("position").copy()
        r.z = r.z + self.get_attr("eye_height") * 0.75
        return r
    },

    /**
        Given an origin position (e.g. from an attachment tag), this method
        is supposed to fix it so that it corresponds to where player actually
        targeted from. By default just returns origin.
    */
    get_targeting_origin: func(self, origin) {
        return origin
    },

    /**
        Sets the `animation` property locally, without notifying the other
        side. Useful when allowing actions to animate the entity (as we mostly
        don't need the changes to reflect elsewhere).
    */
    set_local_animation: func(self, anim) {
        capi::set_animation(self.uid, anim)
        self.svar_values["animation"] = anim
    },

    /**
        Sets the `model_name` property locally, without notifying the other
        side.
    */
    set_local_model_name: func(self, mname) {
        capi::set_model_name(self.uid, mname)
        self.svar_values["model_name"] = mname
    }
})
var Character = M.Character

/** Function: physics_collide_client
    An external called when two clients collide. Takes both entities. By
    default emits the "collision" signal on both clients, passing the other
    one as an argument. The client we're testing collisions against gets the
    first emit.
*/
set_external("physics_collide_client", func(cl1, cl2, dx, dy, dz) {
    cl1, cl2 = get_by_centity(cl1), get_by_centity(cl2)
    if !cl1 || !cl2 { return }
    emit(cl1, "collision", cl2, dx, dy, dz)
    emit(cl2, "collision", cl1, dx, dy, dz)
})

set_external("entity_set_local_animation", func(cent, anim) {
    var ent = get_by_centity(cent)
    if !ent { return }
    ent.set_local_animation(anim)
})

/**
    The default entity prototype for player. Inherits from $Character. Adds
    two new properties.

    Properties:
        - can_edit [false] - if player can edit, it's true (private edit mode).
        - hud_model_name [""] - the first person model to use for the player.
*/
M.Player = Character.clone({
    name: "Player",

    __properties: {
        can_edit: svars::StateBoolean(),
        hud_model_name: svars::StateString()
    },

    __init_svars: func(self, kwargs) {
        Character::__init_svars(self, kwargs)

        self.set_attr("can_edit", false)
        self.set_attr("hud_model_name", "")
    }
})

ents::register_prototype(Character)
ents::register_prototype(M.Player)

// STATIC ENTS ARE CLIENT ONLY

@[!server] {

var c_get_attr = capi.get_attr
var c_set_attr = capi.set_attr

var gen_attr = func(i, name) {
    i = i - 1
    return svars::StateInteger({
        getter: func(ent) {      return c_get_attr(ent, i)      },
        setter: func(ent, val) { return c_set_attr(ent, i, val) },
        gui_name: name, alt_name: name
    })
}

/**
    A base for any static entity. Inherits from $Entity. Unlike
    dynamic entities (such as $Character$), static entities usually don't
    invoke their `__run` method per frame. To re-enable that, set the
    `__per_frame` member to true (false by default for efficiency).

    This entity prototype is never registered, the inherited ones are.

    Properties:
        position [{{$svars.StateVec3}}] - the entity position.
*/
M.StaticEntity = Entity.clone({
    name: "StaticEntity",

    __storage: "static",

    /// The icon that'll be displayed in edit mode.
    __edit_icon: "media/interface/icon/edit_generic",

    __per_frame: false,
    sauer_type: 0,
    attr_num  : 0,

    __properties: {
        position: svars::StateVec3({
            getter: capi.get_extent_position,
            setter: capi.set_extent_position
        })
    },

    __init_svars: func(self, kwargs) {
        @[debug] log(DEBUG, "StaticEntity.init")

        kwargs = kwargs || {}

        self.setup()
        self.initialized = true

        self.__centity = capi::setup_extent(self.uid, self.sauer_type,
            kwargs.c_entity, true)
        M::set_centity(self.__centity, self)

        self.set_attr("tags", [])

        if !kwargs.position {
            self.set_attr("position", [ 511, 512, 513 ])
        } else {
            self.set_attr("position", [
                tonumber(kwargs.position.x),
                tonumber(kwargs.position.y),
                tonumber(kwargs.position.z)
            ])
        }

        @[debug] log(DEBUG, "StaticEntity.init complete")
    },

    /// Overridden because static ents are always clientside.
    __activate: func(self, kwargs) {
        var sd = kwargs && kwargs.state_data || undef
        if !self.__centity {
            self.__centity = capi::setup_extent(self.uid, self.sauer_type,
                kwargs.c_entity, false)
            M::set_centity(self.__centity, self)
        }
        self.setup()
        if sd { self.set_sdata_full(sd) }
        self.initialized = true

        // need to do this in order to trigger C setters
        self.set_attr("position", self.get_attr("position"))
        for i in 1 to self.attr_num {
            var an = "attr" ~ i
            self.set_attr(an, self.get_attr(an))
        }
    },

    __deactivate: func(self) {
        if self.__centity {
            M::set_centity(self.__centity, undef)
            capi::destroy_extent(self.uid)
            self.__centity = undef
        }
        self.clear_actions()
        self.deactivated = true
    },

    /**
        Overridden because static ents are always clientside. We ignore
        client_set etc. for svars here.
    */
    set_sdata: func(self, key, val, actor_uid) {
        @[debug] log(INFO, "    var update")
        var svar = self[e"_SV_$key"]
        assert(svar.validate(val))
        self.sdata_changed(svar, key, val)
        emit(self, e"$key,changed", val, actor_uid != -1)
        self.svar_values[key] = val
    },

    /**
        See {{$Character.get_center}}. By default this is the entity position.
        May be overloaded for other entity types.
    */
    get_center: func(self) {
        return self.get_attr("position").copy()
    },

    /**
        Returns the color of the entity icon in edit mode. If an invalid
        value is returned, it defaults to 255, 255, 255 (white). This is
        useful for e.g. light entity that is colored.
    */
    __get_edit_color: func(self) {
        return 255, 255, 255
    },

    /**
        Returns any piece of information displayed in in the edit HUD in
        addition to the entity name. Overload for different entity types.
    */
    __get_edit_info: func(self) {
        return undef
    },

    /**
        Returns the currently attached entity. Useful mainly for spotlights.
        This refers to the "internally attached" entity that the core engine
        works with.
    */
    get_attached_entity: func(self) {
        return capi::get_attached_entity(self)
    },

    /**
        Returns the height above the floor to use when dropping the entity
        to the floor. By default returns 4, may be useful to overload (for
        say, mapmodels).
    */
    get_edit_drop_height: func(self) {
        return 4
    },

    __sdata_call_cb_set: func(self, f, val) {
        var uid = self.uid
        if self.__fully_created {
            capi::removeentityedit(uid)
            f(uid, val)
            capi::addentityedit(uid)
        } else {
            f(uid, val)
        }
    },

    __sdata_post_call_cb_set: func(self) {
        if self.__fully_created {
            capi::editent(self.uid)
        }
    },

    __sdata_call_cb_get: func(self, f) {
        return f(self.uid)
    },

    __post_create_cb: func(self, new, kwargs) {
        capi::setup_extent_done(self.uid, kwargs.c_entity, new, !!kwargs.synced)
        if new && !kwargs.synced {
            capi::editent(self.uid)
        }
    }
})
var StaticEntity = M.StaticEntity

set_external("entity_set_pos", func(cent, x, y, z) {
    var ent = get_by_centity(cent)
    if !ent { return }
    // bypass any sort of sync or update here...
    var arr = ent.svar_values["position"]
    arr[0], arr[1], arr[2] = x, y, z
    var uid = ent.uid
    capi::removeentityedit(uid)
    capi::set_extent_position(uid, arr)
    capi::addentityedit(uid)
})

/** Function: entity_get_edit_info
    An external. Returns `ent.__edit_icon`,
    `ent:{{$StaticEntity.__get_edit_color|__get_edit_color}}()` where `ent`
    is the entity with unique id `uid`.
*/
set_external("entity_get_edit_icon_info", func(cent) {
    var ent = get_by_centity(cent)
    if !ent { return }
    return ent.__edit_icon, ent.__get_edit_color()
})

/** Function: entity_get_edit_info
    An external. Returns the entity name and the return value of
    {{$StaticEntity.__get_edit_info}}.
*/
set_external("entity_get_edit_info", func(cent) {
    var ent = get_by_centity(cent)
    if !ent { return }
    return ent.name, ent.__get_edit_info()
})

/** Function: entity_get_edit_drop_height
    An external, see {{$StaticEntity.get_edit_drop_height}}. Takes the entity.
*/
set_external("entity_get_edit_drop_height", func(cent) {
    var ent = get_by_centity(cent)
    if !ent { return }
    return ent.get_edit_drop_height()
})

/**
    A generic marker without orientation. It doesn't have any default
    additional properties.
*/
M.Marker = StaticEntity.clone({
    name: "Marker",

    __edit_icon: "media/interface/icon/edit_marker",

    sauer_type: 1,

    /// Places the given entity on this marker's position.
    place_entity: func(self, ent) {
        ent.set_attr("position", self.get_attr("position"))
    }
})
var Marker = M.Marker

/**
    A generic (oriented) marker with a wide variety of uses. Can be used as
    a base for various position markers (e.g. playerstarts).

    An example of world marker usage is a cutscene system. Different marker
    types inherited from this one can represent different nodes.

    Properties:
        - attr1 - aka "yaw".
        - attr2 - aka "pitch".
*/
M.OrientedMarker = StaticEntity.clone({
    name: "OrientedMarker",

    __edit_icon: "media/interface/icon/edit_marker",

    sauer_type: 2,
    attr_num  : 2,

    __attr_names: [ "yaw", "pitch" ],

    __properties: {
        attr1: gen_attr(1, "yaw"),
        attr2: gen_attr(2, "pitch")
    },

    __init_svars: func(self, kwargs, nd) {
        StaticEntity::__init_svars(self, kwargs, nd)
        self.set_attr("yaw", 0, nd[0])
        self.set_attr("pitch", 0, nd[1])
    },

    /// Places the given entity on this marker's position, using yaw and pitch.
    place_entity: func(self, ent) {
        ent.set_attr("position", self.get_attr("position"))
        ent.set_attr("yaw", self.get_attr("yaw"))
        ent.set_attr("pitch", self.get_attr("pitch"))
    },

    __get_edit_info: func(self) {
        return "yaw :\f2 %d \f7| pitch :\f2 %d".format(self.get_attr("yaw"),
            self.get_attr("pitch"))
    }
})
var OrientedMarker = M.OrientedMarker

from std.table import setmt

var lightflags = setmt({
    0: "dynamic (0)",
    1: "none (1)",
    2: "static (2)"
}, {
    __index: func(self, i) {
        return "invalid (%d)".format(i)
    }
})

/**
    A regular point light. In the extension library there are special light
    entity types that are e.g. triggered, flickering and so on. When providing
    properties as extra arguments to newent, you can specify red, green, blue,
    radius and shadow in that order.

    Properties:
        - attr1 - light radius. (0 to N, alias "radius", default 100 - 0 or
          lower means the light is off)
        - attr2 - red value (can be any range, even negative - typical values
          are 0 to 255, negative values make a negative light, alias "red",
          default 128)
        - attr3 - green value (alias "green", default 128)
        - attr4 - blue value (alias "blue", default 128)
        - attr5 - shadow type, 0 means dnyamic, 1 disabled, 2 static (default 0).
*/
M.Light = StaticEntity.clone({
    name: "Light",

    __edit_icon: "media/interface/icon/edit_light",

    sauer_type: 3,
    attr_num  : 5,

    __attr_names: [ "red", "green", "blue", "radius", "shadow" ],

    __properties: {
        attr1: gen_attr(1, "radius"),
        attr2: gen_attr(2, "red"),
        attr3: gen_attr(3, "green"),
        attr4: gen_attr(4, "blue"),
        attr5: gen_attr(5, "shadow")
    },

    __init_svars: func(self, kwargs, nd) {
        StaticEntity::__init_svars(self, kwargs, nd)
        self.set_attr("red", 128, nd[0])
        self.set_attr("green", 128, nd[1])
        self.set_attr("blue", 128, nd[2])
        self.set_attr("radius", 100, nd[3])
        self.set_attr("shadow", 0, nd[4])
    },

    __get_edit_color: func(self) {
        return self.get_attr("red"), self.get_attr("green"),
            self.get_attr("blue")
    },

    __get_edit_info: func(self) {
        return "red :\f2 %d \f7| green :\f2 %d \f7| blue :\f2 %d\n\f7"
               "radius :\f2 %d \f7| shadow :\f2 %s".format(
            self.get_attr("red"), self.get_attr("green"),
            self.get_attr("blue"), self.get_attr("radius"),
            lightflags[self.get_attr("shadow")])
    }
})

/**
    A spot light. It's attached to the nearest $Light. Properties such as
    color are retrieved from the attached light entity.

    Properties:
        - attr1 - alias "radius", defaults to 90, in degrees (90 is a full
          hemisphere, 0 is a line)
*/
M.SpotLight = StaticEntity.clone({
    name: "SpotLight",

    __edit_icon: "media/interface/icon/edit_spotlight",

    sauer_type: 4,
    attr_num  : 1,

    __attr_names: [ "radius" ],

    __properties: {
        attr1: gen_attr(1, "radius")
    },

    __init_svars: func(self, kwargs, nd) {
        StaticEntity::__init_svars(self, kwargs, nd)
        self.set_attr("radius", 90, nd[0])
    },

    __get_edit_color: func(self) {
        var ent = self.get_attached_entity()
        if !ent { return 255, 255, 255 }
        return ent.get_attr("red"), ent.get_attr("green"), ent.get_attr("blue")
    },

    __get_edit_info: func(self) {
        return "radius :\f2 %d".format(self.get_attr("radius"))
    }
})

/**
    An environment map entity prototype. Things reflecting on their surface using
    environment maps can generate their envmap from the nearest envmap entity
    instead of using skybox and reflect geometry that way (statically). You
    can specify the radius as an extra argument to newent.

    Properties:
        - attr1 - alias "radius", the distance it'll still have effect in,
          defaults to 128.
*/
M.Envmap = StaticEntity.clone({
    name: "Envmap",

    __edit_icon: "media/interface/icon/edit_envmap",

    sauer_type: 5,
    attr_num  : 1,

    __attr_names: [ "radius" ],

    __properties: {
        attr1: gen_attr(1, "radius")
    },

    __init_svars: func(self, kwargs, nd) {
        StaticEntity::__init_svars(self, kwargs, nd)
        self.set_attr("radius", 128, nd[0])
    },

    __get_edit_info: func(self) {
        return "radius :\f2 %d".format(self.get_attr("radius"))
    }
})

/**
    A sound effect prototype. You can use this to make your own sound effect
    types.

    Properties:
        - attr1 - the sound radius (alias "radius", default 100)
        - attr2 - the sound size, if this is 0, the sound is a point source,
          otherwise the sound volume will always be max until the distance
          specified by this property and do it'll start fading off
          (alias "size", default 0).
*/
M.SoundEffect = StaticEntity.clone({
    name: "Sound",

    __edit_icon: "media/interface/icon/edit_sound",

    sauer_type: 6,
    attr_num  : 2,

    __attr_names: [ "radius", "size" ],

    __properties: {
        attr1: gen_attr(1, "radius"),
        attr2: gen_attr(2, "size")
    },

    __init_svars: func(self, kwargs, nd) {
        StaticEntity::__init_svars(self, kwargs, nd)
        self.set_attr("radius", 100, nd[0])
        self.set_attr("size", 0, nd[1])
    },

    __activate: func(self, ...) {
        StaticEntity::__activate(self, ...)
        connect(self, "radius,changed", self.sound_stop)
        connect(self, "size,changed", self.sound_stop)
    },

    /** Stop all sounds currently assigned to the entity. */
    sound_stop: func(self) {
        capi::sound_stop_map(self.__centity)
    },

    /** Play a sound on this entity. The last loops parameter is optional. */
    sound_play: func(self, name, volume, loops) {
        capi::sound_play_map(self.__centity, name, volume, loops || -1)
    },

    /** Override to play sounds. */
    __play_sound: func(self) { }
})

var SoundEffect = M.SoundEffect

/**
    A generic ambient sound entity. Repeats the given sound at the entity
    position. You can specify (in addition to default radius and size) the
    sound name and volume. The extra arguments to newent go as follows:
    sound name, volume, radius, size.

    Properties:
        - volume [{{$svars.StateInteger}}] - the sound volume, from 0 to 100
          (default 100)
        - sound_name [{{$svars.StateString}}] - the  path to the sound in
          media/sound (default "").
*/
M.AmbientSound = SoundEffect.clone({
    name: "AmbientSound",

    __properties: {
        volume: svars::StateInteger(),
        sound_name: svars::StateString()
    },

    __attr_names: [ "volume", "radius", "size" ],

    __init_svars: func(self, kwargs, nd) {
        SoundEffect::__init_svars(self, kwargs, [ nd[2], nd[3] ])
        self.set_attr("volume", 100, nd[1])
        self.set_attr("sound_name", "", nd[0])
    },

    __activate: func(self, ...) {
        SoundEffect::__activate(self, ...)
        connect(self, "sound_name,changed", self.sound_stop)
        connect(self, "volume,changed", self.sound_stop)
    },

    __get_edit_info: func(self) {
        return "radius :\f2 %d \f7| size :\f2 %d \f7| volume :\f2 %d"
               "\n\f7name :\f2 %s".format(
            self.get_attr("radius"), self.get_attr("size"),
            self.get_attr("volume"), self.get_attr("sound_name"))
    },

    __play_sound: func(self) {
        self.sound_play(self.get_attr("sound_name"), self.get_attr("volume"))
    }
})

set_external("sound_play_map", func(cent) {
    var ent = get_by_centity(cent)
    if !ent { return }
    ent.__play_sound()
})

/**
    A particle effect entity prototype. You can derive from this to create
    your own effects, but by default this doesn't draw anything and is
    not registered. It also specifies __emit_particles as a composable
    method.
*/
M.ParticleEffect = StaticEntity.clone({
    name: "ParticleEffect",

    __edit_icon : "media/interface/icon/edit_particles",
    sauer_type: 7,

    __plugin_methods: [ "__emit_particles" ],

    /// Returns 0.
    get_edit_drop_height: func(self) {
        return 0
    },

    /// This is what you need to override - draw your particles from here.
    __emit_particles: func(self) { }
})

set_external("particle_entity_emit", func(cent) {
    var ent = get_by_centity(cent)
    if !ent { return }
    ent.__emit_particles()
})

/**
    A model in the world. All attrs default to 0. On mapmodels and all
    entity types derived from mapmodels, the engine emits the `collision`
    signal with the collider entity passed as an argument when collided.
    You can specify the model name, yaw, pitch, roll and scale as extra
    arguments to newent.

    Properties:
        - animation [{{$svars.StateInteger}}] - the mapmodel's current
          animation. See $Character.
        - start_time [{{$svars.StateInteger}}] - an internal property used for
          animation timing.
        - model_name [{{$svars.StateString}}] - name of the model associated
          with this mapmodel.
        - attachments [{{$svars.StateArray}}] - an array of model attachments.
          Those are strings in format "tagname,attachmentname".
        - attr1 - the model yaw, alias "yaw".
        - attr2 - the model pitch, alias "pitch".
        - attr3 - the model roll, alias "roll".
        - attr4 - the model scale, alias "scale".
*/
M.Mapmodel = StaticEntity.clone({
    name: "Mapmodel",

    __edit_icon: "media/interface/icon/edit_mapmodel",

    sauer_type: 8,
    attr_num  : 4,

    __attr_names: [ "yaw", "pitch", "roll", "scale" ],

    __properties: {
        animation: svars::StateInteger({
            setter: capi.set_animation_ext, client_set: true
        }),
        start_time : svars::StateInteger({
            getter: capi.get_start_time_ext
        }),
        model_name : svars::StateString({
            setter: capi.set_model_name
        }),
        attachments: svars::StateArray({
            setter: func(self, val) {
                var arr = ffi::new("const char *[?]", val.len() + 1)
                for i, v in val.each() { arr[i] = v }
                set_attachments_ext(self, arr)
            }
        }),

        attr1: gen_attr(1, "yaw"),
        attr2: gen_attr(2, "pitch"),
        attr3: gen_attr(3, "roll"),
        attr4: gen_attr(4, "scale")
    },

    __init_svars: func(self, kwargs, nd) {
        StaticEntity::__init_svars(self, kwargs, nd)
        self.set_attr("model_name", "", nd[0])
        self.set_attr("yaw", 0, nd[1])
        self.set_attr("pitch", 0, nd[2])
        self.set_attr("roll", 0, nd[3])
        self.set_attr("scale", 0, nd[4])
        self.set_attr("attachments", [])
        self.set_attr("animation", 3 | (1 << 9))
    },

    __activate: func(self, kwargs) {
        StaticEntity::__activate(self, kwargs)
        self.set_attr("model_name", self.get_attr("model_name"))
    },

    __get_edit_info: func(self) {
        return "yaw :\f2 %d \f7| pitch :\f2 %d \f7| roll :\f2 %d \f7|"
               " scale :\f2 %d\n\f7name :\f2 %s".format(
            self.get_attr("yaw"), self.get_attr("pitch"),
            self.get_attr("roll"), self.get_attr("scale"),
            self.get_attr("model_name"))
    },

    /// Returns 0.
    get_edit_drop_height: func(self) {
        return 0
    },

    /// See {{$Character.set_local_animation}}.
    set_local_animation: Character.set_local_animation,

    /// See {{$Character.set_local_model_name}}.
    set_local_model_name: Character.set_local_model_name
})

/** Function: physics_collide_mapmodel
    An external called when a client collides with a mapmodel. Takes the
    collider entity (the client) and the mapmodel entity. By default emits the
    `collision` signal on both entities, passing the other one as an argument.
    The mapmodel takes precedence.
*/
set_external("physics_collide_mapmodel", func(collider, entity) {
    collider, entity = get_by_centity(collider), get_by_centity(entity)
    if !collider || !entity { return }
    emit(entity, "collision", collider)
    emit(collider, "collision", entity)
})

/**
    An entity prototype that emits a `collision` signal on itself when a client
    (player, NPC...) collides with it. You can specify the properties as extra
    arguments to newent.

    Properties:
        - attr1, attr2, attr3 - alias "yaw", "pitch", "roll", all 0.
        - attr4, attr5, attr6 - alias "a", "b", "c" (the dimensions,
          10, 10, 10 by default).
        - attr7 - alias "solid", makes the obstacle solid when not 0 (0
          by default).
*/
M.Obstacle = StaticEntity.clone({
    name: "Obstacle",

    sauer_type: 9,
    attr_num  : 7,

    __attr_names: [ "a", "b", "c", "yaw", "pitch", "roll" ],

    __properties: {
        attr1: gen_attr(1, "yaw"),
        attr2: gen_attr(2, "pitch"),
        attr3: gen_attr(3, "roll"),
        attr4: gen_attr(4, "a"),
        attr5: gen_attr(5, "b"),
        attr6: gen_attr(6, "c"),
        attr7: gen_attr(7, "solid")
    },

    __init_svars: func(self, kwargs, nd) {
        StaticEntity::__init_svars(self, kwargs, nd)
        self.set_attr("yaw", 0, nd[3])
        self.set_attr("pitch", 0, nd[4])
        self.set_attr("roll", 0, nd[5])
        self.set_attr("a", 10, nd[0])
        self.set_attr("b", 10, nd[1])
        self.set_attr("c", 10, nd[2])
        self.set_attr("solid", 0, nd[6])
    },

    __get_edit_info: func(self) {
        return "yaw :\f2 %d \f7| pitch :\f2 %d \f7| roll :\f2 %d\n\f7"
               "a :\f2 %d \f7| b :\f2 %d \f7| c :\f2 %d \f7| solid :\f2 %d".format(
            self.get_attr("yaw"),  self.get_attr("pitch"),
            self.get_attr("roll"), self.get_attr("a"),
            self.get_attr("b"),    self.get_attr("c"), self.get_attr("solid"))
    },

    /// Returns 0.
    get_edit_drop_height: func(self) {
        return 0
    }
})

/**
    A decal entity prototype. It represents a decal that sticks to world geometry.
    Refer to Tesseract documentation for decals. You can specify the properties
    as extra arguments to newent, in slot, size, yaw, pitch, roll order
    (unlike Tesseract, which is slot, yaw, pitch, roll, size).

    Properties:
        - attr1 - alias "slot", the decal slot used.
        - attr2, attr3, attr4 - alias "yaw", "pitch", "roll", 0 by default.
        - atr5 - alias "size", the decal size in cube units.
*/
M.Decal = StaticEntity.clone({
    name: "Decal",

    sauer_type: 10,
    attr_num  : 5,

    __attr_names: [ "slot", "size", "yaw", "pitch", "roll" ],

    __properties: {
        attr1: gen_attr(1, "slot"),
        attr2: gen_attr(2, "yaw"),
        attr3: gen_attr(3, "pitch"),
        attr4: gen_attr(4, "roll"),
        attr5: gen_attr(5, "size")
    },

    __init_svars: func(self, kwargs, nd) {
        StaticEntity::__init_svars(self, kwargs, nd)
        self.set_attr("slot",  0, nd[0])
        self.set_attr("yaw",   0, nd[2])
        self.set_attr("pitch", 0, nd[3])
        self.set_attr("roll",  0, nd[4])
        self.set_attr("size",  1, nd[1])
    },

    __get_edit_info: func(self) {
        return "yaw :\f2 %d \f7| pitch :\f2 %d \f7| roll :\f2 %d\n\f7"
               "slot :\f2 %d \f7| size :\f2 %d".format(
            self.get_attr("yaw"),  self.get_attr("pitch"),
            self.get_attr("roll"), self.get_attr("slot"),
            self.get_attr("size"))
    },

    /// Returns 0.
    get_edit_drop_height: func(self) {
        return 0
    }
})

/** Function: physics_collide_area
    An external called when a client collides with an area. Takes the
    collider entity (the client) and the area entity. By default emits
    the `collision` signal on both entities, passing the other one as an
    argument. The obstacle takes precedence.
*/
set_external("physics_collide_area", func(collider, entity) {
    collider, entity = get_by_centity(collider), get_by_centity(entity)
    if !collider || !entity { return }
    emit(entity, "collision", collider)
    emit(collider, "collision", entity)
})

ents::register_prototype(M.Marker)
ents::register_prototype(M.OrientedMarker)
ents::register_prototype(M.Light)
ents::register_prototype(M.SpotLight)
ents::register_prototype(M.Envmap)
ents::register_prototype(M.AmbientSound)
ents::register_prototype(M.Mapmodel)
ents::register_prototype(M.Obstacle)
ents::register_prototype(M.Decal)

}
