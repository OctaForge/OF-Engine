/**<
    Implements basic entity handling, that is, storage, entity prototype management
    and the basic entity prototypees; the other extended entity types have their
    own modules.

    Author:
        q66 <daniel@octaforge.org>

    License:
        See COPYING.txt.
*/

import capi

from core.logger import log, DEBUG, INFO, ERROR, WARNING

import core.network.msg
import core.events.frame
import core.events.actions
import core.entities.svars
import core.engine.cubescript as cs
import core.engine.model

from core.octascript.messagepack import pack as mp_pack, unpack as mp_unpack
var mp_opts = { "number": "float" }

import core.externals

from std.object import Object
from std.table import pairs
from std.math import max, floor
from std.conv import tonumber, tostring, serialize, deserialize
from std.util import assert

var Entity

// clientside only
var player_entity

// basic storage for entities, keys are unique ids and values are entities
var storage_logic = []
var storage_dynamic = []
var storage_static
@[!server] storage_static = []

// stores all registered entity prototypees
var proto_storage = {}

// aliases
var proto_aliases = {}

var plugin_slots = [
    "__init_svars", "__activate", "__deactivate", "__run", "__render"
]

var modprefix = "_PLUGINS_"

func register_plugins(cl, plugins, name) {
    @[debug] log(DEBUG, "ents.register_prototype: registering plugins")
    var cldata = {}
    var properties

    var clmeths = cl["__plugin_methods"] || []
    for i, v in plugin_slots.each() { clmeths.push(v) }
    var clmethset = {}
    for i, v in clmeths.each() { clmethset[v] = true }

    var clname = cl.name
    for i, slot in clmeths.each() {
        var slotname = modprefix ~ clname ~ slot
        if cl[slotname] {
            raise e"reserved field used: $slotname"
        }

        var cltbl = [ cl[slot] ]
        for j, plugin in plugins.each() {
            var sl = plugin[slot]
            var tp = typeof sl
            if sl && tp == "function" || tp == "table" || tp == "userdata"
            { cltbl.push(sl) }
        }

        if !(cltbl.empty() || (cltbl.len() == 1 && cltbl[0] == cl[slot])) {
            cldata[slotname] = cltbl
            cldata[slot] = func(...) {
                for i, fn in cltbl.each() { fn(...) }
            }
        }
    }

    for i, plugin in plugins.each() {
        for name, elem in pairs(plugin) {
            if !clmethset[name] {
                if name == "__properties" {
                    if typeof elem != "table" {
                        raise "properties field must be a table"
                    }
                    if !properties {
                        properties = elem
                    } else {
                        for propn, propv in pairs(elem) {
                            properties[propn] = propv
                        }
                    }
                } else {
                    cldata[name] = elem
                }
            }
        }
    }

    var ret = cl.clone(cldata)
    ret.name               = name
    ret.__properties       = properties
    ret.__raw_ent_proto    = cl
    ret.__parent_ent_proto = cl.__proto
    ret.__plugins          = plugins
    return ret
}

/**
    Registers an entity prototype. The registered prototype is always a clone
    of the given prototype. You can access the original prototype via the
    `__raw_ent_proto` member of the new clone. You can access the parent of
    `__raw_ent_proto` using `__parent_ent_proto`. This also generates protocol
    data for its properties and registers these.

    Allows to provide an array of plugins to inject into the entity prototype
    (before the actual registration, so that the plugins can provide their own
    state variables).

    Because this is a special clone, do NOT derive from it. Instead derive
    from `__raw_ent_proto`. This function doesn't return anything for a reason.
    If you really need this special clone, use $get_prototype.

    A plugin is pretty much an associative table of things to inject. It
    can contain slots - those are functions or callable values with keys
    `__init_svars`, `__activate`, `__deactivate`, `__run`, `__render` - slots
    never override elements of the same name in the original prototype, instead
    they're called after it in the order of plugin array. Then it can contain
    any non-slot member, those are overriden without checking (the last plugin
    takes priority). Plugins can provide their own state variables via the
    `__properties` table, like entities. The `__properties` tables of plugins
    are all merged together and the last plugin takes priority.

    The original plugin array is accessible from the clone as `__plugins`.

    Note that plugins can NOT change the entity prototype name. If any such
    element is found, it's ignored.

    Arguments:
        - cl - the entity prototype.
        - plugins - an optional array of plugins (or name).
        - name - optional entity prototype name, if not provided the `name`
          field of the entity prototype name is used; it can also be the second
          argument if you are not providing plugins.
*/
export func register_prototype(cl, plugins, name) {
    if !name {
        if typeof plugins == "string" {
            name, plugins = plugins, undef
        } else {
            name = cl.name
        }
    }
    if !name {
        raise "attempt to register an unnamed entity prototype"
    }

    @[debug] log(DEBUG, e"ents.register_prototype: $name")

    if proto_storage[name] {
        raise e"entity prototype already exists: $name"
    }

    if plugins {
        cl = register_plugins(cl, plugins, name)
    } else {
        cl = cl.clone({
            name: name,
            __raw_ent_proto: cl,
            __parent_ent_proto: cl.__proto
        })
    }

    proto_storage[name] = cl
    proto_aliases[name.lower()] = name

    // table of properties
    var pt = {}
    var sv_names = []

    var base = cl
    while base {
        var props = base.__properties
        if props {
            for n, v in pairs(props) {
                if !pt[n] && svars::is_svar(v) {
                    pt[n] = v
                    sv_names.push(n)
                }
            }
        }
        if base == Entity { break }
        base = base.__proto
    }

    sv_names.sort(func(n, m) {
        if svars::is_svar_alias(pt[n]) && !svars::is_svar_alias(pt[m]) {
            return false
        }
        if !svars::is_svar_alias(pt[n]) && svars::is_svar_alias(pt[m]) {
            return true
        }
        return n < m
    })

    @[debug] log(DEBUG, "ents.register_prototype: generating protocol data for "
        e"{ $(sv_names.concat(', ')) }")

    @[debug] log(DEBUG, "ents.register_prototype: registering state variables")
    var pnames = []
    for i, name in sv_names.each() {
        var svar = pt[name]
        @[debug] log(DEBUG, e"    $name ($(svar.name))")
        svar.register(name, cl, i)
        pnames.push(name)
    }
    cl.__property_names = pnames

    cl.__instances = []
}

/**
    Returns the entity prototype with the given name. If it doesn't exist,
    logs an error message and returns undef.

    Use with caution!See $register_prototype for the possible dangers of
    using this. It's still useful sometimes, so it's in the API.
*/
export func get_prototype(cn) {
    var  t = proto_storage[cn] || proto_storage[proto_aliases[cn]]
    if !t {
        log(ERROR, e"ents.get_prototype: invalid prototype $cn")
    }
    return t
}

/**
    Returns the internal entity prototype storage (name->prototype mapping),
    use with care.
*/
export func get_all_prototypes() {
    return proto_storage
}

/**
    Retrieves a logic entity, given its unique id. If not found, undef.
*/
export func get_logic(uid) {
    var r = storage_logic[uid]
    if !r {
        @[debug] log(DEBUG, e"ents.get_logic: no such entity ($uid)")
    }
    return r
}
export func get_dynamic(uid) {
    var r = storage_dynamic[uid]
    if !r {
        @[debug] log(DEBUG, e"ents.get_dynamic: no such entity ($uid)")
    }
    return r
}
export var get_static = @[!server,func(uid) {
    var r = storage_static[uid]
    if !r {
        @[debug] log(DEBUG, e"ents.get_static: no such entity ($uid)")
    }
    return r
}]

/**
    Returns the currently targeted entity.
*/
export func get_targeted() {
    var suid, duid = capi::gettargetent()
    if suid >= 0 {
        return get_static(suid)
    }
    return get_dynamic(duid)
}

func get_by_tag(tag, stor) {
    var r = []
    for i, ent in stor.each() {
        if ent && ent.has_tag(tag) {
            r.push(ent)
        }
    }
    return r
}

/// Returns an array of entities with a common tag.
export func get_logic_by_tag(tag) { return get_by_tag(tag, storage_logic) }
export func get_dynamic_by_tag(tag) { return get_by_tag(tag, storage_dynamic) }
export var get_static_by_tag = @[!server,func(tag) { return get_by_tag(tag, storage_static) }]

/// Returns an array of entities with a common prototype.
export func get_by_prototype(cl) {
    var v = proto_storage[cl]
    return v ? v.__instances : []
}

var player_prototype = "Player"

/// Sets the player prototype (by name).
export func set_player_prototype(cl) {
    player_prototype = cl
}

/// Gets an array of players (all of the currently set player prototype).
export func get_players() {
    var v = proto_storage[player_prototype]
    return v ? v.__instances : []
}

/// Gets the current player, clientside only.
export var get_player = @[!server,func() {
    return player_entity
}]

export func __set_player(pl) {
    player_entity = pl
    pl.controlled_here = true
}

externals::set("entity_get_player_prototype", func() {
    return player_prototype
})

var storages = {
    logic: storage_logic,
    dynamic: storage_dynamic,
    static: @[!server,storage_static],
}

/**
    Inserts an entity of the given prototype or prototype name into the storage.
    The entity will get assigned an uid and activated. Kwargs will be passed
    to the activation calls and init call on the server. If `notnew` is true,
    `__init_svars` method will be not called on the server. That is mainly
    for when loading entities from complete serialized data.
*/
export func add(cn, kwargs, uid, notnew) {
    var cl = typeof cn == "table" && cn || (proto_storage[cn]
                                        ||  proto_storage[proto_aliases[cn]])
    if !cl {
        raise e"ents.add: no such entity prototype: $(tostring(cn))"
    }

    var cstor = cl.__storage
    var stor = storages[cstor]
    if !stor {
        raise e"invalid entity storage: $cstor"
    }

    if !uid {
        /* try to reuse indexes (TODO: cache unused indexes for better perf) */
        for i, v in stor.each() {
            if !v {
                uid = i
                break
            }
        }
        /* no free slot, no worries - we just add new */
    }

    uid = uid || stor.len()
    if uid >= stor.len() {
        stor.resize(uid + 1)
    }

    @[debug] log(DEBUG, e"ents.add: $(cl.name) ($uid)")
    if stor[uid] {
        raise e"attempt to recreate uid $uid in $cstor storage"
    }

    var r = cl()
    r.uid = uid
    stor[uid] = r
    r.__fully_created = false

    // caching
    cl.__instances.push(r)

    var enew = !!(!notnew && (msg::is_server() || stor == storage_static))
    if  enew {
        var ndata
        if kwargs {
            ndata = kwargs.newent_data
            kwargs.newent_data = undef
            if ndata { ndata = deserialize(ndata) }
        }
        r.__init_svars(kwargs, ndata || [])
    }

    @[debug] log(DEBUG, "ents.add: activate")
    r.__activate(kwargs)
    @[debug] log(DEBUG, "ents.add: activated")
    r.__fully_created = true
    r.__post_create_cb(enew, kwargs)
    return r
}

/**
    Removes an entity. First emits the `pre_deactivate` signal on it, then
    deactivates it and do clears it out from both storages.

    See also:
        - $remove_all
*/
export func remove(ent) {
    var uid = ent.uid
    @[debug] log(DEBUG, e"ents.remove: $uid")
    var stor = storages[ent.__storage]
    ent.emit("pre_deactivate")
    ent.__deactivate()
    ent.__proto.__instances.compact(\v -> v != ent)
    stor[uid] = undef
}

externals::set("entity_remove_static", @[!server,func(uid, synced) {
    var ent = storage_static[uid]
    if !ent { return }
    remove(ent)
    if !synced { capi::editent(uid) }
}])

externals::set("entity_remove_dynamic", func(uid) {
    var ent = storage_dynamic[uid]
    if !ent { return }
    remove(ent)
})

externals::set("entity_clear_actions", func(cn) {
    var ent = storage_dynamic[cn]
    if !ent { return }
    ent.clear_actions()
})

externals::set("entity_is_initialized", func(cn) {
    var ent = storage_dynamic[cn]
    if !ent { return false }
    return ent.initialized
})

func remove_stor(stor, protos) {
    for i, e in stor.each() {
        if e {
            protos[e.name] = true
            e.emit("pre_deactivate")
            e.__deactivate()
            stor[i] = undef
        }
    }
}

/**
    Removes all entities from both storages. It's equivalent to looping
    over the whole storage and removing each entity individually, but
    much faster. External as `entities_remove_all`.

    See also:
        - $remove
*/
export func remove_all(stat) {
    var protos = {}
    if (!stat) {
        remove_stor(storage_logic, protos)
        remove_stor(storage_dynamic, protos)
    } else {
        @[!server] remove_stor(storage_static, protos)
    }
    for nm, v in pairs(protos) {
        proto_storage[nm].__instances = []
    }
}
externals::set("entities_remove_all", remove_all)

externals::set("entities_load", @[!server,func(entstr) {
    var entities, err = []
    if !entstr {
        @[debug] log(DEBUG, "entities_load: nothing to read")
    } else {
        entities, err = deserialize(entstr)
    }

    if !entities {
        log(ERROR, e"error deserializing entities: $err")
        return
    }

    @[debug] log(DEBUG, "entities_load: loading all entities")
    for i, e in entities.each() {
        var cn = e[0]
        @[debug] log(DEBUG, e"    $i, $cn")
        add(cn, { state_data: mp_pack(e[1], mp_opts) }, undef, true)
    }
    @[debug] log(DEBUG, "entities_load: done")
}])

/**
    Serializes all loaded entities into format that can be read by $load.
    External as `entities_save_all`.
*/
export var save = @[!server,func() {
    var r = []
    @[debug] log(DEBUG, "ents.save: saving")

    for uid, entity in storage_static.each() {
        if entity {
            var en = entity.name
            @[debug] log(DEBUG, e"    $uid, $en")
            r.push(serialize([ en, entity.build_sdata() ]))
        }
    }

    @[debug] log(DEBUG, "ents.save: done")
    return e"[\n$(r.concat(",\n"))\n]\n"
}]
externals::set("entities_save_all", save)

var srnopos = { "position": true }
externals::set("entity_serialize", func(uid, nopos) {
    var ent = storage_static[uid]
    if !ent { return }
    var ignore = nopos ? srnopos : undef
    var sr = ent.build_sdata({ compressed: true, ignore: ignore })
    return ent.name, sr
})

func get_stor_uid(uid) {
    if uid < 0 { return -uid - 1, storage_dynamic }
    return uid, storage_logic
}

externals::set("msg_le_cn", @[!server,func(ocn, uid, oc, sd) {
    var uid, stor = get_stor_uid(uid)
    var ent = stor[uid]
    if ent == undef {
        ent = add(oc, (ocn >= 0) && { cn: ocn } || undef, uid, true)
        if ent == undef {
            log(ERROR, "received an entity that cannot be created")
            return
        }
    } else {
        @[debug] log(DEBUG, e"existing entity $uid, no need to create")
    }
    @[debug] log(DEBUG, e"updating state data with $(tostring(sd))")
    ent.set_sdata_full(sd)
    capi::renderprogress(0, "receiving entities...")
}])

func msg_le_cn_send(self, cn, ocn, oc, sd) {
    assert(sd.len() > 0)
    capi::msg_le_cn_send(cn, player_entity && player_entity.cn || -1, ocn,
        (self.__storage == "dynamic") ? (-self.uid - 1) : self.uid, oc, sd,
        sd.len())
}

externals::set("msg_le_rem", @[!server,func(uid) {
    var uid, stor = get_stor_uid(uid)
    if !stor[uid] { return }
    remove(stor[uid])
}])

func msg_le_rem_send(self, cn) {
    capi::msg_le_rem_send(cn, player_entity && player_entity.cn || -1,
        (self.__storage == "dynamic") ? (-self.uid - 1) : self.uid)
}

externals::set("msg_sdata_update", @[!server,func(uid, ocn, kpid, value) {
    var uid, stor = get_stor_uid(uid)
    @[debug] log(DEBUG, e"sdata_update: $uid, $kpid, $(tostring(value))")
    var ent = stor[uid]
    if ent {
        var key = ent.__property_names[kpid]
        @[debug] log(DEBUG, e"set_sdata: $uid, $kpid, $key")
        var sv = ent["_SV_" ~ key]
        ent.set_sdata(key, value)
    }
}])

func msg_sdata_update_send(self, cn, reliable, kpid, value, ocn) {
    assert(value.len() > 0)
    capi::msg_sdata_update_send(cn, player_entity && player_entity.cn || -1,
        reliable, (self.__storage == "dynamic") ? (-self.uid - 1) : self.uid,
        ocn, kpid, value, value.len())
}

externals::set("msg_sdata_changereq", func(sender, uid, kpid, value) {
    var uid, stor = get_stor_uid(uid)
    @[debug] log(DEBUG, e"client $uid tried to change $kpid to value "
        e"$(tostring(value))")
    var ent = stor[uid]
    if ent {
        var key = ent.__property_names[kpid]
        @[debug] log(DEBUG, e"set_sdata: $uid, $kpid, $key")
        var sv = ent["_SV_" ~ key]
        ent.set_sdata(key, value, sender)
    }
})

func msg_sdata_changereq_send(self, reliable, kpid, value) {
    assert(value.len() > 0)
    capi::msg_sdata_changereq_send(reliable,
        (self.__storage == "dynamic") ? (-self.uid - 1) : self.uid, kpid,
        value, value.len())
}

/**
    The base entity prototype. Every other entity prototype inherits from this.
    This prototype is fully functional, but it has no physical form (it's only
    kept in storage, handles its sdata and does the required syncing and
    calls).

    Every entity prototype needs a name. You need to specify a unique one as
    the `name` member of the prototype (see the code). Typically, the name will
    be the same with the name of the actual prototype variable.

    The base entity prototype has two basic properties.

    Properties:
        - tags [{{$svars.StateArray}}] - every entity can have an unlimited
        amount of tags (they're strings). You can use tags to search for
        entities later, other use cases include e.g. marking of player starts.
*/
Entity = Object.clone({
    name: "Entity",

    __storage: "logic",

    __attr_names: [],

    /**
        If this is true for the entity prototype, it will call the $__run method
        every frame. That is often convenient, but in most static entities
        undesirable. It's true by default.
    */
    __per_frame: true,

    /**
        Here you store the state variables. Every inherited entity prototype
        also inherits its parent's properties in addition to the newly
        defined ones. If you don't want any new properties in your
        entity prototype, do not create this table.
    */
    __properties: {
        tags: svars::StateArray()
    },

    /// Makes entity objects return their name on tostring.
    __tostring: func(self) {
        return self.name
    },

    /**
        Performs entity setup. Creates its action queue, caching tables,
        de-deactivates the entity, triggers svar setup and locks.
    */
    setup: func(self) {
        @[debug] log(DEBUG, "Entity: setup")

        if self.setup_complete { return }

        self.action_queue = actions::ActionQueue(self)
        // for caching
        self.svar_values, self.svar_value_timestamps = {}, {}
        // no longer deactivated
        self.deactivated = false

        // lock
        self.setup_complete = true
    },

    /**
        The default entity deactivator. Clears the action queue and deactivates
        the entity. On the server it also sends a message to all clients to do
        the same.
    */
    __deactivate: func(self) {
        self.clear_actions()
        self.deactivated = true
        if msg::is_server() {
            msg_le_rem_send(self, msg.ALL_CLIENTS)
        }
    },

    /**
        Called per frame unless $__per_frame is false. All inherited prototypes
        must call this in their own overrides. The argument specifies how
        long to manage the action queue (how much will the counters change
        internally), specified in milliseconds.
    */
    __run: func(self, millis) {
        self.action_queue.run(millis)
    },

    /// Enqueues an action into the entity's queue. Returns the action.
    enqueue_action: func(self, act) {
        self.action_queue.enqueue(act)
        return act
    },

    /// Clears the entity's action queue.
    clear_actions: func(self) {
        self.action_queue.clear()
    },

    /**
        Tags an entity. Modifies the `tags` property. Checks for existence
        of the tag first.
    */
    add_tag: func(self, tag) {
        if !self.has_tag(tag) {
            self.get_attr("tags").push(tag)
            self.update_attr("tags")
        }
    },

    /// Removes the given tag. Checks for its existence first.
    remove_tag: func(self, tag) {
        @[debug] log(DEBUG, e"Entity: remove_tag ($tag)")

        if !self.has_tag(tag) { return }
        self.set_attr("tags", self.get_attr("tags").filter(\t -> t != tag))
    },

    /**
        Checks if the entity is tagged with the given tag. Returns true if
        found, false if not found.
    */
    has_tag: func(self, tag) {
        @[debug] log(DEBUG, e"Entity: has_tag ($tag)")
        return self.get_attr("tags").find(tag) != undef
    },

    /**
        Builds sdata (state data, property mappings) from the properties the
        entity has.

        Kwargs:
            - target_cn [undef] - the client number to check state variables
            against (see <StateVariable.should_send>). If that is undef,
            no checking happens and stuff is done for all clients.
            - compressed [false] - if true, this function will return the
            sdata in a serialized format (string) with names converted
            to protocol IDs, otherwise raw table.
    */
    build_sdata: func(self, kwargs) {
        kwargs = kwargs || {}
        var tcn, comp
        if !kwargs {
            tcn, comp = msg.ALL_CLIENTS, false
        } else {
            tcn, comp = kwargs.target_cn || msg.ALL_CLIENTS,
                        kwargs.compressed || false
        }
        var ignore = kwargs.ignore

        @[debug] log(DEBUG, e"Entity.build_sdata: $tcn, $(tostring(comp))")

        var r, sn = {}, self.name
        for k, svar in pairs(self.__proto) {
            if svars::is_svar(svar) && (!ignore || !ignore[svar.name])
            && svar.has_history && !(tcn >= 0 && !svar.should_send(self, tcn)) {
                var name = svar.name
                var val = self.get_attr(name)
                if val != undef {
                    var wval = svar.to_serializable(val)
                    @[debug] log(DEBUG, e"    adding $name: $(tostring(wval))")
                    var key = (!comp) && name || svar.index
                    r[key] = wval
                    @[debug] log(DEBUG, e"    currently $(serialize(r))")
                }
            }
        }

        @[debug] log(DEBUG, e"Entity.build_sdata result: $(serialize(r))")
        if !comp {
            return r
        }

        r = mp_pack(r, mp_opts)
        @[debug] log(DEBUG, e"Entity.build_sdata compressed done")
        return r
    },

    /// Updates the complete state data on an entity from serialized input.
    set_sdata_full: func(self, sdata) {
        @[debug] log(DEBUG, e"Entity.set_sdata_full: $(self.uid), $sdata")

        var raw
        if typeof sdata == "table" {
            raw = sdata
        } else {
            raw = mp_unpack(sdata)
            var tp = typeof raw
            if tp != "table" {
                raise "invalid full sdata received (table expected, got $tp)"
            }
        }

        self.initialized = true

        var sn = self.name
        for k, v in pairs(raw) {
            var kpid = tonumber(k)
            k = kpid && self.__property_names[kpid] || k
            @[debug] log(DEBUG, e"    $k = $(tostring(v))")
            var sv = self["_SV_" ~ k]
            self.set_sdata(k, v, undef, true)
            @[debug] log(DEBUG, "    ... done.")
        }
        @[debug] log(DEBUG, "Entity.set_sdata_full: complete")
    },

    /** Function: __init_svars
        Initializes the entity before activation on the server. It's
        used to set default svar values (unless `client_set`).

        Arguments:
             - kwargs - extra data passed to init, unused here.
             - ndata - an array of extra newent arguments in wire format.
    */
    __init_svars: func(self, kwargs, ndata) {
        @[debug] log(DEBUG, "Entity.__init_svars")
        self.setup()
        self.initialized = true
        self.set_attr("tags", [])
    },

    /**
        The entity activator. It's called on its creation. It calls
        $setup. Static entities use a different variant.

        Client note: The entity is not initialized before complete
        sdata is received.

        On the server, the kwargs are queried for sdata and
        a $set_sdata_full happens.
    */
    __activate: func(self, kwargs) {
        @[debug] log(DEBUG, "Entity.__activate")
        if !self.sauer_type {
            @[debug] log(DEBUG, "Entity.__activate: non-sauer entity: "
                e"$(self.name)")
        }
        self.setup()
        self.initialized = msg::is_server()
        if msg::is_server() {
            var sd = kwargs && kwargs.state_data || undef
            if sd { self.set_sdata_full(sd) }
            self.send_notification_full(msg.ALL_CLIENTS)
            self.sent_notification_full = true
        }
    },

    /**
        Triggered automatically right before the `,changed` signal. It first
        checks if there is a setter function for the given svar and does
        nothing if there isn't, otherwise triggers the setter.

        Arguments:
            - svar - the state variable.
            - name - the state variable name.
            - val - the value to set.
    */
    sdata_changed: func(self, svar, name, val) {
        var sfun = svar.setter_fun
        if !sfun { return }
        var srv = svar.client_cb && msg::is_server_only()
        if srv { return }
        @[debug] log(INFO, e"Calling setter function for $name")
        val = svar.to_storage(val)
        self.__sdata_call_cb_set(sfun, val)
        @[debug] log(INFO, "Setter called")
        self.svar_values[name] = val
        self.svar_value_timestamps[name] = frame::get_frame()
        self.__sdata_post_call_cb_set()
    },

    set_sdata_server: func(self, svar, csfh, key, val, actor_uid, iop) {
        if actor_uid && actor_uid != -1 && !svar.client_write {
            log(ERROR, e"Entity.set_sdata: client $actor_uid tried to"
                e" change $key")
            return
        }

        self.sdata_changed(svar, key, val)
        self.emit(e"$key,changed", val, actor_uid)
        if self.sdata_update_cancel {
            self.sdata_update_cancel = undef
            return
        }

        self.svar_values[key] = svar.to_storage(val)
        @[debug] log(INFO, e"Entity.set_sdata: new sdata: $(tostring(val))")

        if !iop && svar.client_read && !csfh {
            if !self.sent_notification_full {
                return
            }

            var kid = svar.index
            var wval = mp_pack(svar.to_serializable(val), mp_opts)
            var acn = (svar.client_set && actor_uid && actor_uid != -1)
                && storage_dynamic[actor_uid].cn || msg.ALL_CLIENTS

            var cns = get_players().map(\p -> p.cn)
            for i, n in cns.each() {
                if actor_uid == n && svar.client_set {
                    continue
                }
                if svar.should_send(self, n) {
                    msg_sdata_update_send(self, n, svar.reliable,
                        kid, wval, acn)
                }
            }
        }
    },

    /** Function: set_sdata
        The entity state data setter. Has different variants for the client
        and the server.

        If this is on the client and the change didn't come from here (or if
        the property is `client_set`), it performs a var update. The local
        update first calls $sdata_changed and do triggers the `,changed`
        signal (before setting). The new value is passed to the signal
        during the emit along with a boolean equaling to `actor_uid != -1`.

        On the server it triggers a var change in the same manner.

        Keep in mind that this is overridden for static entities.

        Arguments:
            - key - the key.
            - val - the value.
            - actor_uid - unique ID of the change source. On the client, -1
              means it's the client itself, on the server it means all clients.
              If the change came from this client on the client and the entity
              doesn't use a custom syncing method, this sends a notification
              to the server.
            - iop - on the server, a boolean value, if it's true it makes
              this an internal server operaton (won't send to clients).
    */
    set_sdata: func(self, key, val, actor_uid, iop) {
        @[debug] log(DEBUG, e"Entity.set_sdata: $key = $(serialize(val)) for $(self.uid)")

        var svar = self[e"_SV_$key"]
        if !svar {
            log(WARNING, "Entity.set_sdata: ignoring sdata setting"
                e" for an unknown variable $key")
            return
        }

        var csfh = svar.custom_sync && self.controlled_here

        // either server or local client (in which case, behave like server)
        if msg::is_server() {
            return self.set_sdata_server(svar, csfh, key, val, actor_uid, iop)
        }

        // from client-side script, send a server request unless the svar
        // is controlled here (synced using some other method)
        // if this variable is set on the client, send a notification
        if actor_uid == -1 && !csfh {
            @[debug] log(DEBUG, "    sending server request/notification.")
            // TODO: supress sending of the same val, at least for some SVs
            msg_sdata_changereq_send(self, svar.reliable,
                svar.index, mp_pack(svar.to_serializable(val), mp_opts))
        }

        // from a server or set clientside, update now
        if actor_uid != -1 || svar.client_set || csfh {
            @[debug] log(INFO, "    var update")
            if !svar.validate(val) {
                raise e"received invalid value for svar $key ($(tostring(val)))"
            }
            self.sdata_changed(svar, key, val)
            self.emit(e"$key,changed", val, actor_uid != -1)
            self.svar_values[key] = svar.to_storage(val)
        }
    },

    /**
        Cancels a state data update (on the server). Useful when called
        from `,changed` signal slots.
    */
    cancel_sdata_update: func(self) {
        self.sdata_update_cancel = true
    },

    /** Function: send_notification_full
        On the server, sends a full notification to a specific client
        or all clients.
    */
    send_notification_full: func(self, cn) {
        var acn = msg.ALL_CLIENTS
        cn = cn || acn

        if cn != acn && self.cn == cn && self.sent_notification_full {
            return
        }

        var cns = (cn == acn) && get_players().map(\p -> p.cn) || [ cn ]

        var uid = self.uid
        @[debug] log(DEBUG, e"Entity.send_notification_full: $cn, $uid")

        var scn, sname = self.cn, self.name
        for i, n in cns.each() {
            msg_le_cn_send(self, n, scn && scn || acn, sname,
                self.build_sdata({ target_cn: n, compressed: true }))
        }

        @[debug] log(DEBUG, "Entity.send_notification_full: done")
    },

    /**
        Returns the next attached entity. This implementation doesn't {
        anything though - you need to overload it for your entity type
        accordingly. The core entity system doesn't manage attached
        entities at all. See also $get_attached_prev.
    */
    get_attached_next: func(self) {
    },

    /**
        Returns the previous attached entity. Like $get_attached_next,
        you need to overload this.
    */
    get_attached_prev: func(self) {
    },

    /**
        Given a GUI property name (`gui_name` or `name` if not defined in the
        svar), this returns the property value in a wire (string) format.

        See also:
            - $get_attr
            - $get_gui_attrs
            - $set_gui_attr
    */
    get_gui_attr: func(self, prop) {
        prop = self.attrnum_to_name(prop)
        var svar = self[e"_SV_GUI_$prop"]
        if !svar || !svar.has_history { return undef }
        var val = self.get_attr(svar.name)
        if val != undef {
            return svar.to_data(val)
        }
    },

    /**
        Like $get_gui_attr, but returns all available attributes as an
        array of key-value pairs. The second argument (defaults to true)
        specifies whether to sort the result by attribute name.
    */
    get_gui_attrs: func(self, sortattrs) {
        if sortattrs == undef { sortattrs = true }
        var r = []
        for k, svar in pairs(self) {
            if svars::is_svar(svar) && svar.has_history
            && svar.gui_name != false {
                var name = svar.name
                var val = self.get_attr(name)
                if val != undef {
                    r.push([ svar.gui_name || name, svar.to_data(val) ])
                }
            }
        }
        if sortattrs { r.sort(\a, b -> a[0] < b[0]) }
        return r
    },

    /**
        Given a GUI property name and a value in a wire format, this sets
        the property on the entity.

        See also:
            - $set_attr
            - $get_gui_attr
    */
    set_gui_attr: func(self, prop, val) {
        prop = self.attrnum_to_name(prop)
        var svar = self[e"_SV_GUI_$prop"]
        if !svar || !svar.has_history { return }
        self.set_attr(svar.name, svar.from_data(val))
    },

    /**
        Returns the entity property of the given name.

        See also:
            - $set_attr
            - $get_gui_attr
    */
    get_attr: func(self, prop) {
        prop = self.attrnum_to_name(prop)
        var svar = self[e"_SV_$prop"]
        if !svar { return undef }
        return svar::getter(self, svar)
    },

    /** Function: set_attr
        Sets the entity property of the given name to the given value.

        Arguments:
             - prop - the property name.
             - val - the value.
             - nd - optionally provides a non-wire default value that takes
               preference (if it's provided, it's converted from wire format
               and if that succeeds, it's used in place of the actual value).

        See also:
            - $get_attr
            - $set_gui_attr
    */
    set_attr: func(self, prop, val, nd) {
        prop = self.attrnum_to_name(prop)
        var svar = self[e"_SV_$prop"]
        if !svar { return }
        if nd != undef {
            var nw = svar.from_data(nd)
            if nw != undef { val = nw }
        }
        svar::setter(self, val, svar)
    },

    /// Updates an attribute.
    update_attr: func(self, prop) {
        var svar = self[e"_SV_$prop"]
        if !svar { return }
        svar::setter(self, svar::getter(self, svar), svar)
    },

    /**
        Increments an attribute by step. If step is not given, it uses
        either step defined by the state variable or 1 as a fallback.

        Returns undef on error (when it's not possible to increment) and
        the new value and the old value on success.
    */
    add_attr: func(self, prop, step) {
        prop = self.attrnum_to_name(prop)
        var svar = self[e"_SV_$prop"]
        if !svar { return undef }
        var step = step || svar.add_step || 1

        var val = svar::getter(self, svar)
        if typeof val != "number" { return undef }

        svar::setter(self, val + step, svar)
        return svar::getter(self, svar), val
    },

    /// Like $add_attr, but subtracts.
    sub_attr: func(self, prop, step) {
        prop = self.attrnum_to_name(prop)
        var svar = self[e"_SV_$prop"]
        if !svar { return undef }
        return self.add_attr(prop, -(step || svar.add_step || 1))
    },

    __sdata_call_cb_set: func(self, f, val) {
        f(self.uid, val)
    },

    __sdata_post_call_cb_set: func(self) {
    },

    __sdata_call_cb_get: func(self, f) {
        return f(self.uid)
    },

    __post_create_cb: func(self) {
    },

    /// Translates an attribute index (entity specific) to name.
    /// Returns the input unchanged if it's not a suitable index.
    attrnum_to_name: func(self, n) {
        return self.__attr_names[n] || n
    }
})
export Entity

externals::set("entity_get_gui_attr", @[!server,func(uid, prop) {
    return storage_static[uid].get_gui_attr(prop)
}])

externals::set("entity_set_gui_attr", @[!server,func(uid, prop, val) {
    return storage_static[uid].set_gui_attr(prop, val)
}])

externals::set("entity_get_attr_dyn", func(cn, prop) {
    var ent = storage_dynamic[cn]
    if !ent { return undef }
    return ent.get_attr(prop)
})
externals::set("entity_get_attr_ext", func(uid, prop) {
    var ent = storage_static[uid]
    if !ent { return undef }
    return ent.get_attr(prop)
})

externals::set("entity_set_attr", func(uid, prop, val) {
    var ent = storage_static[uid]
    if !ent { return undef }
    return ent.set_attr(prop, val)
})

externals::set("entity_add_attr", func(uid, prop, add) {
    var ent = storage_static[uid]
    if !ent { return }
    if add {
        ent.add_attr(prop)
    } else {
        ent.sub_attr(prop)
    }
})

externals::set("entity_draw_attached", func(uid) {
    var fent = storage_static[uid]
    if !fent { return undef }
    var ents = [ fent.get_attached_next() ]
    if !ents.empty() {
        for i, ent in ents.each() {
            capi::entity_draw_attachment(fent.uid, ent.uid)
        }
        return
    }
    ents = [ fent.get_attached_prev() ]
    if !ents.empty() {
        for i, ent in ents.each() {
            capi::entity_draw_attachment(ent.uid, fent.uid)
        }
    }
})

/** Function: entity_get_proto_name
    An external that returns the name of the prototype of the given entity.
*/
externals::set("entity_get_proto_name", func(uid) {
    var ent = storage_static[uid]
    if !ent { return undef }
    return ent.name
})

/** Function: render
    Main render hook. External as `game_render`. Calls individual `render`
    method on each entity (if defined). Clientside only. See also $render_hud.
*/
export var render = @[!server,func(tp, fpsshadow) {
    @[debug] log(INFO, "game_render")
    var player = player_entity
    if !player { return }

    for uid, entity in storage_dynamic.each() {
        if entity && !entity.deactivated {
            var rd = entity.__render
            // first arg to rd is hudpass, false because we aren't rendering
            // the HUD model, second is needhud, which is true if the model
            // should be shown as HUD model and that happens if we're not in
            // thirdperson and the current entity is the player
            // third is whether we're rendering a first person shadow
            if  rd {
                rd(entity, false, !tp && entity == player, fpsshadow)
            }
        }
    }
}]
externals::set("game_render", render)

/** Function: render_hud
    Renders the player HUD model if needed. External as `game_render_hud`.
    Clientside only. See also $render.
*/
export var render_hud = @[!server,func() {
    @[debug] log(INFO, "game_render_hud")
    var  player = player_entity
    if !player { return }

    if player.get_attr("hud_model_name") && !player.get_editing() {
        player.__render(true, true, false)
    }
}]
externals::set("game_render_hud", render_hud)

externals::set("entity_new_with_sd", func(cn, x, y, z, sd, nd, fuid, synced) {
    var cl = proto_storage[cn] || proto_storage[proto_aliases[cn]]
    if !cl {
        log(ERROR, e"no such entity prototype: $(tostring(cn))")
        return -1
    }
    if cl.__storage != "static" {
        log(ERROR, e"trying to create a non-static entity: $(tostring(cn))")
        return -1
    }
    var cent = false
    if fuid {
        var oent = storage_static[fuid]
        if oent {
            cent = !!oent.__has_centity
            oent.__has_centity = false
            remove(oent)
        }
    }
    var ent = add(cl, { position: { x: x, y: y, z: z },
        state_data: sd, newent_data: nd, prev_c_entity: cent, synced: synced }, fuid)
    @[debug] log(DEBUG, "Created entity: %d - %s (%f, %f, %f)"
        .format(ent.uid, cl, x, y, z))
    return ent.uid
})

externals::set("entity_new_with_cn", func(cl, cn) {
    var ent = add(cl, { cn: cn }, cn)
    assert(ent.cn == cn)
})


func send_stor(stor, cn) {
    for i, ent in stor.each() {
        if ent {
            ent.send_notification_full(cn)
        }
    }
}

/** Function: send
    Notifies a client of the number of entities on the server and {
    send a complete notification for each of them. Takes the client number.
    Works only serverside. External as `entities_send_all`.
*/
export func send(cn) {
    @[debug] log(DEBUG, e"Sending active entities to $cn")
    var estor = []
    send_stor(storage_logic, cn)
    send_stor(storage_dynamic, cn)
}
externals::set("entities_send_all", send)

frame::add_callback(func(millis) {
    for uid, ent in storage_logic.each() {
        if ent && !ent.deactivated && ent.__per_frame {
            ent.__run(millis)
        }
    }
    @[!server] for uid, ent in storage_static.each() {
        if ent && !ent.deactivated && ent.__per_frame {
            ent.__run(millis)
        }
    }
    for uid, ent in storage_dynamic.each() {
        if ent && !ent.deactivated && ent.__per_frame {
            ent.__run(millis)
        }
    }
})