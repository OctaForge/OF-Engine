/**<
    Implements basic entity handling, that is, storage, entity prototype management
    and the basic entity prototypees; the other extended entity types have their
    own modules.

    Author:
        q66 <quaker66@gmail.com>

    License:
        See COPYING.txt.
*/

import std.ffi

import capi
import core.logger as logging

var log = logging.log
var DEBUG   = logging.DEBUG
var INFO    = logging.INFO
var ERROR   = logging.ERROR
var WARNING = logging.WARNING

import core.network.msg
import core.events.frame
import core.events.actions
import core.events.signal
import core.entities.svars
import core.engine.cubescript as cs
import core.engine.model

from core.octascript.messagepack import pack as mp_pack, unpack as mp_unpack
var mp_opts = { "number": "float" }

from core.externals import set as set_external

var emit = signal.emit

from std.object import Object
from std.table import pairs
from std.math import max, floor
from std.conv import tonumber, tostring, serialize, deserialize
from std.util import assert

/// Module: ents
var M = {}

var Entity

// clientside only
var player_entity

// basic storage for entities, keys are unique ids and values are entities
var storage_logic = []
var storage_dynamic = []
@[!server] var storage_static = []

// stores all registered entity prototypees
var proto_storage = {}

// aliases
var proto_aliases = {}

/*
    Stores mapping of state variable names and the associated ids, which
    are used for network transfers; numbers take less space than names,
    so they take less time to transfer.
    {
        entity_proto_name1 = {
            state_variable_name1 = id1,
            state_variable_name2 = id2,
            state_variable_namen = idn
        },
        entity_proto_name2 = ...
        entity_proto_namen = ...
    }
*/
var names_to_ids = {}

// see above, used for back-translation
var ids_to_names = {}

var is_svar, is_svar_alias = svars.is_svar, svars.is_svar_alias

var cent_storage = {}

var iptr = ffi["typeof"]("intptr_t")
var cent_to_addr = func(cent) {
    return tonumber(ffi::cast(iptr, cent))
}

M.get_by_centity = func(cent) {
    return cent_storage[cent_to_addr(cent)]
}
M.set_centity = func(cent, ent) {
    cent_storage[cent_to_addr(cent)] = ent
}
var get_by_centity = M.get_by_centity

/**
    Generates the required network data for an entity prototype. You pass the
    entity prototype name and an array of state variable names to generate network
    data for.
*/
M.gen_network_data = func(cn, names) {
    @[debug] log(DEBUG, e"ents.generate_network_data: $cn")
    names.sort()

    var ntoi, iton = {}, {}
    for id, name in names.each() {
        ntoi[name], iton[id + 1] = tostring(id + 1), name
    }

    names_to_ids[cn], ids_to_names[cn] = ntoi, iton
}
var gen_network_data = M.gen_network_data

/**
    If an entity prototype name is provided, clears the network data generated
    by $gen_network_data for the entity prototype. Otherwise clears it all.
*/
M.clear_network_data = func(cn) {
    if cn == undef {
        @[debug] log(DEBUG, "ents.clear_network_data")
        names_to_ids, ids_to_names = {}, {}
    } else {
        @[debug] log(DEBUG, e"ents.clear_network_data: $cn")
        names_to_ids[cn], ids_to_names[cn] = undef, undef
    }
}

var plugin_slots = [
    "__init_svars", "__activate", "__deactivate", "__run", "__render"
]

var modprefix = "_PLUGINS_"

var register_plugins = func(cl, plugins, name) {
    @[debug] log(DEBUG, "ents.register_prototype: registering plugins")
    var cldata = {}
    var properties

    var clmeths = cl["__plugin_methods"] || []
    for i, v in plugin_slots.each() { clmeths.push(v) }
    var clmethset = {}
    for i, v in clmeths.each() { clmethset[v] = true }

    var clname = cl.name
    for i, slot in clmeths.each() {
        var slotname = modprefix ~ clname ~ slot
        assert(!cl[slotname])

        var cltbl = [ cl[slot] ]
        for j, plugin in plugins.each() {
            var sl = plugin[slot]
            var tp = typeof sl
            if sl && tp == "function" || tp == "table" || tp == "userdata"
            { cltbl.push(sl) }
        }

        if !(cltbl.empty() || (cltbl.len() == 1 && cltbl[0] == cl[slot])) {
            cldata[slotname] = cltbl
            cldata[slot] = func(...) {
                for i, fn in cltbl.each() { fn(...) }
            }
        }
    }

    for i, plugin in plugins.each() {
        for name, elem in pairs(plugin) {
            if !clmethset[name] {
                if name == "__properties" {
                    assert(typeof elem == "table")
                    if !properties {
                        properties = elem
                    } else {
                        for propn, propv in pairs(elem) {
                            properties[propn] = propv
                        }
                    }
                } else {
                    cldata[name] = elem
                }
            }
        }
    }

    var ret = cl.clone(cldata)
    ret.name               = name
    ret.__properties       = properties
    ret.__raw_ent_proto    = cl
    ret.__parent_ent_proto = cl.__proto
    ret.__plugins          = plugins
    return ret
}

/**
    Registers an entity prototype. The registered prototype is always a clone
    of the given prototype. You can access the original prototype via the
    `__raw_ent_proto` member of the new clone. You can access the parent of
    `__raw_ent_proto` using `__parent_ent_proto`. This also generates protocol
    data for its properties and registers these.

    Allows to provide an array of plugins to inject into the entity prototype
    (before the actual registration, so that the plugins can provide their own
    state variables).

    Because this is a special clone, do NOT derive from it. Instead derive
    from `__raw_ent_proto`. This function doesn't return anything for a reason.
    If you really need this special clone, use $get_prototype.

    A plugin is pretty much an associative table of things to inject. It
    can contain slots - those are functions or callable values with keys
    `__init_svars`, `__activate`, `__deactivate`, `__run`, `__render` - slots
    never override elements of the same name in the original prototype, instead
    they're called after it in the order of plugin array. Then it can contain
    any non-slot member, those are overriden without checking (the last plugin
    takes priority). Plugins can provide their own state variables via the
    `__properties` table, like entities. The `__properties` tables of plugins
    are all merged together and the last plugin takes priority.

    The original plugin array is accessible from the clone as `__plugins`.

    Note that plugins can NOT change the entity prototype name. If any such
    element is found, it's ignored.

    Arguments:
        - cl - the entity prototype.
        - plugins - an optional array of plugins (or name).
        - name - optional entity prototype name, if not provided the `name`
          field of the entity prototype name is used; it can also be the second
          argument if you are not providing plugins.
*/
M.register_prototype = func(cl, plugins, name) {
    if !name {
        if typeof plugins == "string" {
            name, plugins = plugins, undef
        } else {
            name = cl.name
        }
    }
    assert(name)

    @[debug] log(DEBUG, e"ents.register_prototype: $name")

    assert(!proto_storage[name],
        "an entity prototype with the same name already exists")

    if plugins {
        cl = register_plugins(cl, plugins, name)
    } else {
        cl = cl.clone({
            name: name,
            __raw_ent_proto: cl,
            __parent_ent_proto: cl.__proto
        })
    }

    proto_storage[name] = cl
    proto_aliases[name.lower()] = name

    // table of properties
    var pt = {}
    var sv_names = []

    var base = cl
    while base {
        var props = base.__properties
        if props {
            for n, v in pairs(props) {
                if !pt[n] && svars::is_svar(v) {
                    pt[n] = v
                    sv_names.push(n)
                }
            }
        }
        if base == Entity { break }
        base = base.__proto
    }

    sv_names.sort(func(n, m) {
        if is_svar_alias(pt[n]) && !is_svar_alias(pt[m]) {
            return false
        }
        if !is_svar_alias(pt[n]) && is_svar_alias(pt[m]) {
            return true
        }
        return n < m
    })

    @[debug] log(DEBUG, "ents.register_prototype: generating protocol data for "
        e"{ $(sv_names.concat(', ')) }")

    gen_network_data(name, sv_names)

    @[debug] log(DEBUG, "ents.register_prototype: registering state variables")
    for i, name in sv_names.each() {
        var svar = pt[name]
        @[debug] log(DEBUG, e"    $name ($(svar.name))")
        svar.register(name, cl)
    }

    cl.__instances = []
}

/**
    Returns the entity prototype with the given name. If it doesn't exist,
    logs an error message and returns undef.

    Use with caution!See $register_prototype for the possible dangers of
    using this. It's still useful sometimes, so it's in the API.
*/
M.get_prototype = func(cn) {
    var  t = proto_storage[cn] || proto_storage[proto_aliases[cn]]
    if !t {
        log(ERROR, e"ents.get_prototype: invalid prototype $cn")
    }
    return t
}

/**
    Returns the internal entity prototype storage (name->prototype mapping),
    use with care.
*/
M.get_all_prototypes = func() {
    return proto_storage
}

/**
    Retrieves a logic entity, given its unique id. If not found, undef.
*/
M.get_logic = func(uid) {
    var r = storage_logic[uid]
    if !r {
        @[debug] log(DEBUG, e"ents.get_logic: no such entity ($uid)")
    }
    return r
}
M.get_dynamic = func(uid) {
    var r = storage_dynamic[uid]
    if !r {
        @[debug] log(DEBUG, e"ents.get_dynamic: no such entity ($uid)")
    }
    return r
}
M.get_static = @[!server,func(uid) {
    var r = storage_static[uid]
    if !r {
        @[debug] log(DEBUG, e"ents.get_static: no such entity ($uid)")
    }
    return r
}]

var get_by_tag = func(tag, stor) {
    var r = []
    for i, ent in stor.each() {
        if ent && ent.has_tag(tag) {
            r.push(ent)
        }
    }
    return r
}

/// Returns an array of entities with a common tag.
M.get_logic_by_tag = func(tag) { return get_by_tag(tag, storage_logic) }
M.get_dynamic_by_tag = func(tag) { return get_by_tag(tag, storage_dynamic) }
M.get_static_by_tag = @[!server,func(tag) { return get_by_tag(tag, storage_static) }]

/// Returns an array of entities with a common prototype.
M.get_by_prototype = func(cl) {
    var v = proto_storage[cl]
    return v ? v.__instances : []
}

var player_prototype = "Player"

/// Sets the player prototype (by name).
M.set_player_prototype = func(cl) {
    player_prototype = cl
}

var vg = cs.var_get

/// Gets an array of players (all of the currently set player prototype).
M.get_players = func() {
    var v = proto_storage[player_prototype]
    return v ? v.__instances : []
}
var get_players = M.get_players

/// Gets the current player, clientside only.
M.get_player = @[!server,func() {
    return player_entity
}]

M.__set_player = func(pl) { player_entity = pl }

set_external("entity_get_player_prototype", func() {
    return player_prototype
})

var storages = {
    logic: storage_logic,
    dynamic: storage_dynamic,
    static: @[!server,storage_static],
}

/**
    Inserts an entity of the given prototype or prototype name into the storage.
    The entity will get assigned an uid and activated. Kwargs will be passed
    to the activation calls and init call on the server. If `new` is true,
    `__init_svars` method will be called on the server on the entity instead
    of just assigning an uid. That means it's a newly created entity. Sometimes
    we don't want this behavior, for example when loading an entity from a
    file.
*/
var add = func(cn, uid, kwargs, new) {
    var cl = typeof cn == "table" && cn || (proto_storage[cn]
                                        ||  proto_storage[proto_aliases[cn]])
    if !cl {
        log(ERROR, e"ents.add: no such entity prototype: $(tostring(cn))")
        assert(false)
    }

    var cstor = cl.__storage
    var stor = storages[cstor]
    assert(stor)

    if !uid {
        /* try to reuse indexes (TODO: cache unused indexes for better perf) */
        for i, v in stor.each() {
            if !v {
                uid = i
                break
            }
        }
        /* no free slot, no worries - we just add new */
    }

    uid = uid || stor.len()
    if uid >= stor.len() {
        stor.resize(uid + 1)
    }

    @[debug] log(DEBUG, e"ents.add: $(cl.name) ($uid)")
    assert(!stor[uid])

    var r = cl()
    r.uid = uid
    stor[uid] = r
    r.__fully_created = false

    // caching
    cl.__instances.push(r)

    if @[server,new,new && msg::is_local()] {
        var ndata
        if kwargs {
            ndata = kwargs.newent_data
            kwargs.newent_data = undef
            if ndata { ndata = deserialize(ndata) }
        }
        r.__init_svars(kwargs, ndata || [])
    }

    @[debug] log(DEBUG, "ents.add: activate")
    r.__activate(kwargs)
    @[debug] log(DEBUG, "ents.add: activated")
    r.__fully_created = true
    r.__post_create_cb(!!@[server,new,new && msg::is_local()], kwargs)
    return r
}
M.add = add

/**
    Removes an entity. First emits the `pre_deactivate` signal on it, then
    deactivates it and do clears it out from both storages.

    See also:
        - $remove_all
*/
M.remove = func(ent) {
    var uid = ent.uid
    @[debug] log(DEBUG, e"ents.remove: $uid")
    var stor = storages[ent.__storage]
    emit(ent, "pre_deactivate")
    ent.__deactivate()
    ent.__proto.__instances.compact(\v -> v != ent)
    stor[uid] = undef
}
var ent_remove = M.remove

set_external("entity_remove_static", @[!server,func(uid) {
    var ent = storage_static[uid]
    if !ent { return }
    ent_remove(ent)
}])

set_external("entity_remove_dynamic", func(uid) {
    var ent = storage_dynamic[uid]
    if !ent { return }
    ent_remove(ent)
})

set_external("entity_clear_actions", func(cent) {
    var ent = get_by_centity(cent)
    if !ent { return }
    ent.clear_actions()
})

set_external("entity_is_initialized", func(cent) {
    var ent = get_by_centity(cent)
    if !ent { return false }
    return ent.initialized
})

var remove_stor = func(stor, protos) {
    for i, e in stor.each() {
        if e {
            protos[e.name] = true
            emit(e, "pre_deactivate")
            e.__deactivate()
            stor[i] = undef
        }
    }
}

/**
    Removes all entities from both storages. It's equivalent to looping
    over the whole storage and removing each entity individually, but
    much faster. External as `entities_remove_all`.

    See also:
        - $remove
*/
M.remove_all = func(stat) {
    var protos = {}
    if (!stat) {
        remove_stor(storage_logic, protos)
        remove_stor(storage_dynamic, protos)
    } else {
        @[!server] remove_stor(storage_static, protos)
    }
    for nm, v in pairs(protos) {
        proto_storage[nm].__instances = []
    }
}
set_external("entities_remove_all", M.remove_all)

set_external("entities_load", @[!server,func(entstr) {
    var entities, err = []
    if !entstr {
        @[debug] log(DEBUG, "entities_load: nothing to read")
    } else {
        entities, err = deserialize(entstr)
    }

    @[debug] log(DEBUG, "entities_load: loading all entities")
    for i, e in entities.each() {
        var cn = e[0]
        @[debug] log(DEBUG, e"    $i, $cn")
        add(cn, undef, { state_data: mp_pack(e[1], mp_opts) })
    }
    @[debug] log(DEBUG, "entities_load: done")
}])

/**
    Serializes all loaded entities into format that can be read by $load.
    External as `entities_save_all`.
*/
M.save = @[!server,func() {
    var r = []
    @[debug] log(DEBUG, "ents.save: saving")

    for uid, entity in storage_static.each() {
        if entity {
            var en = entity.name
            @[debug] log(DEBUG, e"    $uid, $en")
            r.push(serialize([ en, entity.build_sdata() ]))
        }
    }

    @[debug] log(DEBUG, "ents.save: done")
    return e"[\n$(r.concat(",\n"))\n]\n"
}]
set_external("entities_save_all", M.save)

var srnopos = { "position": true }
set_external("entity_serialize", func(cent, nopos) {
    var ent = get_by_centity(cent)
    if !ent { return }
    var ignore = nopos ? srnopos : undef
    var sr = ent.build_sdata({ compressed: true, ignore: ignore })
    return ent.name, sr, sr.len()
})

var storid = enum {
    logic: 1 << 29,
    dynamic: 1 << 30,
    static: 1 << 31
}
var uidmask = 0x1FFFFFFF

var get_stor_uid = func(uid) {
    var ruid = uid & uidmask
    var sid = uid & (~uidmask)
    if sid == storid.logic {
        return ruid, storage_logic
    } else if sid == storid.dynamic {
        return ruid, storage_dynamic
    } else if @[!server,sid == storid.static] {
        @[!server] return ruid, storage_static
    } else {
        assert(false)
    }
}

var make_stor_uid = func(uid, stor) {
    return (uid & uidmask) | storid[stor]
}

/**
    The base entity prototype. Every other entity prototype inherits from this.
    This prototype is fully functional, but it has no physical form (it's only
    kept in storage, handles its sdata and does the required syncing and
    calls).

    Every entity prototype needs a name. You need to specify a unique one as
    the `name` member of the prototype (see the code). Typically, the name will
    be the same with the name of the actual prototype variable.

    The base entity prototype has two basic properties.

    Properties:
        - tags [{{$svars.StateArray}}] - every entity can have an unlimited
        amount of tags (they're strings). You can use tags to search for
        entities later, other use cases include e.g. marking of player starts.
*/
M.Entity = Object.clone({
    name: "Entity",

    __storage: "logic",

    /**
        If this is true for the entity prototype, it will call the $__run method
        every frame. That is often convenient, but in most static entities
        undesirable. It's true by default.
    */
    __per_frame: true,

    /**
        Here you store the state variables. Every inherited entity prototype
        also inherits its parent's properties in addition to the newly
        defined ones. If you don't want any new properties in your
        entity prototype, do not create this table.
    */
    __properties: {
        tags: svars::StateArray()
    },

    /// Makes entity objects return their name on tostring.
    __tostring: func(self) {
        return self.name
    },

    /**
        Performs entity setup. Creates its action queue, caching tables,
        de-deactivates the entity, triggers svar setup and locks.
    */
    setup: func(self) {
        @[debug] log(DEBUG, "Entity: setup")

        if self.setup_complete { return }

        self.action_queue = actions::ActionQueue(self)
        // for caching
        self.svar_values, self.svar_value_timestamps = {}, {}
        // no longer deactivated
        self.deactivated = false

        // lock
        self.setup_complete = true
    },

    /**
        The default entity deactivator. Clears the action queue and deactivates
        the entity. On the server it also sends a message to all clients to do
        the same.
    */
    __deactivate: func(self) {
        self.clear_actions()
        self.deactivated = true
        @[server] {
            self.msg_le_rem_send(msg.ALL_CLIENTS, self.uid)
        }
    },

    /**
        Called per frame unless $__per_frame is false. All inherited prototypes
        must call this in their own overrides. The argument specifies how
        long to manage the action queue (how much will the counters change
        internally), specified in milliseconds.
    */
    __run: func(self, millis) {
        self.action_queue.run(millis)
    },

    /// Enqueues an action into the entity's queue. Returns the action.
    enqueue_action: func(self, act) {
        self.action_queue.enqueue(act)
        return act
    },

    /// Clears the entity's action queue.
    clear_actions: func(self) {
        self.action_queue.clear()
    },

    /**
        Tags an entity. Modifies the `tags` property. Checks for existence
        of the tag first.
    */
    add_tag: func(self, tag) {
        if !self.has_tag(tag) {
            self.get_attr("tags").push(tag)
        }
    },

    /// Removes the given tag. Checks for its existence first.
    remove_tag: func(self, tag) {
        @[debug] log(DEBUG, e"Entity: remove_tag ($tag)")

        if !self.has_tag(tag) { return }
        self.set_attr("tags", self.get_attr("tags").filter(\t -> t != tag))
    },

    /**
        Checks if the entity is tagged with the given tag. Returns true if
        found, false if not found.
    */
    has_tag: func(self, tag) {
        @[debug] log(DEBUG, e"Entity: has_tag ($tag)")
        return self.get_attr("tags").to_array().find(tag) != undef
    },

    /**
        Builds sdata (state data, property mappings) from the properties the
        entity has.

        Kwargs:
            - target_cn [undef] - the client number to check state variables
            against (see <StateVariable.should_send>). If that is undef,
            no checking happens and stuff is done for all clients.
            - compressed [false] - if true, this function will return the
            sdata in a serialized format (string) with names converted
            to protocol IDs, otherwise raw table.
    */
    build_sdata: func(self, kwargs) {
        kwargs = kwargs || {}
        var tcn, comp
        if !kwargs {
            tcn, comp = msg.ALL_CLIENTS, false
        } else {
            tcn, comp = kwargs.target_cn || msg.ALL_CLIENTS,
                        kwargs.compressed || false
        }
        var ignore = kwargs.ignore

        @[debug] log(DEBUG, e"Entity.build_sdata: $tcn, $(tostring(comp))")

        var r, sn = {}, self.name
        for k, svar in pairs(self.__proto) {
            if is_svar(svar) && (!ignore || !ignore[svar.name])
            && svar.has_history && !(tcn >= 0 && !svar.should_send(self, tcn)) {
                var name = svar.name
                var val = self.get_attr(name)
                if val != undef {
                    var wval = svar.to_serializable(val)
                    @[debug] log(DEBUG, e"    adding $name: $wval")
                    var key = (!comp) && name
                        || tonumber(names_to_ids[sn][name])
                    r[key] = wval
                    @[debug] log(DEBUG, e"    currently $(serialize(r))")
                }
            }
        }

        @[debug] log(DEBUG, e"Entity.build_sdata result: $(serialize(r))")
        if !comp {
            return r
        }

        r = mp_pack(r, mp_opts)
        @[debug] log(DEBUG, e"Entity.build_sdata compressed done")
        return r
    },

    /// Updates the complete state data on an entity from serialized input.
    set_sdata_full: func(self, sdata) {
        @[debug] log(DEBUG, e"Entity.set_sdata_full: $(self.uid), $sdata")

        var raw = sdata.sub(0, 1) != "{" ? mp_unpack(sdata) : deserialize(sdata)
        assert(typeof raw == "table")

        self.initialized = true

        var sn = self.name
        for k, v in pairs(raw) {
            k = tonumber(k) && ids_to_names[sn][k] || k
            @[debug] log(DEBUG, e"    $k = $(tostring(v))")
            var sv = self["_SV_" ~ k]
            self.set_sdata(k, v, undef, true)
            @[debug] log(DEBUG, "    ... done.")
        }
        @[debug] log(DEBUG, "Entity.set_sdata_full: complete")
    },

    /** Function: entity_setup
        Takes care of a proper entity setup (calls $setup, inits the change
        queue and makes the entity initialized). Called by $__init_svars and
        $__activate.
    */
    entity_setup: @[server,func(self) {
        if !self.initialized {
            @[debug] log(DEBUG, "Entity.entity_setup: setup")
            self.setup()

            self.svar_change_queue = {}
            self.svar_change_queue_complete = false

            self.initialized = true
            @[debug] log(DEBUG, "Entity.entity_setup: setup complete")
        }
    }],

    /** Function: __init_svars
        Initializes the entity before activation on the server. It's
        used to set default svar values (unless `client_set`).

        Arguments:
             - kwargs - extra data passed to init, unused here.
             - ndata - an array of extra newent arguments in wire format.
    */
    __init_svars: func(self, kwargs, ndata) {
        @[debug] log(DEBUG, "Entity.__init_svars")
        @[!server] {
            if !msg::is_local() { return }
            self.setup()
            self.initialized = true
        } else {
            self.entity_setup()
        }
        self.set_attr("tags", [])
    },

    /**
        The entity activator. It's called on its creation. It calls
        $setup. Static entities use a different variant.

        Client note: The entity is not initialized before complete
        sdata is received.

        On the server, the kwargs are queried for sdata and
        a $set_sdata_full happens.
    */
    __activate: func(self, kwargs) {
        @[debug] log(DEBUG, "Entity.__activate")
        if !self.sauer_type {
            @[debug] log(DEBUG, "Entity.__activate: non-sauer entity: "
                e"$(self.name)")
        }
        @[server] {
            var sd = kwargs && kwargs.state_data || undef
            self.entity_setup()
            if !self.sauer_type {
                self.flush_queued_svar_changes()
            }
            if sd { self.set_sdata_full(sd) }
            self.send_notification_full(msg.ALL_CLIENTS)
            self.sent_notification_full = true
        } else {
            self.setup()
            self.initialized = msg::is_local()
        }
    },

    msgid_le_cn: msg::register(@[!server,func(tp, receiver, sender, p) {
        var ocnf = msg::buf_get_int(p)
        var ouid, stor = get_stor_uid(msg::buf_get_int(p))
        var oc   = msg::buf_get_string(p)
        var sd   = msg::buf_get_string(p)
        // retrieve ocn - first 7 bits only is client number
        var ocn = ocnf & 0x7F
        // if they differ, we're sending a player complete notification
        var ispl = ocnf != ocn
        var ent = stor[ouid]
        if ent == undef {
            ent = add(oc, ouid, (ocn >= 0) && { cn: ocn } || undef)
            if ent == undef {
                log(ERROR, "received an entity that cannot be created")
                return
            }
        } else {
            @[debug] log(DEBUG, e"existing entity $ouid, no need to create")
        }
        @[debug] log(DEBUG, e"updating state data with $sd")
        ent.set_sdata_full(sd)
        if ispl && stor == storage_dynamic {
            @[debug] log(DEBUG, e"initializing player with uid $ouid")
            player_entity = storage_dynamic[ouid]
            assert(player_entity)
            player_entity.controlled_here = true
        }
        capi::renderprogress(0, "receiving entities...")
    }]),

    msg_le_cn_send: func(self, cn, ocn, oc, sd) {
        // encode a flag that we're sending a complete notification for the
        // player; it's the 8th bit, first 7 is the client number (maxclients
        // is 128)
        var pl = ((cn == ocn) ? 1 : 0) << 7
        capi::msg_send(cn, -1, "riiiss", self.msgid_le_cn, ocn | pl,
            make_stor_uid(self.uid, self.__storage), oc, sd || "")
    },

    msgid_le_rem: msg::register(@[!server,func(tp, receiver, sender, p) {
        var uid, stor = get_stor_uid(msg::buf_get_int(p))
        ent_remove(stor[uid])
    }]),

    msg_le_rem_send: func(self, cn, uid) {
        capi::msg_send(cn, -1, "rii", self.msgid_le_rem,
            make_stor_uid(uid, self.__storage))
    },

    msgid_sdata_update: msg::register(@[!server,func(tp, receiver, sender, p) {
        var uid, stor = get_stor_uid(msg::buf_get_int(p))
        var kpid = msg::buf_get_int(p)
        var value = msg::buf_get_string(p)
        var ocn = msg::buf_get_int(p)
        @[debug] log(DEBUG, e"sdata_update: $uid, $kpid, $value")
        var ent = stor[uid]
        if ent {
            var key = ids_to_names[ent.name][kpid]
            @[debug] log(DEBUG, e"set_sdata: $uid, $kpid, $key")
            var sv = ent["_SV_" ~ key]
            ent.set_sdata(key, mp_unpack(value))
        }
    }]),

    msg_sdata_update_send: func(self, cn, reliable, uid, kpid, value, ocn) {
        capi::msg_send(cn, ocn, reliable ? "riiisi" : "iiisi",
            self.msgid_sdata_update, make_stor_uid(uid, self.__storage), kpid,
            value, ocn)
    },

    msgid_sdata_changereq: msg::register(@[server,func(tp, receiver, sender, p) {
        var uid, stor = get_stor_uid(msg::buf_get_int(p))
        var kpid = msg::buf_get_int(p)
        var value = msg::buf_get_string(p)
        @[debug] log(DEBUG, e"client $auid tried to change $kpid to value $value")
        var ent = stor[uid]
        if ent {
            var key = ids_to_names[ent.name][kpid]
            @[debug] log(DEBUG, e"set_sdata: $uid, $kpid, $key")
            var sv = ent["_SV_" ~ key]
            ent.set_sdata(key, mp_unpack(value), sender)
        }
    }]),

    msg_sdata_changereq_send: func(self, reliable, uid, kpid, value) {
        capi::msg_add(self.msgid_sdata_changereq, reliable ? "riis" : "iis",
            make_stor_uid(uid, self.__storage), kpid, value || "")
    },

    /**
        Triggered automatically right before the `,changed` signal. It first
        checks if there is a setter function for the given svar and does
        nothing if there isn't. Triggers a setter call on the client or on the
        server when there is no change queue and queues a change otherwise.

        Arguments:
            - svar - the state variable.
            - name - the state variable name.
            - val - the value to set.
    */
    sdata_changed: func(self, svar, name, val) {
        var sfun = svar.setter_fun
        if !sfun { return }
        if !@[server,self.svar_change_queue] {
            @[debug] log(INFO, e"Calling setter function for $name")
            self.__sdata_call_cb_set(sfun, val)
            @[debug] log(INFO, "Setter called")

            self.svar_values[name] = val
            self.svar_value_timestamps[name] = frame::get_frame()
        } else {
            self.queue_svar_change(name, val)
        }
    },

    /** Function: set_sdata
        The entity state data setter. Has different variants for the client
        and the server.

        If this is on the client and the change didn't come from here (or if
        the property is `client_set`), it performs a var update. The local
        update first calls $sdata_changed and do triggers the `,changed`
        signal (before setting). The new value is passed to the signal
        during the emit along with a boolean equaling to `actor_uid != -1`.

        On the server it triggers a var change in the same manner.

        Keep in mind that this is overridden for static entities.

        Arguments:
            - key - the key.
            - val - the value.
            - actor_uid - unique ID of the change source. On the client, -1
              means it's the client itself, on the server it means all clients.
              If the change came from this client on the client and the entity
              doesn't use a custom syncing method, this sends a notification
              to the server.
            - iop - on the server, a boolean value, if it's true it makes
              this an internal server operaton (won't send to clients).
    */
    set_sdata: @[!server,func(self, key, val, actor_uid) {
        @[debug] log(DEBUG, e"Entity.set_sdata: $key = $(serialize(val)) for $(self.uid)")

        var svar = self[e"_SV_$key"]
        var csfh = svar.custom_sync && self.controlled_here
        var cset = svar.client_set

        var nfh = actor_uid != -1

        var is_local = msg::is_local()

        // from client-side script, send a server request unless the svar
        // is controlled here (synced using some other method)
        // if this variable is set on the client, send a notification
        if !nfh && !csfh && !is_local {
            @[debug] log(DEBUG, "    sending server request/notification.")
            // TODO: supress sending of the same val, at least for some SVs
            self.msg_sdata_changereq_send(svar.reliable, self.uid,
                tonumber(names_to_ids[self.name][svar.name]),
                mp_pack(svar.to_serializable(val), mp_opts))
        }

        // from a server or set clientside, update now
        if nfh || cset || csfh || is_local {
            @[debug] log(INFO, "    var update")
            // TODO: avoid assertions
            assert(svar.validate(val))
            self.sdata_changed(svar, key, val)
            emit(self, e"$key,changed", val, nfh)
            self.svar_values[key] = val
        }
    },func(self, key, val, actor_uid, iop) {
        @[debug] log(DEBUG, e"Entity.set_sdata: $key = $(serialize(val)) for $(self.uid)")

        var svar = self[e"_SV_$key"]

        if !svar {
            log(WARNING, "Entity.set_sdata: ignoring sdata setting"
                e" for an unknown variable $key")
            return
        }

        if actor_uid && actor_uid != -1 {
            if !svar.client_write {
                log(ERROR, "Entity.set_sdata: client $actor_uid tried to"
                    e" change $key")
                return
            }
        }

        self.sdata_changed(svar, key, val)
        emit(self, e"$key,changed", val, actor_uid)
        if self.sdata_update_cancel {
            self.sdata_update_cancel = undef
            return
        }

        self.svar_values[key] = val
        @[debug] log(INFO, e"Entity.set_sdata: new sdata: $(tostring(val))")

        var csfh = svar.custom_sync && self.controlled_here
        if !iop && svar.client_read && !csfh {
            if !self.sent_notification_full {
                return
            }

            var kid = names_to_ids[self.name][key]
            var wval = mp_pack(svar.to_serializable(val), mp_opts)
            var acn = (svar.client_set && actor_uid && actor_uid != -1)
                && storage_dynamic[actor_uid].cn || msg.ALL_CLIENTS

            var cns = get_players().map(\p -> p.cn)
            for i, n in cns.each() {
                if svar.should_send(self, n) {
                    self.msg_sdata_update_send(n, svar.reliable, self.uid,
                        tonumber(kid), wval, acn)
                }
            }
        }
    }],

    /**
        Cancels a state data update (on the server). Useful when called
        from `,changed` signal slots.
    */
    cancel_sdata_update: func(self) {
        self.sdata_update_cancel = true
    },

    /** Function: send_notification_full
        On the server, sends a full notification to a specific client
        or all clients.
    */
    send_notification_full: @[server,func(self, cn) {
        var acn = msg.ALL_CLIENTS
        cn = cn || acn

        var cns = (cn == acn) && get_players().map(\p -> p.cn) || [ cn ]

        var uid = self.uid
        @[debug] log(DEBUG, e"Entity.send_notification_full: $cn, $uid")

        var scn, sname = self.cn, self.name
        for i, n in cns.each() {
            self.msg_le_cn_send(n, scn && scn || acn, sname,
                self.build_sdata({ target_cn: n, compressed: true }))
        }

        @[debug] log(DEBUG, "Entity.send_notification_full: done")
    }],

    /** Function: queue_svar_change
        Queues a svar change (Happens before full update, when the
        entity is being created). Server only.
    */
    queue_svar_change: @[server,func(self, key, val) {
        self.svar_change_queue[key] = val
    }],

    /** Function: flush_queued_svar_changes
        Flushes the SV change queue (applies all the changes). After this,
        there is no change queue anymore.
    */
    flush_queued_svar_changes: @[server,func(self) {
        var changes = self.svar_change_queue
        if !changes { return }
        self.svar_change_queue = undef

        for k, v in pairs(changes) {
            var rv = self.svar_values[k]
            @[debug] log(DEBUG, e"Entity: flushing queued svar change: $k == "
                e"$(tostring(v)) (real: $(tostring(rv)))")
            self.set_attr(k, rv)
        }

        self.svar_change_queue_complete = true
    }],

    /**
        Returns the next attached entity. This implementation doesn't {
        anything though - you need to overload it for your entity type
        accordingly. The core entity system doesn't manage attached
        entities at all. See also $get_attached_prev.
    */
    get_attached_next: func(self) {
    },

    /**
        Returns the previous attached entity. Like $get_attached_next,
        you need to overload this.
    */
    get_attached_prev: func(self) {
    },

    /**
        Given a GUI property name (`gui_name` or `name` if not defined in the
        svar), this returns the property value in a wire (string) format.

        See also:
            - $get_attr
            - $get_gui_attrs
            - $set_gui_attr
    */
    get_gui_attr: func(self, prop) {
        var svar = self[e"_SV_GUI_$prop"]
        if !svar || !svar.has_history { return undef }
        var val = self.get_attr(svar.name)
        if val != undef {
            return svar.to_data(val)
        }
    },

    /**
        Like $get_gui_attr, but returns all available attributes as an
        array of key-value pairs. The second argument (defaults to true)
        specifies whether to sort the result by attribute name.
    */
    get_gui_attrs: func(self, sortattrs) {
        if sortattrs == undef { sortattrs = true }
        var r = []
        for k, svar in pairs(self) {
            if is_svar(svar) && svar.has_history && svar.gui_name != false {
                var name = svar.name
                var val = self.get_attr(name)
                if val != undef {
                    r.push([ svar.gui_name || name, svar.to_data(val) ])
                }
            }
        }
        if sortattrs { r.sort(\a, b -> a[0] < b[0]) }
        return r
    },

    /**
        Given a GUI property name and a value in a wire format, this sets
        the property on the entity.

        See also:
            - $set_attr
            - $get_gui_attr
    */
    set_gui_attr: func(self, prop, val) {
        var svar = self[e"_SV_GUI_$prop"]
        if !svar || !svar.has_history { return }
        self.set_attr(svar.name, svar.from_data(val))
    },

    /**
        Returns the entity property of the given name.

        See also:
            - $set_attr
            - $get_gui_attr
    */
    get_attr: func(self, prop) {
        var fun = self[e"__get_$prop"]
        if fun { return fun(self) }
        return undef
    },

    /** Function: set_attr
        Sets the entity property of the given name to the given value.

        Arguments:
             - prop - the property name.
             - val - the value.
             - nd - optionally provides a non-wire default value that takes
               preference (if it's provided, it's converted from wire format
               and if that succeeds, it's used in place of the actual value).

        See also:
            - $get_attr
            - $set_gui_attr
    */
    set_attr: func(self, prop, val, nd) {
        if nd {
            var svar = self[e"_SV_$prop"]
            if svar {
                var nw = svar.from_data(nd)
                if nw != undef { val = nw }
            }
        }
        var fun = self[e"__set_$prop"]
        return fun && fun(self, val) || undef
    },

    __sdata_call_cb_set: func(self, f, val) {
        f(self.__centity, val)
    },

    __sdata_call_cb_get: func(self, f) {
        return f(self.__centity)
    },

    __post_create_cb: func(self) {
    }
})
Entity = M.Entity

/**
    See {{$Entity.get_gui_attr}}. Externally accessible as
    `entity_get_gui_attr` (using uid). See also $set_gui_attr.
*/
M.get_gui_attr = func(ent, prop) {
    return ent.get_gui_attr(prop)
}

set_external("entity_get_gui_attr", @[!server,func(cent, prop) {
    return get_by_centity(cent).get_gui_attr(prop)
}])

/**
    See {{$Entity.set_gui_attr}}. Externally accessible as
    `entity_set_gui_attr` (using uid). See also $get_gui_attr.
*/
M.set_gui_attr = func(ent, prop, val) {
    return ent.set_gui_attr(prop, val)
}
set_external("entity_set_gui_attr", @[!server,func(cent, prop, val) {
    return get_by_centity(cent).set_gui_attr(prop, val)
}])

/**
    See {{$Entity.get_attr}}. Externally accessible as `entity_get_attr`
    (using the uid). See also $set_attr.
*/
M.get_attr = func(ent, prop) {
    return ent.get_attr(prop)
}
set_external("entity_get_attr", func(cent, prop) {
    var ent = get_by_centity(cent)
    if !ent { return undef }
    return ent.get_attr(prop)
})

/**
    See {{$Entity.set_attr}}. Externally accessible as `entity_set_attr`
    (using the uid). See also $get_attr.
*/
M.set_attr = func(ent, prop, val) {
    return ent.set_attr(prop, val)
}

set_external("entity_draw_attached", func(cent) {
    var fent = get_by_centity(cent)
    if !fent { return undef }
    var ents = [ fent.get_attached_next() ]
    if !ents.empty() {
        for i, ent in ents.each() {
            capi::entity_draw_attachment(fent.__centity, ent.__centity)
        }
        return
    }
    ents = [ fent.get_attached_prev() ]
    if !ents.empty() {
        for i, ent in ents.each() {
            capi::entity_draw_attachment(ent.__centity, fent.__centity)
        }
    }
})

/** Function: entity_get_proto_name
    An external that returns the name of the prototype of the given entity.
*/
set_external("entity_get_proto_name", func(cent) {
    var ent = get_by_centity(cent)
    if !ent { return undef }
    return ent.name
})

/** Function: render
    Main render hook. External as `game_render`. Calls individual `render`
    method on each entity (if defined). Clientside only. See also $render_hud.
*/
M.render = @[!server,func(tp, fpsshadow) {
    @[debug] log(INFO, "game_render")
    var  player = player_entity
    if !player { return }

    for uid, entity in storage_dynamic.each() {
        if entity && !entity.deactivated {
            var rd = entity.__render
            // first arg to rd is hudpass, false because we aren't rendering
            // the HUD model, second is needhud, which is true if the model
            // should be shown as HUD model and that happens if we're not in
            // thirdperson and the current entity is the player
            // third is whether we're rendering a first person shadow
            if  rd {
                rd(entity, false, !tp && entity == player, fpsshadow)
            }
        }
    }
}]
var render = M.render
set_external("game_render", render)

/** Function: render_hud
    Renders the player HUD model if needed. External as `game_render_hud`.
    Clientside only. See also $render.
*/
M.render_hud = @[!server,func() {
    @[debug] log(INFO, "game_render_hud")
    var  player = player_entity
    if !player { return }

    if player.get_attr("hud_model_name") && !player.get_editing() {
        player.__render(true, true, false)
    }
}]
var render_hud = M.render_hud
set_external("game_render_hud", render_hud)

/** Function: scene_is_ready
    On the client, used to check if the current scene is ready and we can
    actually start (checks whether the player exists and whether all the
    entities are initialized). External as `scene_is_ready`.
*/
M.scene_is_ready = @[!server,func() {
    @[debug] log(INFO, "Scene ready?")

    if player_entity == undef {
        @[debug] log(INFO, "...!ready, player entity missing.")
        return false
    }

    @[debug] log(INFO, "...player ready, trying other entities.")
    for uid, ent in storage_logic.each() {
        if ent && !ent.initialized {
            @[debug] log(INFO, e"...logic entity $uid !ready.")
            return false
        }
    }
    for uid, ent in storage_dynamic.each() {
        if ent && !ent.initialized {
            @[debug] log(INFO, e"...dynamic entity $uid !ready.")
            return false
        }
    }

    @[debug] log(INFO, "...yes!")
    return true
}]
set_external("scene_is_ready", M.scene_is_ready)

/** Function: new
    Creates a new entity. External as `entity_new`.

    Arguments:
        - cl - the entity prototype.
        - kwargs - passed directly to $add.
        - fuid - optional forced unique ID, otherwise $gen_uid.

    Returns:
         The new entity.
*/
M.new = func(cl, kwargs, fuid) {
    return add(cl, fuid, kwargs, true)
}
var ent_new = M.new

set_external("entity_new_with_sd", func(cn, x, y, z, sd, nd, fuid) {
    var cl = proto_storage[cn] || proto_storage[proto_aliases[cn]]
    if !cl {
        log(ERROR, e"no such entity prototype: $(tostring(cn))")
        return
    }
    if cl.__storage != "static" {
        log(ERROR, e"trying to create a non-static entity: $(tostring(cn))")
        return
    }
    var cent
    if fuid {
        var oent = storage_static[fuid]
        if oent {
            cent = oent.__centity
            oent.__centity = undef
            ent_remove(oent)
        }
    }
    var ent = ent_new(cl, { position: { x: x, y: y, z: z },
        state_data: sd, newent_data: nd, c_entity: cent }, fuid)
    @[debug] log(DEBUG, "Created entity: %d - %s (%f, %f, %f)"
        .format(ent.uid, cl, x, y, z))
    return ent.uid
})

var created_cns = {}

set_external("entity_new_with_cn", func(cl, cn, can_edit, char_name) {
    if created_cns[cn] { return }
    var ent = ent_new(cl, { cn: cn }, cn)
    assert(ent.cn == cn)
    if can_edit { ent.set_attr("can_edit", can_edit) }
    ent.set_attr("character_name", char_name)
    created_cns[cn] = true
})


var send_stor = func(stor, cn) {
    for i, ent in stor.each() {
        if ent {
            ent.send_notification_full(cn)
        }
    }
}

/** Function: send
    Notifies a client of the number of entities on the server and {
    send a complete notification for each of them. Takes the client number.
    Works only serverside. External as `entities_send_all`.
*/
M.send = @[server,func(cn) {
    @[debug] log(DEBUG, e"Sending active entities to $cn")
    var estor = []
    send_stor(storage_logic, cn)
    send_stor(storage_dynamic, cn)
}]
set_external("entities_send_all", M.send)

M.run_frame = func(millis) {
    for uid, ent in storage_logic.each() {
        if ent && !ent.deactivated && ent.__per_frame {
            ent.__run(millis)
        }
    }
    @[!server] for uid, ent in storage_static.each() {
        if ent && !ent.deactivated && ent.__per_frame {
            ent.__run(millis)
        }
    }
    for uid, ent in storage_dynamic.each() {
        if ent && !ent.deactivated && ent.__per_frame {
            ent.__run(millis)
        }
    }
}

return M
