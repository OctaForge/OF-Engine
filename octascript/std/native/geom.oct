import std
import std.package

import std.ffi

from std.table import rawget, rawset, pairs
from std.math import sin, cos, abs, min, max, sqrt, floor, atan2, asin, deg

var gen_vec2 = func(tp, sf, mt) {
    ffi::cdef(r"""
        typedef struct __rt_vec2%s_t {
            %s x, y;
        } __rt_vec2%s_t;
    """.format(sf, tp, sf))
    return ffi::metatype("__rt_vec2" ~ sf ~ "_t", mt), mt
}

var gen_vec3 = func(tp, sf, mt) {
    ffi::cdef(r"""
        typedef union __rt_vec3%s_t {
            struct { %s x, y, z; };
            struct { %s r, g, b; };
        } __rt_vec3%s_t;
    """.format(sf, tp, tp, sf))
    return ffi::metatype("__rt_vec3" ~ sf ~ "_t", mt), mt
}

var gen_vec4 = func(tp, sf, mt) {
    ffi::cdef(r"""
        typedef union __rt_vec4%s_t {
            struct { %s x, y, z, w; };
            struct { %s r, g, b, a; };
        } __rt_vec4%s_t;
    """.format(sf, tp, tp, sf))
    return ffi::metatype("__rt_vec4" ~ sf ~ "_t", mt), mt
}

var ffi_new = ffi.new
var clamp = func(v, l, h) {
    return max(l, min(v, h))
}

var iton = { 0: "x", 1: "y", 2: "z" }

var M = {}

/**
    Normalizes an angle to be within +-180 degrees of some value.
    Useful to know if we need to turn left or right in order to be
    closer to something (we just need to check the sign, after normalizing
    relative to that angle).

    For example, for angle 100 and rel_to 300, this function returns 460
    (as 460 is within 180 degrees of 300, but 100 isn't).
*/
var normalize_angle = func(angle, rel_to) {
    while angle < (rel_to - 180.0) { angle = angle + 360.0 }
    while angle > (rel_to + 180.0) { angle = angle - 360.0 }
    return angle
}
M.normalize_angle = normalize_angle

var Vec2, Vec2_mt; Vec2, Vec2_mt = gen_vec2("float", "f", {
    __new: func(self, x, y) {
        if typeof x == "number" {
            if !y {
                return ffi_new(self, x, x)
            } else {
                return ffi_new(self, x, y)
            }
        } else {
            return ffi_new(self, x.x, x.y)
        }
    },
    __tostring: func(self) {
        return "Vec2 <%f, %f>".format(self.x, self.y)
    },
    __eq: func(self, o) { return self.equals(o) },
    __mul: func(self, o) { return self.mul_new(o) },
    __div: func(self, o) { return self.div_new(o) },
    __add: func(self, o) { return self.add_new(o) },
    __sub: func(self, o) { return self.sub_new(o) },
    __index: {
        equals: func(self, o) {
            return self.x == o.x && self.y == o.y
        },
        from_array: func(self, o) {
            return ffi_new(self, o[0], o[1])
        },
        copy: func(self) {
            return Vec2(self.x, self.y)
        },
        to_array: func(self) {
            return [ self.x, self.y ]
        },
        unpack: func(self) {
            return self.x, self.y
        },
        get_nth: func(self, n) { return self[iton[n - 1]] },
        set_nth: func(self, n, v) { self[iton[n - 1]] = v },
        is_zero: func(self) { return self.x == 0 && self.y == 0 },
        dot: func(self, o) { return self.x * o.x + self.y * o.y },
        dot_abs: func(self, o) {
            return abs(self.x * o.x) + abs(self.y * o.y)
        },
        squared_len: func(self) { return self.dot(self) },
        magnitude: func(self) { return sqrt(self.squared_len()) },
        normalize: func(self) {
            self.div(self.magnitude())
            return self
        },
        cross: func(self, o) { return self.x * o.y + self.y * o.x },
        square_dist: func(self, e) { return self.sub_new(e).squared_len() },
        dist: func(self, e) { return sqrt(self.square_dist(e)) },
        mul: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x * o, self.y * o
            } else {
                self.x, self.y = self.x * o.x, self.y * o.y
            }
            return self
        },
        square: func(self) {
            self.mul(self)
            return self
        },
        div: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x / o, self.y / o
            } else {
                self.x, self.y = self.x / o.x, self.y / o.y
            }
            return self
        },
        recip: func(self) {
            self.x = 1 / self.x
            self.y = 1 / self.y
            return self
        },
        add: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x + o, self.y + o
            } else {
                self.x, self.y = self.x + o.x, self.y + o.y
            }
            return self
        },
        sub: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x - o, self.y - o
            } else {
                self.x, self.y = self.x - o.x, self.y - o.y
            }
            return self
        },
        mul_new: func(self, o) {
            if typeof o == "number" {
                return Vec2(self.x * o, self.y * o)
            } else {
                return Vec2(self.x * o.x, self.y * o.y)
            }
        },
        div_new: func(self, o) {
            if typeof o == "number" {
                return Vec2(self.x / o, self.y / o)
            } else {
                return Vec2(self.x / o.x, self.y / o.y)
            }
        },
        add_new: func(self, o) {
            if typeof o == "number" {
                return Vec2(self.x + o, self.y + o)
            } else {
                return Vec2(self.x + o.x, self.y + o.y)
            }
        },
        sub_new: func(self, o) {
            if typeof o == "number" {
                return Vec2(self.x - o, self.y - o)
            } else {
                return Vec2(self.x - o.x, self.y - o.y)
            }
        },
        neg: func(self) {
            self.x, self.y = -self.x, -self.y
            return self
        },
        min: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = min(self.x, o), min(self.y, o)
            } else {
                self.x, self.y = min(self.x, o.x), min(self.y, o.y)
            }
            return self
        },
        max: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = max(self.x, o), max(self.y, o)
            } else {
                self.x, self.y = max(self.x, o.x), max(self.y, o.y)
            }
            return self
        },
        abs: func(self) {
            self.x, self.y = abs(self.x), abs(self.y)
            return self
        },
        clamp: func(self, l, h) {
            self.x, self.y = clamp(self.x, l, h), clamp(self.y, l, h)
            return self
        },
        reflect: func(self, n) {
            var k = 2 * self.dot(n)
            self.x -= k * n.x
            self.y -= k * n.y
            return self
        },
        lerp: func(self, a, b, t) {
            if !t { a, b, t = self, a, b }
            self.x, self.y = a.x + (b.x - a.x) * t,
                             a.y * (b.y - a.y) * t
            return self
        },
        avg: func(self, b) { return self.add(b).mul(0.5) },
        madd: func(self, a, b) { return self.add(a.mul_new(b)) },
        msub: func(self, a, b) { return self.sub(a.mul_new(b)) },
        rotate_around_z: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_z(cos(angle), sin(angle))
                } else {
                    var rx, ry = self.x, self.y
                    self.x, self.y = c * rx - s * ry, c * ry + s * rx
                    return self
                }
            } else {
                return self.rotate_around_z(c.x, c.y)
            }
        }
    }
})
M.Vec2 = Vec2

var Vec3, Vec3_mt; Vec3, Vec3_mt = gen_vec3("float", "f", {
    __new: func(self, x, y, z) {
        if typeof x == "number" {
            if !y && !z {
                return ffi_new(self, x, x, x)
            } else {
                return ffi_new(self, x, y, z)
            }
        } else {
            return ffi_new(self, x.x, x.y, x.z)
        }
    },
    __tostring: func(self) {
        return "Vec3 <%f, %f, %f>".format(self.x, self.y, self.z)
    },
    __eq: func(self, o) { return self.equals(o) },
    __mul: func(self, o) { return self.mul_new(o) },
    __div: func(self, o) { return self.div_new(o) },
    __add: func(self, o) { return self.add_new(o) },
    __sub: func(self, o) { return self.sub_new(o) },
    __index: {
        equals: func(self, o) {
            return self.x == o.x && self.y == o.y && self.z == o.z
        },
        from_array: func(self, o) {
            return ffi_new(self, o[0], o[1], o[2])
        },
        from_vec2: func(self, o, z) {
            return ffi_new(self, o.x, o.y, z || 0)
        },
        from_yaw_pitch: func(self, yaw, pitch) {
            return ffi_new(self,
                -sin(yaw) * cos(pitch),
                 cos(yaw) * cos(pitch),
                 sin(pitch))
        },
        from_hex_color: func(self, color) {
            return ffi_new(self, ((color >> 16) & 0xFF) / 255,
                                 ((color >>  8) & 0xFF) / 255,
                                  (color        & 0xFF) / 255)
        },

        copy: func(self) {
            return Vec3(self.x, self.y, self.z)
        },
        to_array: func(self) {
            return [ self.x, self.y, self.z ]
        },
        unpack2: func(self) {
            return self.x, self.y
        },
        unpack: func(self) {
            return self.x, self.y, self.z
        },
        get_nth: func(self, n) { return self[iton[n - 1]] },
        set_nth: func(self, n, v) { self[iton[n - 1]] = v },
        is_zero: func(self) {
            return self.x == 0 && self.y == 0 && self.z == 0
        },
        dot2: func(self, o) { return self.x * o.x + self.y * o.y },
        dot: func(self, o) {
            return self.x * o.x + self.y * o.y + self.z * o.z
        },
        dot_abs: func(self, o) {
            return abs(self.x * o.x) + abs(self.y * o.y) + abs(self.z * o.z)
        },
        dot_z: func(self, o) {
            return self.z * o.z
        },
        squared_len: func(self) { return self.dot(self) },
        magnitude2: func(self) { return sqrt(self.dot2(self)) },
        magnitude: func(self) { return sqrt(self.squared_len()) },
        normalize: func(self) { return self.div(self.magnitude()) },
        is_normalized: func(self) {
            var m = self.squared_len()
            return m > 0.99 && m < 1.01
        },
        mul: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x * o, self.y * o, self.z * o
            } else {
                self.x, self.y, self.z = self.x * o.x, self.y * o.y,
                    self.z * o.z
            }
            return self
        },
        mul2: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x * o, self.y * o
            } else {
                self.x, self.y = self.x * o.x, self.y * o.y
            }
            return self
        },
        square: func(self) {
            self.mul(self)
            return self
        },
        div: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x / o, self.y / o, self.z / o
            } else {
                self.x, self.y, self.z = self.x / o.x, self.y / o.y,
                    self.z / o.z
            }
            return self
        },
        div2: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x / o, self.y / o
            } else {
                self.x, self.y = self.x / o.x, self.y / o.y
            }
            return self
        },
        recip: func(self) {
            self.x = 1 / self.x
            self.y = 1 / self.y
            self.z = 1 / self.z
            return self
        },
        add: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x + o, self.y + o, self.z + o
            } else {
                self.x, self.y, self.z = self.x + o.x, self.y + o.y,
                    self.z + o.z
            }
            return self
        },
        add2: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x + o, self.y + o
            } else {
                self.x, self.y = self.x + o.x, self.y + o.y
            }
            return self
        },
        add_z: func(self, f) {
            self.z = self.z + f
            return self
        },
        sub: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x - o, self.y - o, self.z - o
            } else {
                self.x, self.y, self.z = self.x - o.x, self.y - o.y,
                    self.z - o.z
            }
            return self
        },
        sub2: func(self, o) {
            if typeof o == "number" {
                self.x, self.y = self.x - o, self.y - o
            } else {
                self.x, self.y = self.x - o.x, self.y - o.y
            }
            return self
        },
        sub_z: func(self, f) {
            self.z = self.z - f
            return self
        },
        mul_new: func(self, o) {
            if typeof o == "number" {
                return Vec3(self.x * o, self.y * o, self.z * o)
            } else {
                return Vec3(self.x * o.x, self.y * o.y, self.z * o.z)
            }
        },
        div_new: func(self, o) {
            if typeof o == "number" {
                return Vec3(self.x / o, self.y / o, self.z / o)
            } else {
                return Vec3(self.x / o.x, self.y / o.y, self.z / o.z)
            }
        },
        add_new: func(self, o) {
            if typeof o == "number" {
                return Vec3(self.x + o, self.y + o, self.z + o)
            } else {
                return Vec3(self.x + o.x, self.y + o.y, self.z + o.z)
            }
        },
        sub_new: func(self, o) {
            if typeof o == "number" {
                return Vec3(self.x - o, self.y - o, self.z - o)
            } else {
                return Vec3(self.x - o.x, self.y - o.y, self.z - o.z)
            }
        },
        neg2: func(self) {
            self.x, self.y = -self.x, -self.y
            return self
        },
        neg: func(self) {
            self.x, self.y, self.z = -self.x, -self.y, -self.z
            return self
        },
        min: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = min(self.x, o), min(self.y, o),
                    min(self.z, o)
            } else {
                self.x, self.y, self.z = min(self.x, o.x), min(self.y, o.y),
                    min(self.z, o.z)
            }
            return self
        },
        max: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = max(self.x, o), max(self.y, o),
                    max(self.z, o)
            } else {
                self.x, self.y, self.z = max(self.x, o.x), max(self.y, o.y),
                    max(self.z, o.z)
            }
            return self
        },
        abs: func(self) {
            self.x, self.y, self.z = abs(self.x), abs(self.y), abs(self.z)
            return self
        },
        clamp: func(self, l, h) {
            self.x, self.y, self.z = clamp(self.x, l, h), clamp(self.y, l, h),
                clamp(self.z, l, h)
            return self
        },
        square_dist: func(self, e) { return self.sub_new(e).squared_len() },
        dist: func(self, e) { return sqrt(self.square_dist(e)) },
        dist2: func(self, o) {
            var dx, dy = self.x - o.x, self.y - o.y
            return sqrt(dx ** 2 + dy ** 2)
        },
        reject: func(self, o, r) {
            return self.x > (o.x + r) || self.x < (o.x - r)
                || self.y > (o.y + r) || self.y < (o.y - r)
        },
        cross: func(self, a, b, o) {
            if o {
                return self.cross(a.sub_new(o), b.sub_new(o))
            }
            self.x, self.y, self.z = a.y * b.z - a.z * b.y,
                                     a.z * b.x - a.x * b.z,
                                     a.x * b.y - a.y * b.x
            return self
        },
        scalar_triple: func(self, a, b) {
            return self.x * (a.y * b.z - a.z * b.y)
                 + self.y * (a.z * b.x - a.x * b.z)
                 + self.z * (a.x * b.y - a.y * b.x)
        },
        scalar_triple_z: func(self, a, b) {
            return self.z * (a.x * b.y - a.y * b.x)
        },
        reflect_z: func(self, rz) {
            self.z = 2 * rz - self.z
            return self
        },
        reflect: func(self, n) {
            var k = 2 * self.dot(n)
            self.x, self.y, self.z = self.x - k * n.x,
                                     self.y - k * n.y,
                                     self.z - k * n.z
            return self
        },
        project: func(self, n) {
            var k = self.dot(n)
            self.x, self.y, self.z = self.x - k * n.x,
                                     self.y - k * n.y,
                                     self.z - k * n.z
            return self
        },
        project_xy_dir: func(self, n) {
            if n.z != 0 {
                self.z = -(self.x * n.x / n.z + self.y * n.y / n.z)
            }
            return self
        },
        project_xy: func(self, n, threshold) {
            var m = self.squared_len()
            var k = threshold && min(self.dot(n), threshold) || self.dot(n)
            self.project_xy_dir()
            self.rescale(sqrt(max(m - k ** 2, 0)))
            return self
        },
        lerp: func(self, a, b, t) {
            if !t { a, b, t = self, a, b }
            self.x, self.y, self.z = a.x + (b.x - a.x) * t,
                                     a.y * (b.y - a.y) * t,
                                     a.z * (b.z - a.z) * t
            return self
        },
        avg: func(self, b) { return self.add(b).mul(0.5) },
        madd: func(self, a, b) { return self.add(a.mul_new(b)) },
        msub: func(self, a, b) { return self.sub(a.mul_new(b)) },
        rescale: func(self, k) {
            var mag = self.magnitude()
            if mag > 1e-6 { self.mul(k / mag) }
            return self
        },
        rotate_around_z: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_z(cos(angle), sin(angle))
                } else {
                    var rx, ry = self.x, self.y
                    self.x, self.y = c * rx - s * ry, c * ry + s * rx
                    return self
                }
            } else {
                return self.rotate_around_z(c.x, c.y)
            }
        },
        rotate_around_x: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_x(cos(angle), sin(angle))
                } else {
                    var ry, rz = self.y, self.z
                    self.y, self.z = c * ry - s * rz, c * rz + s * ry
                    return self
                }
            } else {
                return self.rotate_around_x(c.x, c.y)
            }
        },
        rotate_around_y: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_y(cos(angle), sin(angle))
                } else {
                    var rx, rz = self.x, self.z
                    self.x, self.z = c * rx + s * rz, c * rz - s * rx
                    return self
                }
            } else {
                return self.rotate_around_y(c.x, c.y)
            }
        },
        rotate: func(self, c, s, d) {
            if !d {
                if typeof c == "number" {
                    var angle, d = c, s
                    return self.rotate(cos(angle), sin(angle), d)
                } else {
                    var sc, d = c, s
                    return self.rotate(sc.x, sc.y, d)
                }
            } else {
                var x, y, z = self.x, self.y, self.z
                self.x = x*(d.x*d.x*(1-c)+c) + y*(d.x*d.y*(1-c)-d.z*s)
                    + z*(d.x*d.z*(1-c)+d.y*s)
                self.y = x*(d.y*d.x*(1-c)+d.z*s) + y*(d.y*d.y*(1-c)+c)
                    + z*(d.y*d.z*(1-c)-d.x*s)
                self.z = x*(d.x*d.z*(1-c)-d.y*s) + y*(d.y*d.z*(1-c)+d.x*s)
                    + z*(d.z*d.z*(1-c)+c)
                return self
            }
        },
        orthogonal: func(self, d) {
            var x, y, z
            if abs(d.x) > abs(d.z) {
                x, y, z = -(d.y), d.x, 0
            } else {
                x, y, z = 0, -(d.z), d.y
            }
            self.x, self.y, self.z = x, y, z
            return self
        },
        orthonormalize: func(self, s, t) {
            s.project(self)
            t.project(self).project(s)
        },
        inside_bb: func(self, bbmin, bbmax, margin) {
            margin = margin || 0
            if typeof bbmax == "number" {
                var o, size = bbmin, bbmax
                size += margin
                return self.x >= (o.x - margin) && self.x <= (o.x + size)
                    && self.y >= (o.y - margin) && self.y <= (o.y + size)
                    && self.z >= (o.z - margin) && self.z <= (o.z + size)
            }
            return self.x >= (bbmin.x - margin) && self.x <= (bbmax.x + margin)
                && self.y >= (bbmin.y - margin) && self.y <= (bbmax.y + margin)
                && self.z >= (bbmin.z - margin) && self.z <= (bbmax.z + margin)
        },
        dist_to_bb: func(self, min, max) {
            if typeof max == "number" {
                var o, size = min, max
                return self.dist_to_bb(o, o.add_new(size))
            }
            var sqrdist = 0
            for i in 0 to 2 {
                var n = iton[i]
                if self[n] < min[n] {
                    var delta = self[n] - min[n]
                    sqrdist = sqrdist + delta ** 2
                } else if self[n] > max[n] {
                    var delta = max[n] - self[n]
                    sqrdist = sqrdist + delta ** 2
                }
            }
            return sqrt(sqrdist)
        },
        project_bb: func(self, min, max) {
            var x, y, z = self.x, self.y, self.z
            return x * (x < 0 && max.x || min.x)
                 + y * (y < 0 && max.y || min.y)
                 + z * (z < 0 && max.z || min.z)
        },
        to_hex_color: func(self) {
            return floor(clamp(self.r, 0, 1) * 255) << 16
                 | floor(clamp(self.g, 0, 1) * 255) <<  8
                 | floor(clamp(self.b, 0, 1) * 255)
        },

        /**
            Calculates the yaw from an origin to a target. Done on 2D data
            only. If the last "reverse" argument is given as true, it
            calculates away from the target. Returns the yaw.
        */
        yaw_to: func(self, target, reverse) {
            return reverse && target.yaw_to(self)
                || deg(-(atan2(target.x - self.x, target.y - self.y)))
        },

        /**
            Calculates the pitch from an origin to a target. Done on 2D data
            only. If the last "reverse" argument is given as true, it
            calculates away from the target. Returns the pitch.
        */
        pitch_to: func(self, target, reverse) {
            return reverse && target.pitch_to(self)
                || deg(asin((target.z - self.z) / self.dist(target)))
        },

        /**
            Checks if the yaw between two points is within acceptable error
            range. Useful to see whether a character is facing closely enough
            to the target, for example. Returns true if it is within the range,
            false otherwise.
        */
        compare_yaw: func(self, target, yaw, acceptable) {
            return abs(normalize_angle(self.yaw_to(target), yaw) - yaw)
                <= acceptable
        },

        /**
            Checks if the pitch between two points is within acceptable error
            range. Useful to see whether a character is facing closely enough
            to the target, for example. Returns true if it is within the range,
            false otherwise.
        */
        compare_pitch: func(self, target, pitch, acceptable) {
            return abs(normalize_angle(self.pitch_to(target), pitch) - pitch)
                <= acceptable
        }
    }
})
M.Vec3 = Vec3

var Vec4, Vec4_mt; Vec4, Vec4_mt = gen_vec4("float", "f", {
    __new: func(self, x, y, z, w) {
        if typeof x == "number" {
            if !y && !z && !w {
                return ffi_new(self, x, x, x, x)
            } else {
                return ffi_new(self, x, y, z, w)
            }
        } else {
            return ffi_new(self, x.x, x.y, x.z, x.w)
        }
    },
    __tostring: func(self) {
        return "Vec3 <%f, %f, %f, %f>".format(self.x, self.y, self.z, self.w)
    },
    __eq: func(self, o) { return self.equals(o) },
    __mul: func(self, o) { return self.mul_new(o) },
    __div: func(self, o) { return self.div_new(o) },
    __add: func(self, o) { return self.add_new(o) },
    __sub: func(self, o) { return self.sub_new(o) },
    __index: {
        equals: func(self, o) {
            return self.x == o.x && self.y == o.y
                && self.z == o.z && self.w == o.w
        },
        from_array: func(self, o) {
            return ffi_new(self, o[0], o[1], o[2], o[3])
        },
        from_vec3: func(self, o, w) {
            return ffi_new(self, o.x, o.y, o.z, w || 0)
        },

        copy: func(self) {
            return Vec4(self.x, self.y, self.z, self.w)
        },
        to_array: func(self) {
            return [ self.x, self.y, self.z, self.w ]
        },
        unpack3: func(self) {
            return self.x, self.y, self.z
        },
        unpack: func(self) {
            return self.x, self.y, self.z, self.w
        },
        get_nth: func(self, n) { return self[iton[n - 1]] },
        set_nth: func(self, n, v) { self[iton[n - 1]] = v },
        is_zero: func(self) {
            return self.x == 0 && self.y == 0 && self.z == 0 && self.w == 0
        },
        dot3: func(self, o) {
            return self.x * o.x + self.y * o.y + self.z * o.z
        },
        dot: func(self, o) {
            return self.x * o.x + self.y * o.y + self.z * o.z + self.w * o.w
        },
        squared_len: func(self) { return self.dot(self) },
        magnitude3: func(self) { return sqrt(self.dot3(self)) },
        magnitude: func(self) { return sqrt(self.squared_len()) },
        normalize: func(self) { return self.div(self.magnitude()) },
        lerp: func(self, a, b, t) {
            if !t { a, b, t = self, a, b }
            self.x, self.y, self.z, self.w = a.x + (b.x - a.x) * t,
                                             a.y * (b.y - a.y) * t,
                                             a.z * (b.z - a.z) * t,
                                             a.w * (b.w - a.w) * t
            return self
        },
        avg: func(self, b) { return self.add(b).mul(0.5) },
        madd: func(self, a, b) { return self.add(a.mul_new(b)) },
        msub: func(self, a, b) { return self.sub(a.mul_new(b)) },
        mul3: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x * o, self.y * o, self.z * o
            } else {
                self.x, self.y, self.z = self.x * o.x, self.y * o.y,
                    self.z * o.z
            }
            return self
        },
        div3: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x / o, self.y / o, self.z / o
            } else {
                self.x, self.y, self.z = self.x / o.x, self.y / o.y,
                    self.z / o.z
            }
            return self
        },
        add3: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x + o, self.y + o, self.z + o
            } else {
                self.x, self.y, self.z = self.x + o.x, self.y + o.y,
                    self.z + o.z
            }
            return self
        },
        sub3: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z = self.x - o, self.y - o, self.z - o
            } else {
                self.x, self.y, self.z = self.x - o.x, self.y - o.y,
                    self.z - o.z
            }
            return self
        },
        mul: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = self.x * o, self.y * o,
                    self.z * o, self.w * o
            } else {
                self.x, self.y, self.z, self.w = self.x * o.x, self.y * o.y,
                    self.z * o.z, self.w * o.w
            }
            return self
        },
        square: func(self) {
            self.mul(self)
            return self
        },
        div: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = self.x / o, self.y / o,
                    self.z / o, self.w / o
            } else {
                self.x, self.y, self.z, self.w = self.x / o.x, self.y / o.y,
                    self.z / o.z, self.w / o.w
            }
            return self
        },
        recip: func(self) {
            self.x = 1 / self.x
            self.y = 1 / self.y
            self.z = 1 / self.z
            self.w = 1 / self.w
            return self
        },
        add: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = self.x + o, self.y + o,
                    self.z + o, self.w + o
            } else {
                self.x, self.y, self.z, self.w = self.x + o.x, self.y + o.y,
                    self.z + o.z, self.w + o.w
            }
            return self
        },
        add_w: func(self, f) {
            self.w = self.w + f
            return self
        },
        sub: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = self.x - o, self.y - o,
                    self.z - o, self.w - o
            } else {
                self.x, self.y, self.z, self.w = self.x - o.x, self.y - o.y,
                    self.z - o.z, self.w - o.w
            }
            return self
        },
        sub_w: func(self, f) {
            self.w = self.w - f
            return self
        },
        mul_new: func(self, o) {
            if typeof o == "number" {
                return Vec4(self.x * o, self.y * o, self.z * o, self.w * o)
            } else {
                return Vec4(self.x * o.x, self.y * o.y, self.z * o.z,
                    self.w * o.w)
            }
        },
        div_new: func(self, o) {
            if typeof o == "number" {
                return Vec4(self.x / o, self.y / o, self.z / o, self.w / o)
            } else {
                return Vec4(self.x / o.x, self.y / o.y, self.z / o.z,
                    self.w / o.w)
            }
        },
        add_new: func(self, o) {
            if typeof o == "number" {
                return Vec4(self.x + o, self.y + o, self.z + o, self.w + o)
            } else {
                return Vec4(self.x + o.x, self.y + o.y, self.z + o.z,
                    self.w + o.w)
            }
        },
        sub_new: func(self, o) {
            if typeof o == "number" {
                return Vec4(self.x - o, self.y - o, self.z - o, self.w - o)
            } else {
                return Vec4(self.x - o.x, self.y - o.y, self.z - o.z,
                    self.w - o.w)
            }
        },
        neg3: func(self) {
            self.x, self.y, self.z = -self.x, -self.y, -self.w
            return self
        },
        neg: func(self) {
            self.x, self.y, self.z, self.w = -self.x, -self.y, -self.z, -self.w
            return self
        },
        min: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = min(self.x, o),
                    min(self.y, o), min(self.z, o), min(self.w, o)
            } else {
                self.x, self.y, self.z, self.w = min(self.x, o.x),
                    min(self.y, o.y), min(self.z, o.z), min(self.w, o.w)
            }
            return self
        },
        max: func(self, o) {
            if typeof o == "number" {
                self.x, self.y, self.z, self.w = max(self.x, o),
                    max(self.y, o), max(self.z, o), max(self.w, o)
            } else {
                self.x, self.y, self.z, self.w = max(self.x, o.x),
                    max(self.y, o.y), max(self.z, o.z), max(self.w, o.w)
            }
            return self
        },
        abs: func(self) {
            self.x, self.y, self.z, self.w = abs(self.x), abs(self.y),
                abs(self.z), abs(self.w)
            return self
        },
        clamp: func(self, l, h) {
            self.x, self.y, self.z, self.w = clamp(self.x, l, h),
                clamp(self.y, l, h), clamp(self.z, l, h), clamp(self.w, l. h)
            return self
        },
        cross: func(self, o, a, b) {
            if !b {
                b = a
                a = o
                self.x = a.y * b.z - a.z * b.y
                self.y = a.z * b.x - a.x * b.z
                self.z = a.x * b.y - a.y * b.x
                return self
            }
            return self.cross(a.sub_new(o), b.sub_new(o))
        },
        dist: func(self, o) {
            var dx, dy, dz = self.x - o.x, self.y - o.y, self.z - o.z
            return sqrt(dx ** 2 + dy ** 2 + dz ** 2)
        },
        dist2: func(self, o) {
            var dx, dy = self.x - o.x, self.y - o.y
            return sqrt(dx ** 2 + dy ** 2)
        },
        rotate_around_z: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_z(cos(angle), sin(angle))
                } else {
                    var rx, ry = self.x, self.y
                    self.x, self.y = c * rx - s * ry, c * ry + s * rx
                    return self
                }
            } else {
                return self.rotate_around_z(c.x, c.y)
            }
        },
        rotate_around_x: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_x(cos(angle), sin(angle))
                } else {
                    var ry, rz = self.y, self.z
                    self.y, self.z = c * ry - s * rz, c * rz + s * ry
                    return self
                }
            } else {
                return self.rotate_around_x(c.x, c.y)
            }
        },
        rotate_around_y: func(self, c, s) {
            if typeof c == "number" {
                if !s {
                    var angle = c
                    return self.rotate_around_y(cos(angle), sin(angle))
                } else {
                    var rx, rz = self.x, self.z
                    self.x, self.z = c * rx + s * rz, c * rz - s * rx
                    return self
                }
            } else {
                return self.rotate_around_y(c.x, c.y)
            }
        }
    }
})
M.Vec4 = Vec4

var sincos360 = [
    Vec2( 1.00000000,  0.00000000), Vec2( 0.99984770,  0.01745241), Vec2( 0.99939083,  0.03489950), Vec2( 0.99862953,  0.05233596), Vec2( 0.99756405,  0.06975647), Vec2( 0.99619470,  0.08715574), // 0
    Vec2( 0.99452190,  0.10452846), Vec2( 0.99254615,  0.12186934), Vec2( 0.99026807,  0.13917310), Vec2( 0.98768834,  0.15643447), Vec2( 0.98480775,  0.17364818), Vec2( 0.98162718,  0.19080900), // 6
    Vec2( 0.97814760,  0.20791169), Vec2( 0.97437006,  0.22495105), Vec2( 0.97029573,  0.24192190), Vec2( 0.96592583,  0.25881905), Vec2( 0.96126170,  0.27563736), Vec2( 0.95630476,  0.29237170), // 12
    Vec2( 0.95105652,  0.30901699), Vec2( 0.94551858,  0.32556815), Vec2( 0.93969262,  0.34202014), Vec2( 0.93358043,  0.35836795), Vec2( 0.92718385,  0.37460659), Vec2( 0.92050485,  0.39073113), // 18
    Vec2( 0.91354546,  0.40673664), Vec2( 0.90630779,  0.42261826), Vec2( 0.89879405,  0.43837115), Vec2( 0.89100652,  0.45399050), Vec2( 0.88294759,  0.46947156), Vec2( 0.87461971,  0.48480962), // 24
    Vec2( 0.86602540,  0.50000000), Vec2( 0.85716730,  0.51503807), Vec2( 0.84804810,  0.52991926), Vec2( 0.83867057,  0.54463904), Vec2( 0.82903757,  0.55919290), Vec2( 0.81915204,  0.57357644), // 30
    Vec2( 0.80901699,  0.58778525), Vec2( 0.79863551,  0.60181502), Vec2( 0.78801075,  0.61566148), Vec2( 0.77714596,  0.62932039), Vec2( 0.76604444,  0.64278761), Vec2( 0.75470958,  0.65605903), // 36
    Vec2( 0.74314483,  0.66913061), Vec2( 0.73135370,  0.68199836), Vec2( 0.71933980,  0.69465837), Vec2( 0.70710678,  0.70710678), Vec2( 0.69465837,  0.71933980), Vec2( 0.68199836,  0.73135370), // 42
    Vec2( 0.66913061,  0.74314483), Vec2( 0.65605903,  0.75470958), Vec2( 0.64278761,  0.76604444), Vec2( 0.62932039,  0.77714596), Vec2( 0.61566148,  0.78801075), Vec2( 0.60181502,  0.79863551), // 48
    Vec2( 0.58778525,  0.80901699), Vec2( 0.57357644,  0.81915204), Vec2( 0.55919290,  0.82903757), Vec2( 0.54463904,  0.83867057), Vec2( 0.52991926,  0.84804810), Vec2( 0.51503807,  0.85716730), // 54
    Vec2( 0.50000000,  0.86602540), Vec2( 0.48480962,  0.87461971), Vec2( 0.46947156,  0.88294759), Vec2( 0.45399050,  0.89100652), Vec2( 0.43837115,  0.89879405), Vec2( 0.42261826,  0.90630779), // 60
    Vec2( 0.40673664,  0.91354546), Vec2( 0.39073113,  0.92050485), Vec2( 0.37460659,  0.92718385), Vec2( 0.35836795,  0.93358043), Vec2( 0.34202014,  0.93969262), Vec2( 0.32556815,  0.94551858), // 66
    Vec2( 0.30901699,  0.95105652), Vec2( 0.29237170,  0.95630476), Vec2( 0.27563736,  0.96126170), Vec2( 0.25881905,  0.96592583), Vec2( 0.24192190,  0.97029573), Vec2( 0.22495105,  0.97437006), // 72
    Vec2( 0.20791169,  0.97814760), Vec2( 0.19080900,  0.98162718), Vec2( 0.17364818,  0.98480775), Vec2( 0.15643447,  0.98768834), Vec2( 0.13917310,  0.99026807), Vec2( 0.12186934,  0.99254615), // 78
    Vec2( 0.10452846,  0.99452190), Vec2( 0.08715574,  0.99619470), Vec2( 0.06975647,  0.99756405), Vec2( 0.05233596,  0.99862953), Vec2( 0.03489950,  0.99939083), Vec2( 0.01745241,  0.99984770), // 84
    Vec2( 0.00000000,  1.00000000), Vec2(-0.01745241,  0.99984770), Vec2(-0.03489950,  0.99939083), Vec2(-0.05233596,  0.99862953), Vec2(-0.06975647,  0.99756405), Vec2(-0.08715574,  0.99619470), // 90
    Vec2(-0.10452846,  0.99452190), Vec2(-0.12186934,  0.99254615), Vec2(-0.13917310,  0.99026807), Vec2(-0.15643447,  0.98768834), Vec2(-0.17364818,  0.98480775), Vec2(-0.19080900,  0.98162718), // 96
    Vec2(-0.20791169,  0.97814760), Vec2(-0.22495105,  0.97437006), Vec2(-0.24192190,  0.97029573), Vec2(-0.25881905,  0.96592583), Vec2(-0.27563736,  0.96126170), Vec2(-0.29237170,  0.95630476), // 102
    Vec2(-0.30901699,  0.95105652), Vec2(-0.32556815,  0.94551858), Vec2(-0.34202014,  0.93969262), Vec2(-0.35836795,  0.93358043), Vec2(-0.37460659,  0.92718385), Vec2(-0.39073113,  0.92050485), // 108
    Vec2(-0.40673664,  0.91354546), Vec2(-0.42261826,  0.90630779), Vec2(-0.43837115,  0.89879405), Vec2(-0.45399050,  0.89100652), Vec2(-0.46947156,  0.88294759), Vec2(-0.48480962,  0.87461971), // 114
    Vec2(-0.50000000,  0.86602540), Vec2(-0.51503807,  0.85716730), Vec2(-0.52991926,  0.84804810), Vec2(-0.54463904,  0.83867057), Vec2(-0.55919290,  0.82903757), Vec2(-0.57357644,  0.81915204), // 120
    Vec2(-0.58778525,  0.80901699), Vec2(-0.60181502,  0.79863551), Vec2(-0.61566148,  0.78801075), Vec2(-0.62932039,  0.77714596), Vec2(-0.64278761,  0.76604444), Vec2(-0.65605903,  0.75470958), // 126
    Vec2(-0.66913061,  0.74314483), Vec2(-0.68199836,  0.73135370), Vec2(-0.69465837,  0.71933980), Vec2(-0.70710678,  0.70710678), Vec2(-0.71933980,  0.69465837), Vec2(-0.73135370,  0.68199836), // 132
    Vec2(-0.74314483,  0.66913061), Vec2(-0.75470958,  0.65605903), Vec2(-0.76604444,  0.64278761), Vec2(-0.77714596,  0.62932039), Vec2(-0.78801075,  0.61566148), Vec2(-0.79863551,  0.60181502), // 138
    Vec2(-0.80901699,  0.58778525), Vec2(-0.81915204,  0.57357644), Vec2(-0.82903757,  0.55919290), Vec2(-0.83867057,  0.54463904), Vec2(-0.84804810,  0.52991926), Vec2(-0.85716730,  0.51503807), // 144
    Vec2(-0.86602540,  0.50000000), Vec2(-0.87461971,  0.48480962), Vec2(-0.88294759,  0.46947156), Vec2(-0.89100652,  0.45399050), Vec2(-0.89879405,  0.43837115), Vec2(-0.90630779,  0.42261826), // 150
    Vec2(-0.91354546,  0.40673664), Vec2(-0.92050485,  0.39073113), Vec2(-0.92718385,  0.37460659), Vec2(-0.93358043,  0.35836795), Vec2(-0.93969262,  0.34202014), Vec2(-0.94551858,  0.32556815), // 156
    Vec2(-0.95105652,  0.30901699), Vec2(-0.95630476,  0.29237170), Vec2(-0.96126170,  0.27563736), Vec2(-0.96592583,  0.25881905), Vec2(-0.97029573,  0.24192190), Vec2(-0.97437006,  0.22495105), // 162
    Vec2(-0.97814760,  0.20791169), Vec2(-0.98162718,  0.19080900), Vec2(-0.98480775,  0.17364818), Vec2(-0.98768834,  0.15643447), Vec2(-0.99026807,  0.13917310), Vec2(-0.99254615,  0.12186934), // 168
    Vec2(-0.99452190,  0.10452846), Vec2(-0.99619470,  0.08715574), Vec2(-0.99756405,  0.06975647), Vec2(-0.99862953,  0.05233596), Vec2(-0.99939083,  0.03489950), Vec2(-0.99984770,  0.01745241), // 174
    Vec2(-1.00000000,  0.00000000), Vec2(-0.99984770, -0.01745241), Vec2(-0.99939083, -0.03489950), Vec2(-0.99862953, -0.05233596), Vec2(-0.99756405, -0.06975647), Vec2(-0.99619470, -0.08715574), // 180
    Vec2(-0.99452190, -0.10452846), Vec2(-0.99254615, -0.12186934), Vec2(-0.99026807, -0.13917310), Vec2(-0.98768834, -0.15643447), Vec2(-0.98480775, -0.17364818), Vec2(-0.98162718, -0.19080900), // 186
    Vec2(-0.97814760, -0.20791169), Vec2(-0.97437006, -0.22495105), Vec2(-0.97029573, -0.24192190), Vec2(-0.96592583, -0.25881905), Vec2(-0.96126170, -0.27563736), Vec2(-0.95630476, -0.29237170), // 192
    Vec2(-0.95105652, -0.30901699), Vec2(-0.94551858, -0.32556815), Vec2(-0.93969262, -0.34202014), Vec2(-0.93358043, -0.35836795), Vec2(-0.92718385, -0.37460659), Vec2(-0.92050485, -0.39073113), // 198
    Vec2(-0.91354546, -0.40673664), Vec2(-0.90630779, -0.42261826), Vec2(-0.89879405, -0.43837115), Vec2(-0.89100652, -0.45399050), Vec2(-0.88294759, -0.46947156), Vec2(-0.87461971, -0.48480962), // 204
    Vec2(-0.86602540, -0.50000000), Vec2(-0.85716730, -0.51503807), Vec2(-0.84804810, -0.52991926), Vec2(-0.83867057, -0.54463904), Vec2(-0.82903757, -0.55919290), Vec2(-0.81915204, -0.57357644), // 210
    Vec2(-0.80901699, -0.58778525), Vec2(-0.79863551, -0.60181502), Vec2(-0.78801075, -0.61566148), Vec2(-0.77714596, -0.62932039), Vec2(-0.76604444, -0.64278761), Vec2(-0.75470958, -0.65605903), // 216
    Vec2(-0.74314483, -0.66913061), Vec2(-0.73135370, -0.68199836), Vec2(-0.71933980, -0.69465837), Vec2(-0.70710678, -0.70710678), Vec2(-0.69465837, -0.71933980), Vec2(-0.68199836, -0.73135370), // 222
    Vec2(-0.66913061, -0.74314483), Vec2(-0.65605903, -0.75470958), Vec2(-0.64278761, -0.76604444), Vec2(-0.62932039, -0.77714596), Vec2(-0.61566148, -0.78801075), Vec2(-0.60181502, -0.79863551), // 228
    Vec2(-0.58778525, -0.80901699), Vec2(-0.57357644, -0.81915204), Vec2(-0.55919290, -0.82903757), Vec2(-0.54463904, -0.83867057), Vec2(-0.52991926, -0.84804810), Vec2(-0.51503807, -0.85716730), // 234
    Vec2(-0.50000000, -0.86602540), Vec2(-0.48480962, -0.87461971), Vec2(-0.46947156, -0.88294759), Vec2(-0.45399050, -0.89100652), Vec2(-0.43837115, -0.89879405), Vec2(-0.42261826, -0.90630779), // 240
    Vec2(-0.40673664, -0.91354546), Vec2(-0.39073113, -0.92050485), Vec2(-0.37460659, -0.92718385), Vec2(-0.35836795, -0.93358043), Vec2(-0.34202014, -0.93969262), Vec2(-0.32556815, -0.94551858), // 246
    Vec2(-0.30901699, -0.95105652), Vec2(-0.29237170, -0.95630476), Vec2(-0.27563736, -0.96126170), Vec2(-0.25881905, -0.96592583), Vec2(-0.24192190, -0.97029573), Vec2(-0.22495105, -0.97437006), // 252
    Vec2(-0.20791169, -0.97814760), Vec2(-0.19080900, -0.98162718), Vec2(-0.17364818, -0.98480775), Vec2(-0.15643447, -0.98768834), Vec2(-0.13917310, -0.99026807), Vec2(-0.12186934, -0.99254615), // 258
    Vec2(-0.10452846, -0.99452190), Vec2(-0.08715574, -0.99619470), Vec2(-0.06975647, -0.99756405), Vec2(-0.05233596, -0.99862953), Vec2(-0.03489950, -0.99939083), Vec2(-0.01745241, -0.99984770), // 264
    Vec2(-0.00000000, -1.00000000), Vec2( 0.01745241, -0.99984770), Vec2( 0.03489950, -0.99939083), Vec2( 0.05233596, -0.99862953), Vec2( 0.06975647, -0.99756405), Vec2( 0.08715574, -0.99619470), // 270
    Vec2( 0.10452846, -0.99452190), Vec2( 0.12186934, -0.99254615), Vec2( 0.13917310, -0.99026807), Vec2( 0.15643447, -0.98768834), Vec2( 0.17364818, -0.98480775), Vec2( 0.19080900, -0.98162718), // 276
    Vec2( 0.20791169, -0.97814760), Vec2( 0.22495105, -0.97437006), Vec2( 0.24192190, -0.97029573), Vec2( 0.25881905, -0.96592583), Vec2( 0.27563736, -0.96126170), Vec2( 0.29237170, -0.95630476), // 282
    Vec2( 0.30901699, -0.95105652), Vec2( 0.32556815, -0.94551858), Vec2( 0.34202014, -0.93969262), Vec2( 0.35836795, -0.93358043), Vec2( 0.37460659, -0.92718385), Vec2( 0.39073113, -0.92050485), // 288
    Vec2( 0.40673664, -0.91354546), Vec2( 0.42261826, -0.90630779), Vec2( 0.43837115, -0.89879405), Vec2( 0.45399050, -0.89100652), Vec2( 0.46947156, -0.88294759), Vec2( 0.48480962, -0.87461971), // 294
    Vec2( 0.50000000, -0.86602540), Vec2( 0.51503807, -0.85716730), Vec2( 0.52991926, -0.84804810), Vec2( 0.54463904, -0.83867057), Vec2( 0.55919290, -0.82903757), Vec2( 0.57357644, -0.81915204), // 300
    Vec2( 0.58778525, -0.80901699), Vec2( 0.60181502, -0.79863551), Vec2( 0.61566148, -0.78801075), Vec2( 0.62932039, -0.77714596), Vec2( 0.64278761, -0.76604444), Vec2( 0.65605903, -0.75470958), // 306
    Vec2( 0.66913061, -0.74314483), Vec2( 0.68199836, -0.73135370), Vec2( 0.69465837, -0.71933980), Vec2( 0.70710678, -0.70710678), Vec2( 0.71933980, -0.69465837), Vec2( 0.73135370, -0.68199836), // 312
    Vec2( 0.74314483, -0.66913061), Vec2( 0.75470958, -0.65605903), Vec2( 0.76604444, -0.64278761), Vec2( 0.77714596, -0.62932039), Vec2( 0.78801075, -0.61566148), Vec2( 0.79863551, -0.60181502), // 318
    Vec2( 0.80901699, -0.58778525), Vec2( 0.81915204, -0.57357644), Vec2( 0.82903757, -0.55919290), Vec2( 0.83867057, -0.54463904), Vec2( 0.84804810, -0.52991926), Vec2( 0.85716730, -0.51503807), // 324
    Vec2( 0.86602540, -0.50000000), Vec2( 0.87461971, -0.48480962), Vec2( 0.88294759, -0.46947156), Vec2( 0.89100652, -0.45399050), Vec2( 0.89879405, -0.43837115), Vec2( 0.90630779, -0.42261826), // 330
    Vec2( 0.91354546, -0.40673664), Vec2( 0.92050485, -0.39073113), Vec2( 0.92718385, -0.37460659), Vec2( 0.93358043, -0.35836795), Vec2( 0.93969262, -0.34202014), Vec2( 0.94551858, -0.32556815), // 336
    Vec2( 0.95105652, -0.30901699), Vec2( 0.95630476, -0.29237170), Vec2( 0.96126170, -0.27563736), Vec2( 0.96592583, -0.25881905), Vec2( 0.97029573, -0.24192190), Vec2( 0.97437006, -0.22495105), // 342
    Vec2( 0.97814760, -0.20791169), Vec2( 0.98162718, -0.19080900), Vec2( 0.98480775, -0.17364818), Vec2( 0.98768834, -0.15643447), Vec2( 0.99026807, -0.13917310), Vec2( 0.99254615, -0.12186934), // 348
    Vec2( 0.99452190, -0.10452846), Vec2( 0.99619470, -0.08715574), Vec2( 0.99756405, -0.06975647), Vec2( 0.99862953, -0.05233596), Vec2( 0.99939083, -0.03489950), Vec2( 0.99984770, -0.01745241), // 354
    Vec2( 1.00000000,  0.00000000), Vec2( 0.99984770,  0.01745241), Vec2( 0.99939083,  0.03489950), Vec2( 0.99862953,  0.05233596), Vec2( 0.99756405,  0.06975647), Vec2( 0.99619470,  0.08715574), // 360
    Vec2( 0.99452190,  0.10452846), Vec2( 0.99254615,  0.12186934), Vec2( 0.99026807,  0.13917310), Vec2( 0.98768834,  0.15643447), Vec2( 0.98480775,  0.17364818), Vec2( 0.98162718,  0.19080900), // 366
    Vec2( 0.97814760,  0.20791169), Vec2( 0.97437006,  0.22495105), Vec2( 0.97029573,  0.24192190), Vec2( 0.96592583,  0.25881905), Vec2( 0.96126170,  0.27563736), Vec2( 0.95630476,  0.29237170), // 372
    Vec2( 0.95105652,  0.30901699), Vec2( 0.94551858,  0.32556815), Vec2( 0.93969262,  0.34202014), Vec2( 0.93358043,  0.35836795), Vec2( 0.92718385,  0.37460659), Vec2( 0.92050485,  0.39073113), // 378
    Vec2( 0.91354546,  0.40673664), Vec2( 0.90630779,  0.42261826), Vec2( 0.89879405,  0.43837115), Vec2( 0.89100652,  0.45399050), Vec2( 0.88294759,  0.46947156), Vec2( 0.87461971,  0.48480962), // 384
    Vec2( 0.86602540,  0.50000000), Vec2( 0.85716730,  0.51503807), Vec2( 0.84804810,  0.52991926), Vec2( 0.83867057,  0.54463904), Vec2( 0.82903757,  0.55919290), Vec2( 0.81915204,  0.57357644), // 390
    Vec2( 0.80901699,  0.58778525), Vec2( 0.79863551,  0.60181502), Vec2( 0.78801075,  0.61566148), Vec2( 0.77714596,  0.62932039), Vec2( 0.76604444,  0.64278761), Vec2( 0.75470958,  0.65605903), // 396
    Vec2( 0.74314483,  0.66913061), Vec2( 0.73135370,  0.68199836), Vec2( 0.71933980,  0.69465837), Vec2( 0.70710678,  0.70710678), Vec2( 0.69465837,  0.71933980), Vec2( 0.68199836,  0.73135370), // 402
    Vec2( 0.66913061,  0.74314483), Vec2( 0.65605903,  0.75470958), Vec2( 0.64278761,  0.76604444), Vec2( 0.62932039,  0.77714596), Vec2( 0.61566148,  0.78801075), Vec2( 0.60181502,  0.79863551), // 408
    Vec2( 0.58778525,  0.80901699), Vec2( 0.57357644,  0.81915204), Vec2( 0.55919290,  0.82903757), Vec2( 0.54463904,  0.83867057), Vec2( 0.52991926,  0.84804810), Vec2( 0.51503807,  0.85716730), // 414
    Vec2( 0.50000000,  0.86602540), Vec2( 0.48480962,  0.87461971), Vec2( 0.46947156,  0.88294759), Vec2( 0.45399050,  0.89100652), Vec2( 0.43837115,  0.89879405), Vec2( 0.42261826,  0.90630779), // 420
    Vec2( 0.40673664,  0.91354546), Vec2( 0.39073113,  0.92050485), Vec2( 0.37460659,  0.92718385), Vec2( 0.35836795,  0.93358043), Vec2( 0.34202014,  0.93969262), Vec2( 0.32556815,  0.94551858), // 426
    Vec2( 0.30901699,  0.95105652), Vec2( 0.29237170,  0.95630476), Vec2( 0.27563736,  0.96126170), Vec2( 0.25881905,  0.96592583), Vec2( 0.24192190,  0.97029573), Vec2( 0.22495105,  0.97437006), // 432
    Vec2( 0.20791169,  0.97814760), Vec2( 0.19080900,  0.98162718), Vec2( 0.17364818,  0.98480775), Vec2( 0.15643447,  0.98768834), Vec2( 0.13917310,  0.99026807), Vec2( 0.12186934,  0.99254615), // 438
    Vec2( 0.10452846,  0.99452190), Vec2( 0.08715574,  0.99619470), Vec2( 0.06975647,  0.99756405), Vec2( 0.05233596,  0.99862953), Vec2( 0.03489950,  0.99939083), Vec2( 0.01745241,  0.99984770), // 444
    Vec2( 0.00000000,  1.00000000), Vec2(-0.01745241,  0.99984770), Vec2(-0.03489950,  0.99939083), Vec2(-0.05233596,  0.99862953), Vec2(-0.06975647,  0.99756405), Vec2(-0.08715574,  0.99619470), // 450
    Vec2(-0.10452846,  0.99452190), Vec2(-0.12186934,  0.99254615), Vec2(-0.13917310,  0.99026807), Vec2(-0.15643447,  0.98768834), Vec2(-0.17364818,  0.98480775), Vec2(-0.19080900,  0.98162718), // 456
    Vec2(-0.20791169,  0.97814760), Vec2(-0.22495105,  0.97437006), Vec2(-0.24192190,  0.97029573), Vec2(-0.25881905,  0.96592583), Vec2(-0.27563736,  0.96126170), Vec2(-0.29237170,  0.95630476), // 462
    Vec2(-0.30901699,  0.95105652), Vec2(-0.32556815,  0.94551858), Vec2(-0.34202014,  0.93969262), Vec2(-0.35836795,  0.93358043), Vec2(-0.37460659,  0.92718385), Vec2(-0.39073113,  0.92050485), // 468
    Vec2(-0.40673664,  0.91354546), Vec2(-0.42261826,  0.90630779), Vec2(-0.43837115,  0.89879405), Vec2(-0.45399050,  0.89100652), Vec2(-0.46947156,  0.88294759), Vec2(-0.48480962,  0.87461971), // 474
    Vec2(-0.50000000,  0.86602540), Vec2(-0.51503807,  0.85716730), Vec2(-0.52991926,  0.84804810), Vec2(-0.54463904,  0.83867057), Vec2(-0.55919290,  0.82903757), Vec2(-0.57357644,  0.81915204), // 480
    Vec2(-0.58778525,  0.80901699), Vec2(-0.60181502,  0.79863551), Vec2(-0.61566148,  0.78801075), Vec2(-0.62932039,  0.77714596), Vec2(-0.64278761,  0.76604444), Vec2(-0.65605903,  0.75470958), // 486
    Vec2(-0.66913061,  0.74314483), Vec2(-0.68199836,  0.73135370), Vec2(-0.69465837,  0.71933980), Vec2(-0.70710678,  0.70710678), Vec2(-0.71933980,  0.69465837), Vec2(-0.73135370,  0.68199836), // 492
    Vec2(-0.74314483,  0.66913061), Vec2(-0.75470958,  0.65605903), Vec2(-0.76604444,  0.64278761), Vec2(-0.77714596,  0.62932039), Vec2(-0.78801075,  0.61566148), Vec2(-0.79863551,  0.60181502), // 498
    Vec2(-0.80901699,  0.58778525), Vec2(-0.81915204,  0.57357644), Vec2(-0.82903757,  0.55919290), Vec2(-0.83867057,  0.54463904), Vec2(-0.84804810,  0.52991926), Vec2(-0.85716730,  0.51503807), // 504
    Vec2(-0.86602540,  0.50000000), Vec2(-0.87461971,  0.48480962), Vec2(-0.88294759,  0.46947156), Vec2(-0.89100652,  0.45399050), Vec2(-0.89879405,  0.43837115), Vec2(-0.90630779,  0.42261826), // 510
    Vec2(-0.91354546,  0.40673664), Vec2(-0.92050485,  0.39073113), Vec2(-0.92718385,  0.37460659), Vec2(-0.93358043,  0.35836795), Vec2(-0.93969262,  0.34202014), Vec2(-0.94551858,  0.32556815), // 516
    Vec2(-0.95105652,  0.30901699), Vec2(-0.95630476,  0.29237170), Vec2(-0.96126170,  0.27563736), Vec2(-0.96592583,  0.25881905), Vec2(-0.97029573,  0.24192190), Vec2(-0.97437006,  0.22495105), // 522
    Vec2(-0.97814760,  0.20791169), Vec2(-0.98162718,  0.19080900), Vec2(-0.98480775,  0.17364818), Vec2(-0.98768834,  0.15643447), Vec2(-0.99026807,  0.13917310), Vec2(-0.99254615,  0.12186934), // 528
    Vec2(-0.99452190,  0.10452846), Vec2(-0.99619470,  0.08715574), Vec2(-0.99756405,  0.06975647), Vec2(-0.99862953,  0.05233596), Vec2(-0.99939083,  0.03489950), Vec2(-0.99984770,  0.01745241), // 534
    Vec2(-1.00000000,  0.00000000), Vec2(-0.99984770, -0.01745241), Vec2(-0.99939083, -0.03489950), Vec2(-0.99862953, -0.05233596), Vec2(-0.99756405, -0.06975647), Vec2(-0.99619470, -0.08715574), // 540
    Vec2(-0.99452190, -0.10452846), Vec2(-0.99254615, -0.12186934), Vec2(-0.99026807, -0.13917310), Vec2(-0.98768834, -0.15643447), Vec2(-0.98480775, -0.17364818), Vec2(-0.98162718, -0.19080900), // 546
    Vec2(-0.97814760, -0.20791169), Vec2(-0.97437006, -0.22495105), Vec2(-0.97029573, -0.24192190), Vec2(-0.96592583, -0.25881905), Vec2(-0.96126170, -0.27563736), Vec2(-0.95630476, -0.29237170), // 552
    Vec2(-0.95105652, -0.30901699), Vec2(-0.94551858, -0.32556815), Vec2(-0.93969262, -0.34202014), Vec2(-0.93358043, -0.35836795), Vec2(-0.92718385, -0.37460659), Vec2(-0.92050485, -0.39073113), // 558
    Vec2(-0.91354546, -0.40673664), Vec2(-0.90630779, -0.42261826), Vec2(-0.89879405, -0.43837115), Vec2(-0.89100652, -0.45399050), Vec2(-0.88294759, -0.46947156), Vec2(-0.87461971, -0.48480962), // 564
    Vec2(-0.86602540, -0.50000000), Vec2(-0.85716730, -0.51503807), Vec2(-0.84804810, -0.52991926), Vec2(-0.83867057, -0.54463904), Vec2(-0.82903757, -0.55919290), Vec2(-0.81915204, -0.57357644), // 570
    Vec2(-0.80901699, -0.58778525), Vec2(-0.79863551, -0.60181502), Vec2(-0.78801075, -0.61566148), Vec2(-0.77714596, -0.62932039), Vec2(-0.76604444, -0.64278761), Vec2(-0.75470958, -0.65605903), // 576
    Vec2(-0.74314483, -0.66913061), Vec2(-0.73135370, -0.68199836), Vec2(-0.71933980, -0.69465837), Vec2(-0.70710678, -0.70710678), Vec2(-0.69465837, -0.71933980), Vec2(-0.68199836, -0.73135370), // 582
    Vec2(-0.66913061, -0.74314483), Vec2(-0.65605903, -0.75470958), Vec2(-0.64278761, -0.76604444), Vec2(-0.62932039, -0.77714596), Vec2(-0.61566148, -0.78801075), Vec2(-0.60181502, -0.79863551), // 588
    Vec2(-0.58778525, -0.80901699), Vec2(-0.57357644, -0.81915204), Vec2(-0.55919290, -0.82903757), Vec2(-0.54463904, -0.83867057), Vec2(-0.52991926, -0.84804810), Vec2(-0.51503807, -0.85716730), // 594
    Vec2(-0.50000000, -0.86602540), Vec2(-0.48480962, -0.87461971), Vec2(-0.46947156, -0.88294759), Vec2(-0.45399050, -0.89100652), Vec2(-0.43837115, -0.89879405), Vec2(-0.42261826, -0.90630779), // 600
    Vec2(-0.40673664, -0.91354546), Vec2(-0.39073113, -0.92050485), Vec2(-0.37460659, -0.92718385), Vec2(-0.35836795, -0.93358043), Vec2(-0.34202014, -0.93969262), Vec2(-0.32556815, -0.94551858), // 606
    Vec2(-0.30901699, -0.95105652), Vec2(-0.29237170, -0.95630476), Vec2(-0.27563736, -0.96126170), Vec2(-0.25881905, -0.96592583), Vec2(-0.24192190, -0.97029573), Vec2(-0.22495105, -0.97437006), // 612
    Vec2(-0.20791169, -0.97814760), Vec2(-0.19080900, -0.98162718), Vec2(-0.17364818, -0.98480775), Vec2(-0.15643447, -0.98768834), Vec2(-0.13917310, -0.99026807), Vec2(-0.12186934, -0.99254615), // 618
    Vec2(-0.10452846, -0.99452190), Vec2(-0.08715574, -0.99619470), Vec2(-0.06975647, -0.99756405), Vec2(-0.05233596, -0.99862953), Vec2(-0.03489950, -0.99939083), Vec2(-0.01745241, -0.99984770), // 624
    Vec2(-0.00000000, -1.00000000), Vec2( 0.01745241, -0.99984770), Vec2( 0.03489950, -0.99939083), Vec2( 0.05233596, -0.99862953), Vec2( 0.06975647, -0.99756405), Vec2( 0.08715574, -0.99619470), // 630
    Vec2( 0.10452846, -0.99452190), Vec2( 0.12186934, -0.99254615), Vec2( 0.13917310, -0.99026807), Vec2( 0.15643447, -0.98768834), Vec2( 0.17364818, -0.98480775), Vec2( 0.19080900, -0.98162718), // 636
    Vec2( 0.20791169, -0.97814760), Vec2( 0.22495105, -0.97437006), Vec2( 0.24192190, -0.97029573), Vec2( 0.25881905, -0.96592583), Vec2( 0.27563736, -0.96126170), Vec2( 0.29237170, -0.95630476), // 642
    Vec2( 0.30901699, -0.95105652), Vec2( 0.32556815, -0.94551858), Vec2( 0.34202014, -0.93969262), Vec2( 0.35836795, -0.93358043), Vec2( 0.37460659, -0.92718385), Vec2( 0.39073113, -0.92050485), // 648
    Vec2( 0.40673664, -0.91354546), Vec2( 0.42261826, -0.90630779), Vec2( 0.43837115, -0.89879405), Vec2( 0.45399050, -0.89100652), Vec2( 0.46947156, -0.88294759), Vec2( 0.48480962, -0.87461971), // 654
    Vec2( 0.50000000, -0.86602540), Vec2( 0.51503807, -0.85716730), Vec2( 0.52991926, -0.84804810), Vec2( 0.54463904, -0.83867057), Vec2( 0.55919290, -0.82903757), Vec2( 0.57357644, -0.81915204), // 660
    Vec2( 0.58778525, -0.80901699), Vec2( 0.60181502, -0.79863551), Vec2( 0.61566148, -0.78801075), Vec2( 0.62932039, -0.77714596), Vec2( 0.64278761, -0.76604444), Vec2( 0.65605903, -0.75470958), // 666
    Vec2( 0.66913061, -0.74314483), Vec2( 0.68199836, -0.73135370), Vec2( 0.69465837, -0.71933980), Vec2( 0.70710678, -0.70710678), Vec2( 0.71933980, -0.69465837), Vec2( 0.73135370, -0.68199836), // 672
    Vec2( 0.74314483, -0.66913061), Vec2( 0.75470958, -0.65605903), Vec2( 0.76604444, -0.64278761), Vec2( 0.77714596, -0.62932039), Vec2( 0.78801075, -0.61566148), Vec2( 0.79863551, -0.60181502), // 678
    Vec2( 0.80901699, -0.58778525), Vec2( 0.81915204, -0.57357644), Vec2( 0.82903757, -0.55919290), Vec2( 0.83867057, -0.54463904), Vec2( 0.84804810, -0.52991926), Vec2( 0.85716730, -0.51503807), // 684
    Vec2( 0.86602540, -0.50000000), Vec2( 0.87461971, -0.48480962), Vec2( 0.88294759, -0.46947156), Vec2( 0.89100652, -0.45399050), Vec2( 0.89879405, -0.43837115), Vec2( 0.90630779, -0.42261826), // 690
    Vec2( 0.91354546, -0.40673664), Vec2( 0.92050485, -0.39073113), Vec2( 0.92718385, -0.37460659), Vec2( 0.93358043, -0.35836795), Vec2( 0.93969262, -0.34202014), Vec2( 0.94551858, -0.32556815), // 696
    Vec2( 0.95105652, -0.30901699), Vec2( 0.95630476, -0.29237170), Vec2( 0.96126170, -0.27563736), Vec2( 0.96592583, -0.25881905), Vec2( 0.97029573, -0.24192190), Vec2( 0.97437006, -0.22495105), // 702
    Vec2( 0.97814760, -0.20791169), Vec2( 0.98162718, -0.19080900), Vec2( 0.98480775, -0.17364818), Vec2( 0.98768834, -0.15643447), Vec2( 0.99026807, -0.13917310), Vec2( 0.99254615, -0.12186934), // 708
    Vec2( 0.99452190, -0.10452846), Vec2( 0.99619470, -0.08715574), Vec2( 0.99756405, -0.06975647), Vec2( 0.99862953, -0.05233596), Vec2( 0.99939083, -0.03489950), Vec2( 0.99984770, -0.01745241), // 714
    Vec2( 1.00000000,  0.00000000) // 720
]
M.sin_cos_360 = func(angle) {
    return sincos360[angle]
}

var mod_360 = func(angle) {
    if angle < 0 {
        angle = 360 + ((angle <= -360) && -((-angle) % 360) || angle)
    } else if angle >= 360 {
        angle %= 360
    }
    return angle
}
M.mod_360 = mod_360

M.sin_cos_mod_360 = func(angle) {
    return sincos360[mod_360(angle)]
}

M.cos_360 = func(angle) {
    return sincos360[angle].x
}

M.sin_360 = func(angle) {
    return sincos360[angle].y
}

M.tan_360 = func(angle) {
    var sc = sincos360[angle]
    return sc.y / sc.x
}

M.cotan_360 = func(angle) {
    var sc = sincos360[angle]
    return sc.x / sc.y
}

package.loaded["std.geom"] = M
std["geom"] = M