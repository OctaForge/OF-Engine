import capi
import core.engine.edit
import core.engine.input
import core.entities.ents
import core.entities.svars
import core.events.signal
import core.gui.core as gui

from std.table import pairs
from std.conv import tostring

var root = gui::get_root()

var slots_populate = func(gr, slotlist) {
    gr.destroy_children()
    for i, slot in slotlist.each() {
        gr.append(gui::Button({ variant: "slot",
            index: slot, min_w: 0.095, min_h: 0.095
        }), func(b) {
            signal::connect(b, "clicked", \-> capi::slot_set(
                capi::slot_get_tex(slot)))
        })
    }
}

var gen_slot_combo = func(packs, gr) {
    var packmap = {}
    var r = gui::MenuButton({ variant: "combobox", label: "all", min_w: 0.2 })
    var mn = gui::Filler({ variant: "menu", min_w: 0.2 })
    mn.append(gui::VBox({ clamp: true }), func(vb) {
        var mb = vb.append(gui::MenuButton({ variant: "submenu",
            label: "all", clamp_h: true }))
        signal::connect(mb, "clicked", func(mb) {
            var slotl = []
            for i in 0 to capi::slot_get_count() - 1 {
                slotl.push(i)
            }
            slots_populate(gr, slotl)
            r.set_label("all")
            root.clear_menus()
        })
        var otherslots = []
        for i in 0 to capi::slot_get_count() - 1 {
            otherslots.push(i)
        }
        for i, val in packs.each() {
            var mb = vb.append(gui::MenuButton({ variant: "submenu",
                label: val[0], clamp_h: true }))
            var slotl = []
            for i in val[1] to val[1] + val[2] - 1 {
                otherslots[i] = undef
                slotl.push(i)
            }
            signal::connect(mb, "clicked", func(mb) {
                slots_populate(gr, slotl)
                r.set_label(val[0])
                root.clear_menus()
            })
        }
        otherslots.compact(\v -> v)
        if otherslots.len() > 0 {
            var mb = vb.append(gui::MenuButton({ variant: "submenu",
                label: "other", clamp_h: true }))
            signal::connect(mb, "clicked", func(mb) {
                slots_populate(gr, otherslots)
                r.set_label("other")
                root.clear_menus()
            })
        }
    })
    signal::connect(r, "clicked", func(mb) {
        mb.show_menu(mn)
    })
    return r
}

var gen_tex_listed = func() {
    var r = gui::VBox()

    var gr = gui::Grid({ columns: 8, padding: 0.01 })
    var packs = capi::texture_get_packs()
    if packs.len() > 0 {
        var sp = r.append(gui::Spacer({ pad_h: 0.005, pad_v: 0.005 }))
        var hb = sp.append(gui::HBox({ padding: 0.02 }))
        hb.append(gui::Label({ text: "Filter by pack:" }))
        hb.append(gen_slot_combo(packs, gr))
    }

    var hb = r.append(gui::HBox())
    var s
    hb.append(gui::Outline({ variant: "normal" }), func(o) {
        o.append(gui::Spacer({ pad_h: 0.005, pad_v: 0.005 }), func(sp) {
            sp.append(gui::Scroller({ clip_w: 0.9, clip_h: 0.6 }), func(sc) {
                sc.append(gr, func(gr) {
                    var slotl = []
                    for i in 0 to capi::slot_get_count() - 1 {
                        slotl.push(i)
                    }
                    slots_populate(gr, slotl)
                })
                s = sc
            })
        })
    })
    hb.append(gui::VScrollbar({ clamp_v: true }), func(sb) {
        sb.append(gui::ScrollButton())
        sb.bind_scroller(s)
    })
    return r
}

var gen_tex_utilized = func() {
    var hb = gui::HBox()
    var s
    hb.append(gui::Outline({ variant: "normal" }), func(o) {
        o.append(gui::Spacer({ pad_h: 0.005, pad_v: 0.005 }), func(sp) {
            sp.append(gui::Scroller({ clip_w: 0.9, clip_h: 0.6 }), func(sc) {
                sc.append(gui::Grid({ columns: 8, padding: 0.01 }), func(gr) {
                    for i in 1 to capi::slot_texmru_num() {
                        var mru = capi::slot_texmru(i - 1)
                        gr.append(gui::Button({ variant: "vslot",
                            index: mru, min_w: 0.095, min_h: 0.095
                        }), func(b) {
                            signal::connect(b, "clicked", \-> capi::slot_set(mru))
                        })
                    }
                })
                s = sc
            })
        })
    })
    hb.append(gui::VScrollbar({ clamp_v: true }), func(sb) {
        sb.append(gui::ScrollButton())
        sb.bind_scroller(s)
    })
    return hb
}

root.new_window("texture", gui.Window, func(win) {
    win.set_floating(true)
    win.set_variant("movable")
    var ttl = gui::HBox({ padding: 0.005 })
    var stat
    var lbtn = ttl.append(gui::Button({ variant: "nobg", label: "Listed", min_w: 0.14 }))
    var ubtn = ttl.append(gui::Button({ variant: "default", label: "Utilized", min_w: 0.14 }))
    signal::connect(lbtn, "clicked", \-> stat.set_state("listed"))
    signal::connect(ubtn, "clicked", \-> stat.set_state("utilized"))
    win.set_title(ttl)
    win.append(gui::State({ state: "utilized" }), func(st) {
        stat = st
        st.update_state("listed"  , gen_tex_listed())
        st.update_state("utilized", gen_tex_utilized())
        signal::connect(st, "state,changed", func(self, nstate) {
            lbtn.set_variant((nstate == "listed") ? "default" : "nobg")
            ubtn.set_variant((nstate != "listed") ? "default" : "nobg")
        })
    })
})

var fields = {
    (svars.StateBoolean): func(hb, nm, ent, dv) {
        var tvar = (dv == "true")
        var ret
        hb.append(gui::Filler({ min_w: 0.4 }), func(f) {
            f.append(gui::Toggle({ variant: "checkbox", condition: \-> tvar,
                align_h: -1
            }), func(t) {
                ret = t
                signal::connect(t, "released", func() {
                    tvar = !tvar
                    capi::makeundoent()
                    ent.set_gui_attr(nm, tostring(tvar))
                })
            })
        })
        return ret
    }
}
var field_def = func(hb, nm, ent, dv) {
    return hb.append(gui::Field({ clip_w: 0.4, value: dv }), func(ed) {
        signal::connect(ed, "value,changed", func(ed, v) {
            capi::makeundoent()
            ent.set_gui_attr(nm, v)
        })
    })
}

root.new_window("entity", gui.Window, func(win) {
    win.set_floating(true)
    win.set_variant("movable")
    var  ent = capi::get_selected_entity()
    if !ent {
        ent = ents::get_player()
    }
    if !ent {
        win.set_title("Entity editing: none")
        win.append(gui::Spacer({ pad_h: 0.04, pad_v: 0.03 },
            gui::Label({ text: "No selected entity" })))
        return
    }
    win.set_title("Entity editing: %s (%d)".format(ent.name, ent.uid))
    var props = []
    var sdata = []
    var sdata_raw = ent.build_sdata()

    var prefix = "_SV_"
    for k, v in pairs(sdata_raw) {
        var sv = ent[prefix ~ k]
        var gn = sv.gui_name
        if gn != false {
            sdata[k] = [ gn || k, v, sv ]
            props.push(k)
        }
    }
    props.sort()

    win.append(gui::HBox(), func(hb) {
        var s
        hb.append(gui::Outline({ variant: "normal" }), func(o) {
            o.append(gui::Spacer({ pad_h: 0.005, pad_v: 0.005 }), func(sp) {
                sp.append(gui::Scroller({ clip_w: 0.9, clip_h: 0.6 }), func(sc) {
                    sc.append(gui::VBox(), func(vb) {
                        var fpf, pf
                        for i, nm in props.each() {
                            var sd = sdata[nm]
                            var gn, dv, sv = sd[0], sd[1], sd[2]
                            vb.append(gui::HBox({ align_h: 1 }), func(hb) {
                                hb.append(gui::Label({ text: " " ~ sd[0]
                                    ~ ": " }))
                                var fld = fields[sv.__proto] || field_def
                                var fd = fld(hb, gn, ent, dv)
                                if pf { pf.set_tab_next(fd) }
                                pf = fd
                                if !fpf { fpf = fd }
                            })
                            if fpf && pf && pf != fpf {
                                pf.set_tab_next(fpf)
                            }
                        }
                    })
                    s = sc
                })
            })
        })
        hb.append(gui::VScrollbar({ clamp_v: true }), func(sb) {
            sb.append(gui::ScrollButton())
            sb.bind_scroller(s)
        })
    })
})

root.new_window("entity_new", gui.Window, func(win) {
    input::save_mouse_position()
    win.set_floating(true)
    win.set_variant("movable")
    win.set_title("New entity")

    var cnames = []
    for k, v in pairs(ents::get_all_prototypes()) {
        if v.is_a(ents.StaticEntity) {
            cnames.push(k)
        }
    }
    cnames.sort()

    win.append(gui::HBox(), func(hb) {
        var s
        hb.append(gui::Outline({ variant: "normal" }), func(o) {
            o.append(gui::Spacer({ pad_h: 0.005, pad_v: 0.005 }), func(sp) {
                sp.append(gui::Scroller({ clip_w: 0.6, clip_h: 0.6 }), func(sc) {
                    sc.append(gui::VBox(), func(vb) {
                        for i, n in cnames.each() {
                            vb.append(gui::Button({
                                variant: "nobg", min_w: 0.3, label: n
                            }), func(btn) {
                                signal::connect(btn, "clicked", func() {
                                    edit::new_entity(n)
                                    root.hide_window("entity_new")
                                })
                            })
                        }
                    })
                    s = sc
                })
            })
        })
        hb.append(gui::VScrollbar({ clamp_v: true }), func(sb) {
            sb.append(gui::ScrollButton())
            sb.bind_scroller(s)
        })
    })
})
