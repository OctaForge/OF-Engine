import core.events.signal
import core.engine.cubescript as cs
import core.gui.core as gui
from std.table import pairs
from std.conv import tonumber, tostring

var root = gui::get_root()

var default_lblcb = \lbl -> tostring(lbl)
var setup_var_widget = func(self, varn, propn, lblcb) {
    lblcb = lblcb || default_lblcb
    var curv = cs::var_get(varn)
    if !curv { return false }
    self["set_" ~ propn](self, lblcb(curv))
    var cid = signal::connect(cs, varn ~ ",changed", func(cs, v) {
        self["set_" ~ propn](self, lblcb(v))
    })
    signal::connect(self, "destroy", func() {
        signal::disconnect(cs, varn ~ ",changed", cid)
    })
}

var gen_combobox = func(varn, names, vals) {
    // generate vals from var if not given
    if !vals {
        vals = []
        var minv = cs::var_get_min(varn)
        var maxv = cs::var_get_max(varn)
        for i in minv to maxv {
            vals.push(i)
        }
    }
    var r = gui::MenuButton({ variant: "combobox", min_w: 0.13 })
    var mn = gui::Filler({ variant: "menu", min_w: 0.2 })
    mn.append(gui::VBox({ clamp: true }), func(vb) {
        for i, val in vals.each() {
            var mb = vb.append(gui::MenuButton({ variant: "submenu",
                label: names[val] || "unknown", clamp_h: true }))
            signal::connect(mb, "clicked", func(mb) {
                cs::var_set(varn, val)
                root.clear_menus()
            })
        }
    })
    setup_var_widget(r, varn, "label", \v -> names[v] || "unknown")
    signal::connect(r, "clicked", func(mb) {
        mb.show_menu(mn)
    })
    return r
}

var gen_checkbox = func(varn, vcfun) {
    var curv = cs::var_get(varn)
    if !curv { return undef }
    var r = gui::Toggle({ variant: "checkbox", condition: \-> curv != 0 })
    if vcfun { vcfun(curv != 0) }
    var cid = signal::connect(cs, varn ~ ",changed", func(cs, v) {
        curv = v
        if vcfun { vcfun(curv != 0) }
    })
    signal::connect(r, "destroy", func() {
        signal::disconnect(cs, varn ~ ",changed", cid)
    })
    signal::connect(r, "released", \-> cs::var_set(varn, (curv != 0) ? 0 : 1))
    return r
}

var gen_opts_game = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, variant: "normal" })
    r.append(gui::VBox())
    return r
}

var gen_opts_edit = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, variant: "normal" })
    r.append(gui::VBox({ clamp: true }),
        func(vb) {
            vb.append(gui::Spacer({ pad_h: 0.02, pad_v: 0.02, clamp: true }),
                func(sp) {
                    sp.append(gui::HBox({ padding: 0.02, expand: true, clamp: true }),
                        func(hb) {
                            hb.append(gui::Label({ text: "Shift floatspeed" }))
                            hb.append(gui::HSlider({ variable: "editfloatspeed", clamp: true }),
                                func(sl) {
                                    sl.append(gui::SliderButton(undef,
                                        gui::Filler({ min_w: 0.08, clamp: true },
                                            gui::EvalLabel({ callback: \-> sl.value }))))
                                }
                            )
                        }
                    )
                }
            )
        }
    )
    return r
}

var gen_opts_graphics = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, variant: "normal" })
    r.append(gui::VBox())
    return r
}

var resolutions = {
    "4:3": [
        "640x480", "800x600", "1024x768", "1152x864", "1280x960",
        "1400x1050", "1600x1200", "1920x1440", "2560x1920"
    ],
    "5:4": [
        "800x640", "960x768", "1280x1024", "1440x1152", "1600x1280",
        "1920x1536", "2560x2048"
    ],
    "16:9": [
        "800x450", "1024x600", "1280x720", "1366x768", "1600x900",
        "1920x1080", "2048x1152", "2560x1440", "3840x2160"
    ],
    "16:10": [
        "768x480", "1024x640", "1280x800", "1440x900", "1680x1050",
        "1920x1200", "2560x1600"
    ]
}

var res_to_aspect = {}
for aspect, resl in pairs(resolutions) {
    for i, res in resl.each() {
        res_to_aspect[res] = aspect
    }
}

var gen_res_submenu = func(ar) {
    var r = gui::Filler({ variant: "menu", min_w: 0.2 })
    r.append(gui::VBox({ clamp: true }), func(vb) {
        for i, res in resolutions[ar].each() {
            var mb = vb.append(gui::MenuButton({ variant: "submenu",
                label: res, clamp_h: true }))
            signal::connect(mb, "clicked", func(mb) {
                var w, h = res.find_match("(%d+)x(%d+)")
                cs::var_set("screenw", tonumber(w))
                cs::var_set("screenh", tonumber(h))
                root.clear_menus()
            })
        }
    })
    return r
}

var gen_res_menu = func() {
    var r = gui::Filler({ variant: "menu", min_w: 0.2 })
    r.append(gui::VBox({ clamp: true }), func(vb) {
        for i, aspect in [ "4:3", "5:4", "16:9", "16:10" ].each() {
            var mb = vb.append(gui::MenuButton({ variant: "submenu",
                label: aspect, clamp_h: true }))
            var sm = gen_res_submenu(aspect)
            signal::connect(mb, "hovering", func(mb) {
                mb.show_menu(sm)
            })
        }
    })
    return r
}

var aniso_names = { 0: "off", 2: "2x", 4: "4x", 8: "8x", 16: "16x" }
var aniso_vals  = [ 0, 2, 4, 8, 16 ]

var aa_names = [ "low", "medium", "high", "ultra" ]

var msaa_names = { 0: "off", 2: "2x", 4: "4x", 8: "8x", 16: "16x" }
var msaa_vals  = [ 0, 2, 4, 8, 16 ]

var add_box = func(vb, fun) {
    vb.append(gui::HBox({ padding: 0.02, expand: true, clamp: true }), fun)
}

var gen_opts_display = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, variant: "normal" })
    r.append(gui::Spacer({ pad_h: 0.02, pad_v: 0.02, clamp: true }), func(sp) {
        sp.append(gui::VBox({ clamp_h: true, padding: 0.01 }),
            func(vb) {
                vb.align(0, -1)
                var sw, sh
                vb.append(gui::HBox({ padding: 0.02, expand: true, clamp: true }),
                    func(hb) {
                        hb.append(gui::Label({ text: "Resolution" }))
                        sw = hb.append(gui::Field({ variable: "screenw", clip_w: 0.10 }))
                        sh = hb.append(gui::Field({ variable: "screenh", clip_w: 0.10 }))
                        hb.append(gui::EvalLabel({ callback: func(self) {
                            var v = res_to_aspect[sw.value ~ "x" ~ sh.value]
                            if !v { v = "custom" }
                            return "\f8" ~ v
                        } }))
                        var mb = hb.append(gui::MenuButton({ variant: "visible",
                            label: "Use preset", min_w: 0.13 }))
                        var resm = gen_res_menu()
                        signal::connect(mb, "clicked", func(mb) {
                            mb.show_menu(resm)
                        })
                    }
                )
                vb.append(gui::Line({ clamp_h: true, variant: "separator" }))
                add_box(vb, func(hb) {
                    hb.append(gui::Label({ text: "Anisotropic filtering" }))
                    hb.append(gen_combobox("aniso", aniso_names, aniso_vals))
                })
                vb.append(gui::Line({ clamp_h: true, variant: "separator" }))
                add_box(vb, func(hb) {
                    hb.append(gui::Label({ text: "Morphological AA" }))
                    hb = hb.append(gui::HBox({ padding: 0.02 }))
                    var cbox = gen_combobox("smaaquality", aa_names)
                    hb.append(gen_checkbox("smaa", func(toggled) {
                        cbox.set_disabled(!toggled)
                    }))
                    hb.append(cbox)
                })
                add_box(vb, func(hb) {
                    hb.append(gui::Spacer({ pad_v: 0.005 },
                        gui::Label({ text: "Temporal AA" })))
                    hb.append(gen_checkbox("tqaa"))
                })
                add_box(vb, func(hb) {
                    hb.append(gui::Label({ text: "FXAA" }))
                    hb = hb.append(gui::HBox({ padding: 0.02 }))
                    var cbox = gen_combobox("fxaaquality", aa_names)
                    hb.append(gen_checkbox("fxaa", func(toggled) {
                        cbox.set_disabled(!toggled)
                    }))
                    hb.append(cbox)
                })
                add_box(vb, func(hb) {
                    hb.append(gui::Label({ text: "Multisample AA" }))
                    hb.append(gen_combobox("msaa", aniso_names, aniso_vals))
                })
                vb.append(gui::Line({ clamp_h: true, variant: "separator" }))
                add_box(vb, func(hb) {
                    hb.append(gui::Label({ text: "Gamma" }))
                    hb.append(gui::HSlider({ variable: "gamma", clamp: true }),
                        func(sl) {
                            sl.append(gui::SliderButton(undef,
                                gui::Filler({ min_w: 0.08, clamp: true },
                                    gui::EvalLabel({ callback: \-> sl.value }))))
                        }
                    )
                })
                vb.append(gui::Line({ clamp_h: true, variant: "separator" }))
                add_box(vb, func(hb) {
                    hb.append(gui::Label({ text: "Vertical sync" }))
                    hb = hb.append(gui::HBox({ padding: 0.02 }))
                    var lbl = gui::Label({ text: "Tear" })
                    var tcb = gen_checkbox("vsynctear")
                    hb.append(gen_checkbox("vsync", func(toggled) {
                        tcb.set_disabled(!toggled)
                        lbl.set_disabled(!toggled)
                    }))
                    hb.append(lbl)
                    hb.append(tcb)
                })
            }
        )
    })
    return r
}

var gen_opts_audio = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, variant: "normal" })
    r.append(gui::Spacer({ pad_h: 0.02, pad_v: 0.02, clamp: true }), func(sp) {
        sp.append(gui::VBox({ clamp_h: true, padding: 0.01 }),
            func(vb) {
                vb.align(0, -1)
                var svl = gui::HSlider({ variable: "soundvol", clamp: true })
                var mvl = gui::HSlider({ variable: "musicvol", clamp: true })
                var mbl = gen_checkbox("mumble")
                var svlbl = gui::Label({ text: "Sound volume", align_h: -1 })
                var mvlbl = gui::Label({ text: "Music volume", align_h: -1 })
                var mblbl = gui::Label({ text: "Mumble positional audio" })
                add_box(vb, func(hb) {
                    hb.append(gui::Label({ text: "Enable audio" }))
                    hb.append(gen_checkbox("sound", func(toggled) {
                       svl.set_disabled(!toggled)
                       mvl.set_disabled(!toggled)
                       mbl.set_disabled(!toggled)
                       svlbl.set_disabled(!toggled)
                       mvlbl.set_disabled(!toggled)
                       mblbl.set_disabled(!toggled)
                    }))
                })
                add_box(vb, func(hb) {
                    hb.append(gui::Filler({ min_w: 0.15 }, svlbl))
                    hb.append(svl, func(sl) {
                        sl.append(gui::SliderButton(undef,
                            gui::Filler({ min_w: 0.08, clamp: true },
                                gui::EvalLabel({ callback: \-> sl.value }))))
                    })
                })
                add_box(vb, func(hb) {
                    hb.append(gui::Filler({ min_w: 0.15 }, mvlbl))
                    hb.append(mvl, func(sl) {
                        sl.append(gui::SliderButton(undef,
                            gui::Filler({ min_w: 0.08, clamp: true },
                                gui::EvalLabel({ callback: \-> sl.value }))))
                    })
                })
                add_box(vb, func(hb) {
                    hb.append(mblbl)
                    hb.append(mbl)
                })
            }
        )
    })
    return r
}

var gen_menu_btn = func(b, lbl, cb) {
    return b.append(gui::Button({ label: lbl, clamp_h: true, variant: "nobg" }),
        func(btn) {
            signal::connect(btn, "clicked", cb)
        }
    )
}

root.new_window("options", gui.Window, func(win) {
    win.set_floating(true)
    win.set_variant("movable")
    win.set_title("Options")
    win.append(gui::HBox({ clamp_h: true }), func(b) {
        var stat
        var btns = []
        b.append(gui::VBox(), func(b) {
            btns.push([ "game"    , gen_menu_btn(b, "Game"    , \-> stat.set_state("game"    )) ])
            btns.push([ "edit"    , gen_menu_btn(b, "Edit"    , \-> stat.set_state("edit"    )) ])
            btns.push([ "graphics", gen_menu_btn(b, "Graphics", \-> stat.set_state("graphics")) ])
            btns.push([ "display" , gen_menu_btn(b, "Display" , \-> stat.set_state("display" )) ])
            btns.push([ "audio"   , gen_menu_btn(b, "Audio"   , \-> stat.set_state("audio"   )) ])
        })
        b.append(gui::Filler({ min_w: 0.005, clamp_v: true }))
        b.append(gui::State({ state: "game" }), func(st) {
            stat = st
            st.update_state("game"    , gen_opts_game())
            st.update_state("edit"    , gen_opts_edit())
            st.update_state("graphics", gen_opts_graphics())
            st.update_state("display" , gen_opts_display())
            st.update_state("audio"   , gen_opts_audio())
            signal::connect(st, "state,changed", func(self, nstate) {
                for i, btn in btns.each() {
                    btn[1].set_variant((btn[0] == nstate) ? "default" : "nobg")
                }
            })
        })
    })
})
