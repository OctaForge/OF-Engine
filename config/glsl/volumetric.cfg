volopt = [ >= (strstr $volumetrictype $arg1) 0 ]

volumetricvariantshader = [
    local volumetrictype
    volumetrictype = $arg3
    maxsteps = $arg4
    spotlight = (>= $arg2 1)
    variantshader 0 $arg1 $arg2 (? (< $arg2 0) [
        attribute vec4 vvertex;
        uniform mat4 lightmatrix;
        void main(void)
        {
            gl_Position = lightmatrix * vvertex;
        }
    ]) [
        @(gfetchdefs tex3)
        @(if (volopt "p") [
            if (|| (volopt "g") (volopt "G")) [if (> $usetexgather 1) [result [
                uniform sampler2DShadow tex4;
            ]] [result [
                uniform sampler2D tex4;
            ]]] [result [
                uniform sampler2DRectShadow tex4;
            ]]
        ])
        uniform vec4 lightpos;
        uniform vec3 lightcolor; 
        @(? $spotlight [
            uniform vec4 spotparams;
        ])
        @(? (volopt "p") [
            uniform vec4 shadowparams;
            uniform vec2 shadowoffset;
            uniform vec2 volshadow;
        ])
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec4 fogdir;
        uniform vec3 fogcolor;
        uniform vec2 fogdensity;
        uniform vec4 radialfogscale;
        uniform vec2 shadowatlasscale;
        uniform vec4 volscale;
        uniform float voldistclamp;
        uniform float volprefilter;
        fragdata(0, fragcolor, vec4)

        @(if (volopt "p") [
            ? $spotlight [
                vec3 getspottc(vec3 dir, float spotdist)
                {
                    vec2 mparams = shadowparams.xy / max(spotdist, 1e-5);
                    return vec3((dir.xy - spotparams.xy*(spotdist + (spotparams.z < 0.0 ? -1.0 : 1.0)*dir.z)*shadowparams.z) * mparams.x + shadowoffset, mparams.y + shadowparams.w);
                }
            ] [
                vec3 getshadowtc(vec3 dir)
                {
                    vec3 adir = abs(dir);
                    float m = max(adir.x, adir.y), mz = max(adir.z, m);
                    vec2 mparams = shadowparams.xy / max(mz, 1e-5);
                    vec4 proj;
                    if(adir.x > adir.y) proj = vec4(dir.zyx, 0.0); else proj = vec4(dir.xzy, 1.0);
                    if(adir.z > m) proj = vec4(dir, 2.0);
                    return vec3(proj.xy * mparams.x + vec2(proj.w, step(proj.z, 0.0)) * shadowparams.z + shadowoffset, mparams.y + shadowparams.w);
                }
            ]
        ])

        @(if (volopt "p") [
            if (|| (volopt "g") (volopt "G")) [
                ? (> $usetexgather 1) [
                    #define filtershadow(shadowtc) float(shadow2D(tex4, shadowtc))
                ] [
                    #define filtershadow(shadowtc) step(shadowtc.z, texture2D(tex4, shadowtc.xy))
                ]
            ] [result [
                #define filtershadow(shadowtc) float(shadow2DRect(tex4, shadowtc))
            ]]
        ])
    
        void main(void)
        {
            vec2 tc = gl_FragCoord.xy * volscale.xy;
            @(gdepthunpack depth [gfetch(tex3, tc)] [
                vec3 pos = (worldmatrix * vec4(depth*tc, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(tc, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            vec2 dither = fract((gl_FragCoord.xy - 0.5)*0.5); 
            vec3 camlight = lightpos.xyz - camera * lightpos.w;
            float inside = 1.0 - dot(camlight, camlight);
            vec3 ray = pos.xyz - camera;
            float dist2 = dot(ray, ray), invdist = inversesqrt(dist2), radialdist = min(dist2 * invdist, voldistclamp);
            ray *= invdist;
            float v = dot(camlight, ray), d = inside + v*v;
            float light = 0.0;
            if(d > 0)
            {
                d = sqrt(d);
                float front = max(v - d, 0.0), back = min(v + d, radialdist * lightpos.w), dist = back - front, stepdist = d * @(divf 2.0 $maxsteps);
                if(dist > @volminstep*stepdist)
                {
                    vec3 lightdir = camera * lightpos.w + ray * (back + stepdist*dot(dither, vec2(0.5, 1.0))) - lightpos.xyz;
                    vec3 step = ray * -stepdist;
                    for(int i = 0; i < @maxsteps; i++)
                    {
                        lightdir += step;
                        @(if $spotlight [result [
                            float lightdist2 = dot(lightdir, lightdir);
                            float lightinvdist = inversesqrt(lightdist2); 
                            float spotdist = dot(lightdir, spotparams.xyz);
                            float spotatten = 1.0 - (1.0 - lightinvdist * spotdist) * spotparams.w;
                            if(spotatten > 0.0)
                            {
                                float lightatten = clamp(1.0 - lightdist2 * lightinvdist, 0.0, 1.0);
                                @(? (volopt "p") [
                                    vec3 spottc = getspottc(lightdir, spotdist);
                                    lightatten *= spotatten * (filtershadow(spottc)*volshadow.x + volshadow.y);
                                ])
                                light += lightatten;
                            }
                        ]] [result [
                            float lightatten = clamp(1.0 - length(lightdir), 0.0, 1.0);
                            @(? (volopt "p") [
                                vec3 shadowtc = getshadowtc(lightdir);
                                lightatten *= filtershadow(shadowtc)*volshadow.x + volshadow.y;
                            ])
                            light += lightatten;
                        ]])
                        dist -= stepdist;
                        if(dist <= 0) break; 
                    }
                    float fogcoord = front/lightpos.w;
                    float foglerp = clamp(exp2(fogcoord*fogdensity.x)*fogdensity.y, 0.0, 1.0);
                    light *= foglerp * stepdist;
                }
            }
            vec2 weights = step(fwidth(radialdist), volprefilter) * (2.0*dither - 0.5);
            light -= dFdx(light) * weights.x;
            light -= dFdy(light) * weights.y;
            fragcolor.rgb = light * lightcolor;
            fragcolor.a = 0.0;
        }
    ]
]

volumetricshader = [
    volumetrictype = (concatword $arg1 $arg2)
    shadername = (concatword "volumetric" $volumetrictype $arg3)
    volumetricvariantshader $shadername -1 $arg1 $arg3
    volumetricvariantshader $shadername 0 (concatword $arg1 $arg2) $arg3
    if (volopt "s") [
        volumetricvariantshader $shadername 1 $arg1 $arg3
        volumetricvariantshader $shadername 2 (concatword $arg1 $arg2) $arg3    
    ]
]

