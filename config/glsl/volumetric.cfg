volopt = [ >= (strstr $volumetrictype $arg1) 0 ]

volumetricvariantshader = [
    local volumetrictype
    volumetrictype = $arg3
    maxsteps = $arg4
    spotlight = (>= $arg2 1)
    variantshader 0 $arg1 $arg2 (? (< $arg2 0) [
        attribute vec4 vvertex;
        uniform mat4 lightmatrix;
        void main(void)
        {
            gl_Position = lightmatrix * vvertex;
        }
    ]) [
        @(gfetchdefs tex3)
        @(if (volopt "p") [
            if (|| (volopt "g") (volopt "G")) [if (> $usetexgather 1) [result [
                uniform sampler2DShadow tex4;
            ]] [result [
                uniform sampler2D tex4;
            ]]] [result [
                uniform sampler2DRectShadow tex4;
            ]]
        ])
        uniform vec4 lightpos;
        uniform vec3 lightcolor; 
        @(? $spotlight [
            uniform vec4 spotparams;
        ])
        @(? (volopt "p") [
            uniform vec4 shadowparams;
            uniform vec2 shadowoffset;
        ])
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec4 fogdir;
        uniform vec3 fogcolor;
        uniform vec2 fogdensity;
        uniform vec4 radialfogscale;
        uniform vec2 shadowatlasscale;
        uniform vec4 volscale;
        uniform float voldistclamp;
        uniform float volprefilter;
        fragdata(0, fragcolor, vec4)

        @(if (volopt "p") [
            ? $spotlight [
                vec3 getspottc(vec3 dir, float spotdist)
                {
                    vec2 mparams = shadowparams.xy / max(spotdist, 1e-5);
                    return vec3((dir.xy - spotparams.xy*(spotdist + (spotparams.z < 0.0 ? -1.0 : 1.0)*dir.z)*shadowparams.z) * mparams.x + shadowoffset, mparams.y + shadowparams.w);
                }
            ] [
                vec3 getshadowtc(vec3 dir)
                {
                    vec3 adir = abs(dir);
                    float m = max(adir.x, adir.y), mz = max(adir.z, m);
                    vec2 mparams = shadowparams.xy / max(mz, 1e-5);
                    vec4 proj;
                    if(adir.x > adir.y) proj = vec4(dir.zyx, 0.0); else proj = vec4(dir.xzy, 1.0);
                    if(adir.z > m) proj = vec4(dir, 2.0);
                    return vec3(proj.xy * mparams.x + vec2(proj.w, step(proj.z, 0.0)) * shadowparams.z + shadowoffset, mparams.y + shadowparams.w);
                }
            ]
        ])

        @(if (volopt "p") [
            if (|| (volopt "g") (volopt "G")) [
                ? (> $usetexgather 1) [
                    #define filtershadow(shadowtc) float(shadow2D(tex4, vec3(shadowtc.xy*shadowatlasscale, shadowtc.z)))
                ] [
                    #define filtershadow(shadowtc) step(shadowtc.z, float(texture2D(tex4, shadowtc.xy*shadowatlasscale)))
                ]
            ] [result [
                #define filtershadow(shadowtc) float(shadow2DRect(tex4, shadowtc))
            ]]
        ])
    
        void main(void)
        {
            vec2 tc = gl_FragCoord.xy * volscale.xy;
            @(gdepthunpack depth [gfetch(tex3, tc)] [
                vec3 pos = (worldmatrix * vec4(depth*tc, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(tc, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            vec3 ray = pos.xyz - camera;
            float dist2 = dot(ray, ray), invdist = inversesqrt(dist2), radialdist = min(dist2 * invdist, voldistclamp);
            ray *= invdist;
            vec3 camlight = lightpos.xyz - camera * lightpos.w;
            float camlight2 = dot(camlight, camlight), v = dot(camlight, ray), d = v*v + 1.0 - camlight2;
            float light = 0.0;
            if(d > 0)
            {
                @(? $spotlight [
                    float spotangle = 1.0 - 1.0/spotparams.w, spotangle2 = spotangle*spotangle,
                          rayspot = dot(ray, spotparams.xyz), camspot = dot(camlight, spotparams.xyz),
                          qa = spotangle2 - rayspot*rayspot,
                          qb = rayspot*camspot - spotangle2*v,
                          qc = spotangle2*camlight2 - camspot*camspot;
                    float disc = qb*qb - qa*qc;
                    if(disc > 0)
                    {
                        d = sqrt(d);
                        disc = abs(sqrt(disc)/qa);
                        float t = -qb/qa,
                              front = max(max(v - d, t - disc), 0.0),
                              back = min(min(v + d, t + disc), radialdist * lightpos.w);
                        d = min(d, disc);
                ] [
                    d = sqrt(d);
                    float front = max(v - d, 0.0), back = min(v + d, radialdist * lightpos.w);
                ])
                float space = back - front, stepdist = d * @(divf 2.0 $maxsteps);
                if(space > @volminstep*stepdist)
                {
                    float dither = dot(fract((gl_FragCoord.xy - 0.5).xyxy*vec4(0.5, 0.5, 0.25, 0.25)), vec4(0.375, 0.9375, 0.25, 0.125));
                    vec3 lightdir = camera * lightpos.w + ray * (back + stepdist*dither) - lightpos.xyz;
                    vec3 raystep = ray * -stepdist;
                    for(int i = 0; i < @maxsteps; i++)
                    {
                        lightdir += raystep;
                        @(if $spotlight [result [
                            float lightdist2 = dot(lightdir, lightdir);
                            float lightinvdist = inversesqrt(lightdist2); 
                            float spotdist = dot(lightdir, spotparams.xyz);
                            float spotatten = 1.0 - (1.0 - lightinvdist * spotdist) * spotparams.w;
                            if(spotatten > 0.0)
                            {
                                float lightatten = clamp(1.0 - lightdist2 * lightinvdist, 0.0, 1.0);
                                @(? (volopt "p") [
                                    vec3 spottc = getspottc(lightdir, spotdist);
                                    lightatten *= spotatten * filtershadow(spottc);
                                ])
                                light += lightatten;
                            }
                        ]] [result [
                            float lightatten = clamp(1.0 - length(lightdir), 0.0, 1.0);
                            @(? (volopt "p") [
                                vec3 shadowtc = getshadowtc(lightdir);
                                lightatten *= filtershadow(shadowtc);
                            ])
                            light += lightatten;
                        ]])
                        space -= stepdist;
                        if(space <= 0) break; 
                    }
                    float fogcoord = front/lightpos.w;
                    float foglerp = clamp(exp2(fogcoord*fogdensity.x)*fogdensity.y, 0.0, 1.0);
                    light *= foglerp * stepdist;
                    @(? $spotlight [
                        light /= min(2.0*disc, 1.0);
                    ])
                }
                @(? $spotlight [}])
            }
            vec2 weights = step(fwidth(radialdist), volprefilter) * (2.0*fract((gl_FragCoord.xy - 0.5)*0.5) - 0.5);
            light -= dFdx(light) * weights.x;
            light -= dFdy(light) * weights.y;
            fragcolor.rgb = light * lightcolor;
            fragcolor.a = 0.0;
        }
    ]
]

volumetricshader = [
    volumetrictype = (concatword $arg1 $arg2)
    shadername = (concatword "volumetric" $volumetrictype $arg3)
    volumetricvariantshader $shadername -1 $arg1 $arg3
    volumetricvariantshader $shadername 0 (concatword $arg1 $arg2) $arg3
    if (volopt "s") [
        volumetricvariantshader $shadername 1 $arg1 $arg3
        volumetricvariantshader $shadername 2 (concatword $arg1 $arg2) $arg3    
    ]
]

volumetricblurvariantshader = [
    maxradius = $arg2
    filterdir = $arg3
    shader 0 $arg1 [
        attribute vec4 vvertex;
        @(screentexcoord 0)
        varying vec2 texcoord0;
        void main(void)
        {
            gl_Position = vvertex;
            texcoord0 = vtexcoord0; 
        }
    ] [
        uniform sampler2DRect tex0;
        varying vec2 texcoord0;
        fragdata(0, fragcolor, vec4)
        void main(void)
        {
            #define texoff(i) @(? (=s $filterdir "x") [ivec2(i, 0)] [ivec2(0, i)])
            #define inrange(x,y) (dot(x - y, vec3(@lumweights)) < @volblurthreshold)
            vec3 color0 = texture2DRect(tex0, texcoord0).rgb;
            vec3 color1 = texture2DRectOffset(tex0, texcoord0, texoff(-2)).rgb;
            vec3 color2 = texture2DRectOffset(tex0, texcoord0, texoff(2)).rgb;
            @(? (> $maxradius 1) [
                vec3 color3 = texture2DRectOffset(tex0, texcoord0, texoff(-4)).rgb;
                vec3 color4 = texture2DRectOffset(tex0, texcoord0, texoff(4)).rgb;
                vec4 color = vec4(0.4 * color0, 0.4);
                if(inrange(color0, color1)) color += vec4(0.2 * color1, 0.2);
                if(inrange(color0, color2)) color += vec4(0.2 * color2, 0.2);
                if(inrange(color0, color3)) color += vec4(0.1 * color3, 0.1);
                if(inrange(color0, color4)) color += vec4(0.1 * color4, 0.1);
            ] [
                vec4 color = vec4(0.5 * color0, 0.5);
                if(inrange(color0, color1)) color += vec4(0.25 * color1, 0.25);
                if(inrange(color0, color2)) color += vec4(0.25 * color2, 0.25);
            ])
            fragcolor = vec4(color.rgb / color.a, 0.0);
        }
    ]
]

volumetricblurshader = [
    volumetricblurvariantshader (concatword "volumetricblurx" $arg1) $arg1 x
    volumetricblurvariantshader (concatword "volumetricblury" $arg1) $arg1 y
]

