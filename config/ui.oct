import capi
import core.events.signal
import core.gui.core as gui
import core.engine.cubescript as cs

from std.conv import tostring, tonumber
from std.table import len, pairs

import std.math

var root = gui::get_root()

var var_get = cs.var_get
var cs_execute = cs.execute

/* Main menu */

var gen_menu_default = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, color: 0x303030 })
    r.append(gui::VBox(), func(vb) {
        vb.append(gui::Label({ text: "Welcome to OctaForge!", scale: 1.5,
            color: 0x88FF88
        }))
        vb.append(gui::Label({ text: "Please start by clicking one of the "
            "menu items." }))
    })
    return r
}

var gen_map_list = func(img, vb) {
    var glob, loc = capi::get_all_map_names()
    var current_preview

    var ml_section = func(lbl, arr) {
        vb.append(gui::Filler({ min_h: 0.005 }))
        vb.append(gui::Label({ text: lbl, color: 0x88FF88 }))
        vb.append(gui::Filler({ min_h: 0.002 }))

        for i, map in arr.each() {
            vb.append(gui::Button({ label: map, clamp_h: true,
                variant: "nobg", min_w: 0.2
            }), func(btn) {
                signal::connect(btn, "hovering", func() {
                    if map != current_preview {
                        current_preview = map
                        img.set_tex("media/map/" ~ map ~ "/preview")
                    }
                })
                signal::connect(btn, "leaving", func() {
                    current_preview = undef
                    img.set_tex(undef)
                })
                signal::connect(btn, "clicked", func() {
                    cs_execute("map " ~ map)
                })
            })
        }
        if arr.empty() {
            vb.append(gui::Label({ text: "(None available)", color: 0xFF6666,
                scale: 0.8 }))
        }
    }

    ml_section("Global maps", glob)
    ml_section("Local maps", loc)
}

var gen_menu_map_load = func() {
    var s
    var r = gui::HBox()
    r.append(gui::Outline({ color: 0x303030 }), func(o) {
        o.append(gui::Spacer({ pad_h: 0.005, pad_v: 0.005 }), func(sp) {
            sp.append(gui::Scroller({ clip_w: 0.6, clip_h: 0.5 }), func(sc) {
                s = sc
                sc.append(gui::HBox({ padding: 0.01 }), func(hb) {
                    var im
                    hb.append(gui::Spacer({ pad_h: 0.02, pad_v: 0.02 },
                        gui::Image({ min_w: 0.3, min_h: 0.3,
                            __init: func(img) { im = img } },
                            gui::Outline({ clamp: true, color: 0x303030 }))))
                    hb.append(gui::VBox(), func(vb) {
                        vb.align(0, -1)
                        gen_map_list(im, vb)
                    })
                })
            })
        })
    })
    return r
}

var gen_menu_credits = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, color: 0x303030 })
    r.append(gui::VBox(undef,
        gui::Label({ text: "OctaForge is brought to you by:",
            color: 0x88FF88 }),
        gui::Filler({ min_h: 0.01, clamp_h: true }),
        gui::Label({ text: 'Daniel \f1"q66"\f7 Kolesa' }),
        gui::Label({ text: "project leader and main programmer",
            scale: 0.8 }),
        gui::Filler({ min_h: 0.008, clamp_h: true }),
        gui::Label({ text: 'Lee \f1"eihrul"\f7 Salzman' }),
        gui::Label({ text: 'David \f1"dkreuter"\f7 Kreuter' }),
        gui::Label({ text: 'Dale \f1"graphitemaster"\f7 Weiler' }),
        gui::Label({ text: "code contributors", scale: 0.8 }),
        gui::Filler({ min_h: 0.01, clamp_h: true }),
        gui::Label({ text: "Based on Tesseract created by:",
            color: 0x88FF88 }),
        gui::Filler({ min_h: 0.01, clamp_h: true }),
        gui::Label({ text: 'Lee \f1"eihrul"\f7 Salzman' }),
        gui::Label({ text: "and others",  scale: 0.8 }),
        gui::Filler({ min_h: 0.01, clamp_h: true }),
        gui::Label({ text: "The original Cube 2 engine:",
            color: 0x88FF88 }),
        gui::Filler({ min_h: 0.01, clamp_h: true }),
        gui::Label({ text: 'Wouter \f1"aardappel"\f7 van '
            ~ 'Oortmerssen' }),
        gui::Label({ text: 'Lee \f1"eihrul"\f7 Salzman' }),
        gui::Label({ text: "and others",  scale: 0.8 }),
        gui::Filler({ min_h: 0.01, clamp_h: true }),
        gui::Label({ text: "Formerely based on Syntensity created by:",
            color: 0x88FF88 }),
        gui::Filler({ min_h: 0.01, clamp_h: true }),
        gui::Label({ text: 'Alon \f1"kripken"\f7 Zakai' }),
        gui::Filler({ min_h: 0.01, clamp_h: true })
    ))
    return r
}

var gen_menu_btn = func(b, lbl, cb) {
    b.append(gui::Button({ label: lbl, clamp_h: true, variant: "nobg" }),
        func(btn) {
            signal::connect(btn, "clicked", cb)
        }
    )
}

root.new_window("main", gui.Window, func(win) {
    win.set_floating(true)
    win.set_variant("movable")
    win.set_title("Main menu")
    win.append(gui::HBox({ clamp_h: true }), func(b) {
        var stat
        b.append(gui::VBox(), func(b) {
            gen_menu_btn(b, "Load map", \-> stat.set_state("load_map"))
            gen_menu_btn(b, "Options", \-> root.show_window("options"))
            gen_menu_btn(b, "Credits", \-> stat.set_state("credits"))
            gen_menu_btn(b, "Quit", \-> cs_execute("quit"))
        })
        b.append(gui::Filler({ min_w: 0.005, clamp_v: true }))
        b.append(gui::State({ state: "default" }), func(st) {
            stat = st
            st.update_state("default" , gen_menu_default())
            st.update_state("load_map", gen_menu_map_load())
            st.update_state("credits" , gen_menu_credits())
        })
    })
})

var gen_opts_game = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, color: 0x303030 })
    r.append(gui::VBox())
    return r
}

var gen_opts_edit = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, color: 0x303030 })
    r.append(gui::VBox({ clamp: true }),
        func(vb) {
            vb.append(gui::Spacer({ pad_h: 0.02, pad_v: 0.02, clamp: true }),
                func(sp) {
                    sp.append(gui::HBox({ padding: 0.02, expand: true, clamp: true }),
                        func(hb) {
                            hb.append(gui::Label({ text: "Shift floatspeed" }))
                            hb.append(gui::HSlider({ variable: "editfloatspeed", clamp: true }),
                                func(sl) {
                                    sl.append(gui::SliderButton(undef, gui::EvalLabel({
                                        callback: \-> sl.value, scale: 0.6 })))
                                }
                            )
                        }
                    )
                }
            )
        }
    )
    return r
}

var gen_opts_graphics = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, color: 0x303030 })
    r.append(gui::VBox())
    return r
}

var gen_opts_display = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, color: 0x303030 })
    r.append(gui::VBox())
    return r
}

var aspect_ratios = [ "4:3", "5:4", "16:9", "16:10", "custom" ]

var resolutions = {
    "4:3": [
        "640x480", "800x600", "1024x768", "1152x864", "1280x960",
        "1400x1050", "1600x1200", "1920x1440", "2560x1920"
    ],
    "5:4": [
        "800x640", "960x768", "1280x1024", "1440x1152", "1600x1280",
        "1920x1536", "2560x2048"
    ],
    "16:9": [
        "800x450", "1024x600", "1280x720", "1366x768", "1600x900",
        "1920x1080", "2048x1152", "2560x1440", "3840x2160"
    ],
    "16:10": [
        "768x480", "1024x640", "1280x800", "1440x900", "1680x1050",
        "1920x1200", "2560x1600"
    ]
}

var gen_opts_resolution = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, color: 0x303030 })
    r.append(gui::VBox())
    return r
}

var gen_opts_audio = func() {
    var r = gui::Outline({ min_w: 0.6, min_h: 0.5, color: 0x303030 })
    r.append(gui::VBox())
    return r
}

root.new_window("options", gui.Window, func(win) {
    win.set_floating(true)
    win.set_variant("movable")
    win.set_title("Options")
    win.append(gui::HBox({ clamp_h: true }), func(b) {
        var stat
        b.append(gui::VBox(), func(b) {
            gen_menu_btn(b, "Game"      , \-> stat.set_state("game"))
            gen_menu_btn(b, "Edit"      , \-> stat.set_state("edit"))
            gen_menu_btn(b, "Graphics"  , \-> stat.set_state("graphics"))
            gen_menu_btn(b, "Display"   , \-> stat.set_state("display"))
            gen_menu_btn(b, "Resolution", \-> stat.set_state("resolution"))
            gen_menu_btn(b, "Audio"     , \-> stat.set_state("audio"))
        })
        b.append(gui::Filler({ min_w: 0.005, clamp_v: true }))
        b.append(gui::State({ state: "game" }), func(st) {
            stat = st
            st.update_state("game"      , gen_opts_game())
            st.update_state("edit"      , gen_opts_edit())
            st.update_state("graphics"  , gen_opts_graphics())
            st.update_state("display"   , gen_opts_display())
            st.update_state("resolution", gen_opts_resolution())
            st.update_state("audio"     , gen_opts_audio())
        })
    })
});

/* Console and editing */

root.new_window("fullconsole", gui.Overlay, func(win) {
    win.clamp(true, true, false, false)
    win.align(0, -1)
    capi::console_full_show(true)
    signal::connect(win, "destroy", \-> capi::console_full_show(false))
    win.append(gui::Console({
        min_h: \-> var_get("fullconsize") / 100, clamp: true
    }))
})

root.new_window("editstats", gui.Overlay, func(win) {
    win.align(-1, 1)
    win.set_above_hud(true)
    win.append(gui::Filler({ variant: "edithud" }), func(fl) {
        fl.append(gui::Spacer({ pad_h: 0.015, pad_v: 0.01 }), func(sp) {
            sp.append(gui::EvalLabel({ scale: -1,
                callback: \-> cs_execute("getedithud") })).align(-1, 0)
        })
    })
})

var editvars = [ "allfaces", "entselsnap", "entediting", "fullbright", "showmat", "nompedit" ]

import core.network.msg

var vicon_cb = func(self) {
    var varn = self.varn
    if cs::var_get(varn) == 1 {
        self.color.a = 0xFF
        return self.cvarn
    } else {
        self.color.a = 0x80
        return varn
    }
}

root.new_window("varicons", gui.Overlay, func(win) {
    win.align(1, 1)
    var is_local = msg::is_local()
    win.append(gui::Spacer({ pad_h: 0.01, pad_v: 0.1 }), func(sp) {
        sp.append(gui::VBox(), func(vb) {
            for i, v in editvars.each() {
                if is_local && i == (editvars.len() - 1) { break }
                vb.append(gui::EvalLabel({ callback: vicon_cb, font: "default_outline", scale: -1 }), func(lbl) {
                    lbl.align(1, 0)
                    lbl.varn = v
                    lbl.cvarn = "\f8" ~ v
                })
            }
        })
    })
})

/* 2048 game, OctaForge edition
 * Just for testing/fun */

var genblock = \val, color, tcolor -> \-> gui::ColorFiller({
    color: color, min_w: 0.18, min_h: 0.18 },
    gui::Label({
        text: tostring(val), scale: 3.5, color: tcolor
    }))

var blocktypes = {
    0: \-> gui::ColorFiller({
        color: 0xccc0b3, min_w: 0.18, min_h: 0.18
    }),
    2:    genblock(2,    0xEEE4DA, 0x776E65),
    4:    genblock(4,    0xEDE0C8, 0x776E65),
    8:    genblock(8,    0xF2B179, 0xF9F6F2),
    16:   genblock(16,   0xF59563, 0xF9F6F2),
    32:   genblock(32,   0xF67C5F, 0xF9F6F2),
    64:   genblock(64,   0xF65E3B, 0xF9F6F2),
    128:  genblock(128,  0xEDCF72, 0xF9F6F2),
    256:  genblock(256,  0xEDCC61, 0xF9F6F2),
    512:  genblock(512,  0xEDC850, 0xF9F6F2),
    1024: genblock(1024, 0xEDC53F, 0xF9F6F2),
    2048: genblock(2048, 0xEDC22E, 0xF9F6F2),
    4096: genblock(4096, 0x3C3A32, 0xF9F6F2)
}

var tiles   = []
var cleanup = []

var totalscore = 0
var gamestate  = 0

var cleanuptiles = func() {
    for i, v in cleanup.each() { v.destroy() }
}

var seedtiles = func() {
    var t1, t2 = math::random(0, 16)
    repeat { t2 = math::random(0, 16) } until t2 != t1
    var vals = [ 2, 4 ]
    var tv1, tv2 = vals[math::random(0, 2)],
                   vals[math::random(0, 2)]
    for i in 0 to 15 {
        if i == t1 {
            tiles.push(tv1)
        } else if i == t2 {
            tiles.push(tv2)
        } else {
            tiles.push(0)
        }
    }
}

var randtile = func(grid) {
    var emptyfields = []
    for i in 0 to 15 {
        if tiles[i] == 0 { emptyfields.push(i) }
    }
    if emptyfields.empty() { return }
    var n = emptyfields[math::random(0, emptyfields.len())]
    tiles[n] = ([ 2, 4 ])[math::random(0, 2)]
    grid.remove(n)
    grid.insert(n, blocktypes[tiles[n]]())
    if emptyfields.len() == 1 {
        // check game over (yes if nothing is mergeable)
        if gamestate == 0 {
            gamestate = -1
            for a in 1 to 2 {
                var ia, ib, ic, ja, jb, jc
                if a == 1 {
                    ia, ib, ic = 0, 12, 4
                    ja, jb, jc = 1, 3, 1
                } else {
                    ia, ib, ic = 0, 3, 1
                    ja, jb, jc = 1, 13, 4
                }
                for i in ia to ib by ic {
                    for j in ja + i to jb + i by jc {
                        if tiles[j - 1] == tiles[j + jc - 1] {
                            gamestate = 0
                            break
                        }
                    }
                    if gamestate >= 0 { break }
                }
                if gamestate >= 0 { break }
            }
            if gamestate == 0 {
                for i in 0 to tiles.len() - 1 {
                    if tiles[i] == 2048 {
                        gamestate = 1
                        break
                    }
                }
            }
        }
    }
}

var pendinganims = 0

var guimovetile = func(grid, i, j, step, hdir, vdir) {
    var o = grid.remove(j - 1, true)
    var oadj = o.adjust
    grid.insert(j - 1, blocktypes[0]())
    var n = (j - i) / step
    var dist = 0.205 * n
    var dirn, mspeed, dx, dy
    if hdir != 0 {
        dirn, mspeed = "speedup,x", 3 * n * hdir
        dx, dy = dist, 0
    } else {
        dirn, mspeed = "speedup,y", 3 * n * vdir
        dx, dy = 0, dist
    }
    grid.parent.append(gui::Animator({
        move_func: dirn, move_speed: mspeed,
        move_dist_x: dx, move_dist_y: dy,
        clamp: true
    }, o), func(m) {
        signal::connect(m, "anim,start", func() {
            pendinganims += 1
        })
        signal::connect(m, "anim,end", func() {
            m.set_visible(false)
            cleanup.push(m)
            grid.remove(i - 1)
            grid.insert(i - 1, blocktypes[tiles[i - 1]]())
            pendinganims -= 1
            if pendinganims == 0 {
                randtile(grid)
            }
            grid.layout()
        })
        m.start()
        grid.parent.append(m)
    })
    o.floating = true
    o.adjust   = 0
}

var movetile = func(grid, off, hdir, vdir) {
    var dir = (hdir != 0) && hdir || (vdir * 4)
    var lbeg, lend, lstart
    if dir < 0 {
        if hdir != 0 {
            lbeg, lend, lstart = 2, 4, 1
        } else {
            lbeg, lend, lstart = 5, 13, 1
        }
    } else {
        if hdir != 0 {
            lbeg, lend, lstart = 3, 1, 4
        } else {
            lbeg, lend, lstart = 9, 1, 13
        }
    }
    var jm = false
    for i in lbeg to lend by -dir {
        var nnz
        for j in i + dir to lstart by dir {
            if tiles[j + off - 1] != 0 {
                nnz = j
                break
            }
        }
        if nnz && !jm && tiles[nnz + off - 1] == tiles[i + off - 1] {
            jm = true
            tiles[nnz + off - 1] += tiles[i + off - 1]
            tiles[i + off - 1] = 0
            guimovetile(grid, nnz + off, i + off, -dir, hdir, vdir)
            totalscore += tiles[nnz + off - 1]
        } else if tiles[i + off - 1] != 0 {
            jm = false
            var fz
            for j in i + dir to lstart by dir {
                if tiles[j + off - 1] == 0 { fz = j }
            }
            if fz {
                tiles[fz + off - 1] = tiles[i + off - 1]
                tiles[i + off - 1] = 0
                guimovetile(grid, fz + off, i + off, -dir, hdir, vdir)
            }
        }
    }
}

var movetiles = func(grid, h, v) {
    if h != 0 {
        movetile(grid, 0,  h, 0)
        movetile(grid, 4,  h, 0)
        movetile(grid, 8,  h, 0)
        movetile(grid, 12, h, 0)
    }
    if v != 0 {
        movetile(grid, 0, 0, v)
        movetile(grid, 1, 0, v)
        movetile(grid, 2, 0, v)
        movetile(grid, 3, 0, v)
    }
    cleanuptiles()
}

var gamestates = {
    (-1): "2048 (game over, score: %d)",
    ( 0): "2048 (score: %d)",
    ( 1): "2048 (you won! score: %d)"
}

var seededtiles = false
root.new_window("2048", gui.Window, func(win) {
    win.set_floating(true)
    win.set_variant("movable")
    win.set_title("2048 (score: 0)")
    signal::connect(win, "destroy", func() { totalscore = 0 })
    win.append(gui::ColorFiller({ color: 0xBBADA0, clamp: true }), func(cf) {
        win.append(gui::Spacer({ pad_h: 0.025, pad_v: 0.025 }), func(sp) {
            sp.append(gui::Grid({ columns: 4, padding: 0.025 }), func(grid) {
                cf.key = func(self, code, isdown) {
                    if isdown {
                        if code == gui.key.LEFT {
                            movetiles(grid, -1,  0)
                        } else if code == gui.key.RIGHT {
                            movetiles(grid,  1,  0)
                        } else if code == gui.key.UP {
                            movetiles(grid,  0, -1)
                        } else if code == gui.key.DOWN {
                            movetiles(grid,  0,  1)
                        }
                    }
                    if gamestate < 0 { cf.key = undef }
                    win.set_title(gamestates[gamestate].format(totalscore))
                    return gui.Widget::key(self, code, isdown)
                }
                if gamestate < 0 {
                    totalscore, gamestate, seededtiles, tiles = 0, 0, false, []
                }
                if !seededtiles {
                    seedtiles()
                    seededtiles = true
                }
                for i in 0 to tiles.len() - 1 {
                    grid.append(blocktypes[tiles[i]]())
                }
            })
        })
    })
})
